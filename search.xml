<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ELK分布式部署</title>
    <url>/2023/06/04/ELK%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>微服务</tag>
        <tag>ELK</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>java项目安全问题</title>
    <url>/2023/06/04/Java%E9%A1%B9%E7%9B%AE%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p><strong>1.弱口令漏洞</strong></p>
<blockquote>
<p>解决方案：最好使用至少6位的数字、字母及特殊字符组合作为密码。数据库不要存储明文密码，应存储MD5加密后的密文，由于目前普通的MD5加密已经可以被破解，最好可以多重MD5加密，或者多种加密方式叠加组合。</p>
</blockquote>
<p><strong>2.未使用用户名及密码登录后台可直接输入后台URL登录系统。</strong></p>
<blockquote>
<p>解决方案：通过配置filter来过滤掉无效用户的连接请求。</p>
</blockquote>
<p><strong>3．JSP页面抛出的异常可能暴露程序信息。有经验的入侵者，可以从JSP程序的异常中获取很多信息，比如程序的部分架构、程序的物理路径、SQL注入爆出来的信息等。</strong></p>
<blockquote>
<p>解决方案：自定义一个Exception，将异常信息包装起来不要抛到页面上。</p>
</blockquote>
<p><strong>4.合法用户”注销”后，在未关闭浏览器的情况下，点击浏览器”后退”按钮，可从本地页面缓存中读取数据，绕过了服务端filter过滤。</strong></p>
<blockquote>
<blockquote>
<p>解决方案：配置filter对存放敏感信息的页面限制页面缓存。如：</p>
</blockquote>
<p>httpResponse.setHeader(“Cache-Control”,”no-cache”);<br>httpResponse.setHeader(“Cache-Control”,”no-store”);<br>httpResponse.setDateHeader(“Expires”, 0);<br>httpResponse.setHeader(“Pragma”,”no-cache”);</p>
</blockquote>
<p><strong>5.SQL注入漏洞。</strong></p>
<blockquote>
<p>解决方案：在数据库访问层中不要使用”+”来拼接SQL语句！如：</p>
<p>String sql&#x3D; “SELECT * FROM USERS WHERE 1&#x3D;1”; if(null !&#x3D;<br>user.getUserName() &amp;&amp; !””.equals(user.getUserName())){<br>sql +&#x3D; “ and UNAME &#x3D; ‘“+user.getUserName()+”‘“; } 而应使用PreparedStatement。如：</p>
<p>PreparedStatement pstmt &#x3D; con.prepareStatement(“SELECT * FROM USERS<br>WHERE UNAME&#x3D;?”); pstmt.setString(1, “Neeke”);<br>如果项目中使用了Hibernate框架，则推荐使用named parameter。如：</p>
<p>String queryString &#x3D; “from Users where uname like :name”; 冒号后面是一个named<br>parameter，我们可以使用Query接口将一个参数绑定到name参数上：</p>
<p>List result &#x3D; session.createQuery(queryString)<br>.setString(“name”, user.getUserName())<br>.list();</p>
</blockquote>
<p><strong>6.文件上传漏洞。前台仅使用JS对文件后缀做了过滤，这只能针对普通的用户，而恶意攻击者完全可以修改表单去掉JS校验。</strong></p>
<blockquote>
<p>解决方案：前台JS过滤加服务器端程序过滤。具体过滤掉哪些文件类型视具体情况而定。</p>
</blockquote>
<p><strong>7.可执行脚本漏洞。对用户提交的数据未转义，一些用户提交的含有JavaScript脚本的信息被直接输出到页面中从而被浏览器执行。</strong></p>
<blockquote>
<p>解决方案：使用org.apache.commons.lang.StringEscapeUtils对用户提交的数据进行转义。如：</p>
<p>@RequestMapping(params&#x3D;”method&#x3D;addTopic”,method&#x3D;RequestMethod.POST)<br>public ModelAndView addTopic(HttpServletRequest request,<br>HttpServletResponse response, BbsTopic topic) { BaseAdmin user &#x3D;<br>(BaseAdmin) request.getSession().getAttribute(Constant.SESSION_USER);<br>topic.setBaseAdmin(user); topic.setTopicDate(new<br>Timestamp(System.currentTimeMillis()));<br>topic.setTopicContent(StringEscapeUtils.escapeHtml(topic.getTopicContent()));<br>topic.setTopicTitle(StringEscapeUtils.escapeHtml(topic.getTopicTitle()));<br>this.bbsTopicService.save(topic); return new ModelAndView(new<br>RedirectView(“<a href="http://bbs.do/?method=topicList&bfid=">bbs.do?method&#x3D;topicList&amp;bfid&#x3D;</a>“+ topic.getBfid())); }</p>
</blockquote>
<p><strong>8.Java WEB容器默认配置漏洞。如TOMCAT后台管理漏洞，默认用户名及密码登录后可直接上传war文件获取webshell。</strong></p>
<blockquote>
<p>解决方案：最好删除，如需要使用它来管理维护，可更改其默认路径，口令及密码。</p>
</blockquote>
<p><strong>9.日志，建议增加服务器的访问日志，记录来访者的IP,传递参数，对后台操作用户建立日志，记录操作内容，完善日志记录可以帮助你发现潜在危险，找到已经发生的问题。<br>10.重放攻击<br>11.僵尸网络暴力破解<br>12.登陆表单http明文提交<br>13.千万不要乱用数据类型，使用基本数据类型，少用包装类，包装类容易被攻击，不要用string去接受所有类型数据。原则上：是什么类型就用什么类型去接收。<br>14.通过架构设计，添加一层设置处理http参数。一般都是通过aop来实现.比如：对邮件，手机验证对整数最大值验证，对字符串最大长度验证<br>15.点击劫持，大概有两种方式，一是攻击者使用一个透明的iframe，覆盖在一个网页上，然后诱使用户在该页面上进行操作，此时用户将在不值钱的情况下点击透明的iframe页面，二是攻击者使用一张图片覆盖在网页，遮挡网页原有位置的含义。</strong></p>
]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>sql注入</tag>
        <tag>上传漏洞</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>corn表达式动态配置</title>
    <url>/2023/06/04/cron%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>由于业务需求，需要提供一个能够让用户动态配置定时任务的入口，定时去同步数据</p>
</blockquote>
<p>1、简单的业务处理，直接使用@Scheduled注解就能开启定时任务，例如在方法上@Scheduled(cron &#x3D; “0 0&#x2F;1 * * * ?”)，书写cron表达式就能配置定时任务。</p>
<figure class="highlight plaintext"><figcaption><span>language-java</span></figcaption><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 每分钟触发一次</span><br><span class="line"> */</span><br><span class="line">@Scheduled(cron = &quot;0 0/1 * * * ?&quot;)</span><br><span class="line">public void execEveryDay() &#123;</span><br><span class="line">    checkPlan();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、但是随着业务复杂化，使用注解目前是满足不了动态配置定时任务的，以下代码能够实现cron表达式的动态配置。</p>
<p>第一步，在启动类新增注解@EnableScheduling</p>
<figure class="highlight plaintext"><figcaption><span>language-java</span></figcaption><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableScheduling</span><br><span class="line">public class testApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(testApplication .class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步，编写定时任务类</p>
<figure class="highlight plaintext"><figcaption><span>language-java</span></figcaption><table><tr><td class="code"><pre><span class="line">@Lazy(false)</span><br><span class="line">@Component</span><br><span class="line">@EnableScheduling</span><br><span class="line">@Slf4j</span><br><span class="line">public class OutPutTask implements SchedulingConfigurer &#123;</span><br><span class="line">	// 默认的cron表达式</span><br><span class="line">    private String cron = &quot;0 55 23 ? * *&quot;;</span><br><span class="line"></span><br><span class="line">    // 定时任务的执行顺序：由上而下按顺序执行，当服务启动时或者定时任务时间到了，先执行业务逻辑，再设置定时任务</span><br><span class="line">    @Override</span><br><span class="line">    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123;</span><br><span class="line">        taskRegistrar.addTriggerTask(() -&gt; &#123;</span><br><span class="line">            // addTriggerTask这一代码块用于当定时任务到了或者服务启动时，执行的业务逻辑</span><br><span class="line">            try &#123;</span><br><span class="line">                // 分布式锁，避免高并发同时执行方法</span><br><span class="line">                Boolean lockStatus = redisTemplate.opsForValue().setIfAbsent(RedisKeyPrefix.RECORD_OUT_PUT, new Date(), 1, TimeUnit.MINUTES);</span><br><span class="line">                if (lockStatus == null || !lockStatus) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(&quot;产能计算定时任务&#123;&#125;&quot;, new Date());</span><br><span class="line">                // 这个是自己写的自定义方法</span><br><span class="line">                recordOutput();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">            	// 释放锁</span><br><span class="line">                redisTemplate.delete(RedisKeyPrefix.RECORD_OUT_PUT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, triggerContext -&gt; &#123;</span><br><span class="line">            // 此代码块用于动态拿到cron表达式并设置定时任务，当定时任务时间到了，就会重新获取cron表达式，重新设置定时任务</span><br><span class="line">            cron = this.getCronString();</span><br><span class="line">            CronTrigger trigger;</span><br><span class="line">            try &#123;</span><br><span class="line">            	// 一旦设置，立即生效</span><br><span class="line">                trigger = new CronTrigger(cron);</span><br><span class="line">                return trigger.nextExecutionTime(triggerContext);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                // 如果格式有问题就按默认时间（时间为每天23点55分）</span><br><span class="line">                trigger = new CronTrigger(&quot;0 55 23 ? * *&quot;);</span><br><span class="line">                return trigger.nextExecutionTime(triggerContext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 拿到cron表达式</span><br><span class="line">     */</span><br><span class="line">    private String getCronString() &#123;</span><br><span class="line">        // 获取时间（当前方法返回的时间格式为yyyy-MM-dd HH:mm:ss）</span><br><span class="line">        Date beginDate = dictService.getDayOutputBeginTime(new Date());</span><br><span class="line">        // 截取分钟和小时</span><br><span class="line">        String hour = beginDate.toString().substring(11, 13);</span><br><span class="line">        String min = beginDate.toString().substring(14, 16);</span><br><span class="line">        // 替换min,hour</span><br><span class="line">        String cron = &quot;0 min hour ? * *&quot;;</span><br><span class="line">        return cron.replaceAll(&quot;min&quot;, min).replaceAll(&quot;hour&quot;, hour);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后我们只需要在页面上提供一个能够让用户配置定时任务的入口或者在数据库里配置cron表达式，就能实现动态配置。<br>如果面向的用户懂得cron表达式，也可以直接让用户配置cron表达式也是可以的，省的程序员进行额外的数据处理，只要配置正确，任何处理方式都行，例如：  </p>
<p>点击确定后，会更新数据库，<strong>当定时任务时间到了，就会触发定时任务机制，重新设置定时任务</strong>。</p>
]]></content>
      <categories>
        <category>corn</category>
      </categories>
      <tags>
        <tag>动态配置</tag>
      </tags>
  </entry>
  <entry>
    <title>idea常用插件</title>
    <url>/2023/06/04/idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<hr>
<br />

<p>大家好，我是shine🌟，本篇将详细介绍IDEA快捷键及插件，让你学习和开发事半功倍。IDEA的牛逼，众所皆知，不论是用来学习还是开发都是首选的IDE，拉爆其他开发工具，让你爱上代码。很多隐藏的功能等待着你去发现🔍。</p>
<p><img src="https://img-blog.csdnimg.cn/e2280ec0e5904537909571e9c022c863.png?x-oss-,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ICAIOaYnw==,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>🌾快捷键（提高码字速度） </p>
]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>java生成二维码</title>
    <url>/2023/06/04/java%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/</url>
    <content><![CDATA[<p>一、介绍：生成二维码有很多种方法，比如微信公众号的生成二维码，但是这个二维码只能用微信扫描且会（可以带参数）自动跳转到微信的公众号页面，不支持跳转到其他网页。这里说的二维码是扫描（微信、QQ、浏览器等扫描）可以跳转到指定网址的二维码。二维码最早是由日本一家公司开发的，并且该二维码主要有两种方式：一种是QRCode 插件产生于日本 ；另一种是ZXing 插件由谷歌开发的。</p>
<p>二、ZXing插件开发：</p>
<p>1、引入依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- 生成二维码，spring boot 的maven项目 导入响应jar包 --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javase&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、生成的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.zxing.BarcodeFormat;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.EncodeHintType;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.MultiFormatWriter;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.WriterException;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.common.BitMatrix;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需求说明：卖家在一个实体产品上贴一个二维码，买家收货后，微信扫码获取产品的详细信息</span></span><br><span class="line"><span class="comment"> * 实现说明：卖家在出货前，把服务器上的产品详情页的链接地址（含有ID）生成二维码，买家收货后微信扫码，跳转到产品信息页即可查看</span></span><br><span class="line"><span class="comment"> * 需要jar:zxing-code-2.3.jar,下载地址http://download.csdn.net/download/sanfye/8704583</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 加内特</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BLACK</span> <span class="operator">=</span> <span class="number">0xFF000000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WHITE</span> <span class="operator">=</span> <span class="number">0xFFFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> generateCode(<span class="string">&quot;518&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;成功生成二维码&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (WriterException | IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;生成二维码失败&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">generateCode</span><span class="params">(String productId)</span> <span class="keyword">throws</span> WriterException, IOException &#123;</span><br><span class="line">        <span class="comment">// 这里是URL，扫描之后就跳转到这个界面</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;https://www.baidu.com/?uudi=&quot;</span> + productId;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;E:/&quot;</span>; <span class="comment">// 图片生成的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">400</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">400</span>;</span><br><span class="line">        <span class="comment">// 二维码图片格式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> <span class="string">&quot;jpg&quot;</span>;</span><br><span class="line">        <span class="comment">// 设置编码，防止中文乱码</span></span><br><span class="line">        Hashtable&lt;EncodeHintType, Object&gt; ht = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;EncodeHintType, Object&gt;();</span><br><span class="line">        ht.put(EncodeHintType.CHARACTER_SET, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置二维码参数(编码内容，编码类型，图片宽度，图片高度,格式)</span></span><br><span class="line">        <span class="type">BitMatrix</span> <span class="variable">bitMatrix</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultiFormatWriter</span>().encode(text, BarcodeFormat.QR_CODE, width, height, ht);</span><br><span class="line">        <span class="comment">// 生成二维码(定义二维码输出服务器路径)</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">outputFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">        <span class="keyword">if</span> (!outputFile.exists()) &#123;</span><br><span class="line">            <span class="comment">// 创建文件夹</span></span><br><span class="line">            outputFile.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">b_width</span> <span class="operator">=</span> bitMatrix.getWidth();</span><br><span class="line">        <span class="type">int</span> <span class="variable">b_height</span> <span class="operator">=</span> bitMatrix.getHeight();</span><br><span class="line">        <span class="comment">// 建立图像缓冲器</span></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedImage</span>(b_width, b_height, BufferedImage.TYPE_3BYTE_BGR);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; b_width; x++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; b_height; y++) &#123;</span><br><span class="line">                image.setRGB(x, y, bitMatrix.get(x, y) ? BLACK : WHITE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成二维码</span></span><br><span class="line">        ImageIO.write(image, format, <span class="keyword">new</span> <span class="title class_">File</span>(path + <span class="string">&quot;/code.&quot;</span> + format));</span><br><span class="line">        <span class="comment">// 二维码的名称</span></span><br><span class="line">        <span class="comment">// code.jpg</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、生成的二维码图片：</p>
<p><img src="https://img-blog.csdnimg.cn/20210304164500997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dfdF95X3k=,size_16,color_FFFFFF,t_70"></p>
]]></content>
      <categories>
        <category>二维码</category>
      </categories>
      <tags>
        <tag>二维码</tag>
        <tag>QRcode</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-plus连表查询</title>
    <url>/2023/06/04/mybatis-plus%E8%BF%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>开发小笔记(持续更新)</title>
    <url>/2023/06/05/%E5%BC%80%E5%8F%91%E5%B0%8F%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<br>

<p>持续更新中……</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>服务占用cpu过高排查</title>
    <url>/2023/06/04/%E6%9C%8D%E5%8A%A1%E5%8D%A0%E7%94%A8cpu%E8%BF%87%E9%AB%98%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<blockquote>
<p><strong>先用top命令找出CPU占比最高的</strong></p>
</blockquote>
<figure class="highlight plaintext"><figcaption><span>language-powershell</span></figcaption><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20201230214810341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODM0MzU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>CPU占用最高的是java进程，它的 <code>进程ID：3362</code></p>
<blockquote>
<p><strong>ps -ef 或者 jps 进一步定位，得知是怎样的程序</strong></p>
</blockquote>
<figure class="highlight plaintext"><figcaption><span>language-powershell</span></figcaption><table><tr><td class="code"><pre><span class="line">[root@192 ~] ps -ef | grep 3362 | grep -v grep</span><br><span class="line">root       3362   2340 42 21:47 pts/0    00:02:30 java HelloWorldApp</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>定位到具体的线程或者代码</strong></p>
</blockquote>
<figure class="highlight plaintext"><figcaption><span>language-powershell</span></figcaption><table><tr><td class="code"><pre><span class="line">ps -mp 3362 -o THREAD,tid,time</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20201230220404953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODM0MzU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>如图所示，引起CPU过高的 <code>线程ID：3363</code></p>
<blockquote>
<p><strong>将线程ID转换为16进制格式（英文小写）</strong></p>
</blockquote>
<p>3365 转换为16进制结果：d23<br><img src="https://img-blog.csdnimg.cn/20201230220804137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODM0MzU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>jstack</p>
</blockquote>
<p>格式：jstack 进程ID | grep tid（16进制小写） -A60</p>
<figure class="highlight plaintext"><figcaption><span>language-powershell</span></figcaption><table><tr><td class="code"><pre><span class="line">jstack 3362 | grep d23 -A60</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20201230221316830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODM0MzU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这样，就能找出具体的异常代码位置</p>
]]></content>
      <categories>
        <category>性能提升</category>
      </categories>
      <tags>
        <tag>cpu飙高</tag>
      </tags>
  </entry>
  <entry>
    <title>获取客户端真实ip</title>
    <url>/2023/06/04/%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9C%9F%E5%AE%9Eip/</url>
    <content><![CDATA[<p>现在都流行显示 ip 归属地，那么我先来获取客户端的真实 ip 地址以及 mac 地址，上代码</p>
<figure class="highlight plaintext"><figcaption><span>language-java</span></figcaption><table><tr><td class="code"><pre><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.NetworkInterface;</span><br><span class="line">import java.net.UnknownHostException;</span><br><span class="line">/**</span><br><span class="line"> * 常用获取客户端信息的工具</span><br><span class="line"> */</span><br><span class="line">public class NetworkUtil &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取ip地址</span><br><span class="line">     */</span><br><span class="line">    public static String getIpAddress(HttpServletRequest request) &#123;</span><br><span class="line">        String ip = request.getHeader(&quot;x-forwarded-for&quot;);</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;HTTP_CLIENT_IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;HTTP_X_FORWARDED_FOR&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getRemoteAddr();</span><br><span class="line">        &#125;</span><br><span class="line">        // 本机访问</span><br><span class="line">        if (&quot;localhost&quot;.equalsIgnoreCase(ip) || &quot;127.0.0.1&quot;.equalsIgnoreCase(ip) || &quot;0:0:0:0:0:0:0:1&quot;.equalsIgnoreCase(ip))&#123;</span><br><span class="line">            // 根据网卡取本机配置的IP</span><br><span class="line">            InetAddress inet;</span><br><span class="line">            try &#123;</span><br><span class="line">                inet = InetAddress.getLocalHost();</span><br><span class="line">                ip = inet.getHostAddress();</span><br><span class="line">            &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 对于通过多个代理的情况，第一个IP为客户端真实IP,多个IP按照&#x27;,&#x27;分割</span><br><span class="line">        if (null != ip &amp;&amp; ip.length() &gt; 15) &#123;</span><br><span class="line">            if (ip.indexOf(&quot;,&quot;) &gt; 15) &#123;</span><br><span class="line">                ip = ip.substring(0, ip.indexOf(&quot;,&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取mac地址</span><br><span class="line">     */</span><br><span class="line">    public static String getMacAddress() throws Exception &#123;</span><br><span class="line">        // 取mac地址</span><br><span class="line">        byte[] macAddressBytes = NetworkInterface.getByInetAddress(InetAddress.getLocalHost()).getHardwareAddress();</span><br><span class="line">        // 下面代码是把mac地址拼装成String</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (int i = 0; i &lt; macAddressBytes.length; i++) &#123;</span><br><span class="line">            if (i != 0) &#123;</span><br><span class="line">                sb.append(&quot;-&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // mac[i] &amp; 0xFF 是为了把byte转化为正整数</span><br><span class="line">            String s = Integer.toHexString(macAddressBytes[i] &amp; 0xFF);</span><br><span class="line">            sb.append(s.length() == 1 ? 0 + s : s);</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString().trim().toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，ip 获取到了至于查询 ip 归属地嘛<br><a href="https://github.com/lionsoul2014/ip2region">Ip2region</a></p>
]]></content>
      <categories>
        <category>IP地址</category>
      </categories>
      <tags>
        <tag>ip地址</tag>
        <tag>mac地址</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown常用语法</title>
    <url>/2023/06/04/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>目录</p>
<br />

<ul>
<li><ul>
<li><a href="#1-%E5%BF%AB%E6%8D%B7%E9%94%AE">1. 快捷键</a></li>
<li><a href="#2-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">2. 基本语法</a><ul>
<li><a href="#21-%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE%E6%96%9C%E4%BD%93%E7%B2%97%E4%BD%93%E5%88%A0%E9%99%A4%E7%BA%BF">2.1 字体设置斜体、粗体、删除线</a></li>
<li><a href="#22-%E5%88%86%E7%BA%A7%E6%A0%87%E9%A2%98">2.2 分级标题</a></li>
<li><a href="#23-%E9%93%BE%E6%8E%A5">2.3 链接</a></li>
<li><a href="#24-%E5%88%86%E5%89%B2%E7%BA%BF">2.4 分割线</a></li>
<li><a href="#25-%E4%BB%A3%E7%A0%81%E5%9D%97">2.5 代码块</a></li>
<li><a href="#26-%E5%BC%95%E7%94%A8">2.6 引用</a></li>
<li><a href="#27-%E5%88%97%E8%A1%A8">2.7 列表</a></li>
<li><a href="#28-%E8%A1%A8%E6%A0%BC">2.8 表格</a></li>
</ul>
</li>
<li><a href="#3-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7">3. 常用技巧</a><ul>
<li><a href="#31-%E6%8D%A2%E8%A1%8C">3.1 换行</a></li>
<li><a href="#32-%E7%BC%A9%E8%BF%9B%E5%AD%97%E7%AC%A6">3.2 缩进字符</a></li>
<li><a href="#33-%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7">3.3 特殊符号</a></li>
<li><a href="#34-%E5%AD%97%E4%BD%93%E5%AD%97%E5%8F%B7%E4%B8%8E%E9%A2%9C%E8%89%B2">3.4 字体、字号与颜色</a></li>
<li><a href="#35-%E9%93%BE%E6%8E%A5%E7%9A%84%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C">3.5 链接的高级操作</a><ul>
<li><a href="#1%E8%A1%8C%E5%86%85%E5%BC%8F">1.行内式</a></li>
<li><a href="#2%E5%8F%82%E8%80%83%E5%BC%8F%E9%93%BE%E6%8E%A5">2.参考式链接</a></li>
<li><a href="#3%E5%86%85%E5%AE%B9%E7%9B%AE%E5%BD%95">3.内容目录</a></li>
<li><a href="#4%E9%94%9A%E7%82%B9">4.锚点</a></li>
<li><a href="#5%E6%B3%A8%E8%84%9A">5.注脚</a></li>
</ul>
</li>
<li><a href="#36-%E8%83%8C%E6%99%AF%E8%89%B2">3.6 背景色</a></li>
<li><a href="#37-emoji%E8%A1%A8%E6%83%85%E7%AC%A6%E5%8F%B7">3.7 emoji表情符号</a></li>
</ul>
</li>
<li><a href="#4-%E9%AB%98%E7%AB%AF%E7%94%A8%E6%B3%95">4. 高端用法</a><ul>
<li><a href="#41-latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">4.1 Latex数学公式</a></li>
<li><a href="#42-%E6%B5%81%E7%A8%8B%E5%9B%BE">4.2 流程图</a></li>
<li><a href="#43-%E5%88%B6%E4%BD%9C%E4%B8%80%E4%BB%BD%E5%BE%85%E5%8A%9E%E4%BA%8B%E5%AE%9C-todo-%E5%88%97%E8%A1%A8">4.3 制作一份待办事宜—-Todo 列表</a></li>
<li><a href="#44-%E7%BB%98%E5%88%B6-%E5%BA%8F%E5%88%97%E5%9B%BE">4.4 绘制 序列图</a></li>
<li><a href="#45-%E7%BB%98%E5%88%B6-%E7%94%98%E7%89%B9%E5%9B%BE">4.5 绘制 甘特图</a></li>
</ul>
</li>
<li><a href="#5-markdown%E5%B7%A5%E5%85%B7">5. Markdown工具</a></li>
</ul>
</li>
</ul>
<br />

<p><strong>前言</strong><br>写过博客或者github上面的文档的，应该知道Markdown语法的重要性，不知道的朋友们也别着急，一篇博客轻松搞定Markdown语法。话说这个语法超级简单，一看就会，不信你点进来看看。</p>
<ol>
<li>快捷键</li>
</ol>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>docker十五问</title>
    <url>/2023/06/04/docker%E5%8D%81%E4%BA%94%E9%97%AE/</url>
    <content><![CDATA[<br />

]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中代码优化的30个小技巧</title>
    <url>/2023/05/28/java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<br />

<h2 id="1-用String-format拼接字符串"><a href="#1-用String-format拼接字符串" class="headerlink" title="1.用String.format拼接字符串 "></a>1.用String.format拼接字符串 </h2><p><em><strong>String.format</strong></em>方法拼接url请求参数，日志打印等字符串。</p>
<p>但不建议在for循环中用它拼接字符串，因为它的执行效率，比使用+号拼接字符串，或者使用StringBuilder拼接字符串都要慢一些。</p>
<h2 id="2-创建可缓冲的IO流"><a href="#2-创建可缓冲的IO流" class="headerlink" title="2.创建可缓冲的IO流"></a>2.创建可缓冲的IO流</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尽量使用try-with-resources语句，可以在程序结束时自动关闭资源</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ServletOutputStream</span> <span class="variable">outStr</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">     <span class="type">BufferedOutputStream</span> <span class="variable">buff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(outStr))&#123;</span><br><span class="line">    buff.write(text.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    buff.flush();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;导出文件文件出错:&#123;&#125;&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用缓冲流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/Documents/test1/1.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/Documents/test1/2.txt&quot;</span>);</span><br><span class="line"><span class="keyword">try</span>(<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos)) &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    bos.flush();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="3-减少循环次数"><a href="#3-减少循环次数" class="headerlink" title="3.减少循环次数"></a>3.减少循环次数</h2><p>如果循环层级比较深，循环中套循环，可能会影响代码的执行效率。</p>
<p>如果有两层循环，如果userList和roleList数据比较多的话，需要循环遍历很多次，才能获取我们所需要的数据，非常消耗cpu资源。</p>
<p>如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正常逻辑2层for循环处理</span></span><br><span class="line"><span class="keyword">for</span>(User user: userList) &#123;</span><br><span class="line">   <span class="keyword">for</span>(Role role: roleList) &#123;</span><br><span class="line">      <span class="keyword">if</span>(user.getRoleId().equals(role.getId())) &#123;</span><br><span class="line">         user.setRoleName(role.getName());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Long, List&lt;Role&gt;&gt; roleMap = roleList.stream().collect(Collectors.groupingBy(Role::getId));</span><br><span class="line"><span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">    List&lt;Role&gt; roles = roleMap.get(user.getRoleId());</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtils.isNotEmpty(roles)) &#123;</span><br><span class="line">        user.setRoleName(roles.get(<span class="number">0</span>).getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化思想就是减少循环次数，最简单的办法是，把第二层循环的集合变成<em><strong>map</strong></em>，这样可以直接通过<em><strong>key</strong></em>，获取想要的<em><strong>value</strong></em>数据。</p>
<p>虽说map的key存在<em><strong>hash冲突</strong></em>的情况，但遍历存放数据的<em><strong>链表</strong></em>或者<em><strong>红黑树</strong></em>的<em><strong>时间复杂度</strong></em>，比遍历整个list集合要小很多。</p>
<h2 id="4-用完资源记得及时关闭"><a href="#4-用完资源记得及时关闭" class="headerlink" title="4.用完资源记得及时关闭"></a>4.用完资源记得及时关闭</h2><p>参考第二点尽量使用try-with-resources语句或者手动关闭资源</p>
<h2 id="5-使用池技术"><a href="#5-使用池技术" class="headerlink" title="5.使用池技术"></a>5.使用池技术</h2><p>数据库连接池、线程池</p>
<h2 id="6-消除if…else的锦囊妙计，反射时添加缓存"><a href="#6-消除if…else的锦囊妙计，反射时添加缓存" class="headerlink" title="6.消除if…else的锦囊妙计，反射时添加缓存"></a>6.消除if…else的锦囊妙计，反射时添加缓存</h2><p>我们都知道通过<em><strong>反射</strong></em>创建对象实例，比使用<em><strong>new</strong></em>关键字要慢很多。</p>
<p>由此，不太建议在用户请求过来时，每次都通过反射<em><strong>实时</strong></em>创建实例。</p>
<p>有时候，为了代码的灵活性，又不得不用反射创建实例，这时该怎么办呢？</p>
<p>答：加<em><strong>缓存</strong></em>。</p>
<p>先看以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">publicinterface IPay &#123;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">publicclass AliaPay <span class="keyword">implements</span> <span class="title class_">IPay</span> &#123;  </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;===发起支付宝支付===&quot;</span>);  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">publicclass WeixinPay <span class="keyword">implements</span> <span class="title class_">IPay</span> &#123;  </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;  </span><br><span class="line">         System.out.println(<span class="string">&quot;===发起微信支付===&quot;</span>);  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">publicclass JingDongPay <span class="keyword">implements</span> <span class="title class_">IPay</span> &#123;  </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;===发起京东支付===&quot;</span>);  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">publicclass PayService &#123;  </span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     <span class="keyword">private</span> AliaPay aliaPay;  </span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     <span class="keyword">private</span> WeixinPay weixinPay;  </span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     <span class="keyword">private</span> JingDongPay jingDongPay;  </span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toPay</span><span class="params">(String code)</span> &#123;  </span><br><span class="line">         <span class="keyword">if</span> (<span class="string">&quot;alia&quot;</span>.equals(code)) &#123;  </span><br><span class="line">             aliaPay.pay();  </span><br><span class="line">         &#125; elseif (<span class="string">&quot;weixin&quot;</span>.equals(code)) &#123;  </span><br><span class="line">              weixinPay.pay();  </span><br><span class="line">         &#125; elseif (<span class="string">&quot;jingdong&quot;</span>.equals(code)) &#123;  </span><br><span class="line">              jingDongPay.pay();  </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">              System.out.println(<span class="string">&quot;找不到支付方式&quot;</span>);  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里违法了设计模式六大原则的：<em><strong>开闭原则</strong></em> 和 <em><strong>单一职责原则</strong></em>。</p>
<p>开闭原则：对扩展开放，对修改关闭。就是说增加新功能要尽量少改动已有代码。</p>
<p>单一职责原则：顾名思义，要求逻辑尽量单一，不要太复杂，便于复用。</p>
<ol>
<li>先创建一个注解</li>
<li>在所有的支付类上都加上该注解</li>
<li>增加最关键的类PayService2</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Ywh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/7/25 14:50</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PayCode &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@PayCode(value = &quot;alia&quot;, name = &quot;支付宝支付&quot;)</span></span><br><span class="line"><span class="meta">@Component(&quot;alia&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliaPay</span> <span class="keyword">implements</span> <span class="title class_">IPay</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===发起支付宝支付===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PayCode(value = &quot;jingdong&quot;, name = &quot;京东支付&quot;)</span></span><br><span class="line"><span class="meta">@Component(&quot;jingdong&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JingDongPay</span> <span class="keyword">implements</span> <span class="title class_">IPay</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===发起京东支付===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PayCode(value = &quot;weixin&quot;, name = &quot;微信支付&quot;)</span></span><br><span class="line"><span class="meta">@Component(&quot;weixin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeixinPay</span> <span class="keyword">implements</span> <span class="title class_">IPay</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===发起微信支付===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayService2</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, IPay&gt; payMap = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextRefreshedEvent contextRefreshedEvent)</span> &#123;</span><br><span class="line">        <span class="comment">//在初始化或刷新ApplicationContext时发布</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> contextRefreshedEvent.getApplicationContext();</span><br><span class="line">        <span class="comment">//获取所有拥有特定payCode注解的Bean（AliPay、WeiXinPay、JindDongPay）</span></span><br><span class="line">        Map&lt;String, Object&gt; beansWithAnnotation = applicationContext.getBeansWithAnnotation(PayCode.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (beansWithAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">            payMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            beansWithAnnotation.forEach((key, value) -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">bizType</span> <span class="operator">=</span> value.getClass().getAnnotation(PayCode.class).value();</span><br><span class="line">                payMap.put(bizType, (IPay) value);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(String code)</span> &#123;</span><br><span class="line">        payMap.get(code).pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/pay&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;测试支付&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(String code)</span>&#123;</span><br><span class="line">        payService2.pay(code);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>PayService2类实现了<em><strong>ApplicationListener</strong></em>接口，这样在<em><strong>onApplicationEvent</strong></em>方法中，就可以拿到<em><strong>ApplicationContext</strong></em>的实例。这一步，其实是在spring容器启动的时候，spring通过反射我们处理好了。</p>
<p>我们再获取打了PayCode注解的类，放到一个<em><strong>map</strong></em>中，map中的<em><strong>key</strong></em>就是PayCode注解中定义的value，跟code参数一致，<em><strong>value</strong></em>是支付类的实例。</p>
<p>这样，每次就可以每次直接通过code获取支付类实例，而不用if…else判断了。如果要加新的支付方法，只需在支付类上面打上PayCode注解定义一个新的code即可。</p>
<p>注意：这种方式的code可以没有业务含义，可以是纯数字，只要不重复就行。</p>
<h2 id="7-多线程处理"><a href="#7-多线程处理" class="headerlink" title="7.多线程处理"></a>7.多线程处理</h2><p>一句话把串行执行的接口变成并行执行；</p>
<p><img src="https://img-blog.csdnimg.cn/0f115e004f5b4a21b78f201d0792216c.png"></p>
<p>并行执行</p>
<p><img src="https://img-blog.csdnimg.cn/51849d4f6a7446f6bde89286dbfe347e.png"></p>
<p>在java8之前可以通过实现<em><strong>Callable</strong></em>接口，获取线程返回结果。</p>
<p>java8以后通过<em><strong>CompleteFuture</strong></em>类实现该功能。我们这里以CompleteFuture为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> UserInfo <span class="title function_">getUserInfo</span><span class="params">(Long id)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserInfo</span>();</span><br><span class="line">    <span class="type">CompletableFuture</span> <span class="variable">userFuture</span> <span class="operator">=</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        getRemoteUserAndFill(id, userInfo);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;, executor);</span><br><span class="line"></span><br><span class="line">    <span class="type">CompletableFuture</span> <span class="variable">bonusFuture</span> <span class="operator">=</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        getRemoteBonusAndFill(id, userInfo);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;, executor);</span><br><span class="line"></span><br><span class="line">    <span class="type">CompletableFuture</span> <span class="variable">growthFuture</span> <span class="operator">=</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        getRemoteGrowthAndFill(id, userInfo);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;, executor);</span><br><span class="line">    CompletableFuture.allOf(userFuture, bonusFuture, growthFuture).join();</span><br><span class="line"></span><br><span class="line">    userFuture.get();</span><br><span class="line">    bonusFuture.get();</span><br><span class="line">    growthFuture.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-懒加载"><a href="#8-懒加载" class="headerlink" title="8.懒加载"></a>8.懒加载</h2><p>有时候，创建对象是一个非常耗时的操作，特别是在该对象的创建过程中，还需要创建很多其他的对象时。</p>
<p>我们以单例模式为例。</p>
<p>在介绍单例模式的时候，必须要先介绍它的两种非常著名的实现方式：<em><strong>饿汉模式</strong></em> 和 <em><strong>懒汉模式</strong></em>。</p>
<h3 id="8-1-饿汉模式"><a href="#8-1-饿汉模式" class="headerlink" title="8.1 饿汉模式"></a>8.1 <em><strong>饿汉模式</strong></em></h3><p>实例在初始化的时候就已经建好了，不管你有没有用到，先建好了再说。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleSingleton</span> &#123;</span><br><span class="line">    <span class="comment">//持有自己类的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleSingleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleSingleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SimpleSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对外提供获取实例的静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SimpleSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用饿汉模式的好处是：<em><strong>没有线程安全的问题</strong></em>，但带来的坏处也很明显。</p>
<h3 id="8-2-懒汉模式"><a href="#8-2-懒汉模式" class="headerlink" title="8.2 懒汉模式"></a>8.2 <em><strong>懒汉模式</strong></em></h3><p>顾名思义就是实例在用到的时候才去创建，”比较懒”，用的时候才去检查有没有实例，如果有则返回，没有则新建。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleSingleton2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleSingleton2 INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SimpleSingleton2</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SimpleSingleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">SimpleSingleton2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例中的INSTANCE对象一开始是空的，在调用getInstance方法才会真正实例化。</p>
<p>懒汉模式相对于饿汉模式，没有提前实例化对象，在真正使用的时候再实例化，在实例化对象的阶段效率更高一些。</p>
<p><strong>除了单例模式之外，懒加载的思想，使用比较多的可能是：</strong></p>
<ol>
<li><p>spring的@Lazy注解。在spring容器启动的时候，不会调用其getBean方法初始化实例。</p>
</li>
<li><p>mybatis的懒加载。在mybatis做级联查询的时候，比如查用户的同时需要查角色信息。如果用了懒加载，先只查用户信息，真正使用到角色了，才取查角色信息。</p>
</li>
</ol>
<h2 id="9-初始化集合时指定大小"><a href="#9-初始化集合时指定大小" class="headerlink" title="9.初始化集合时指定大小"></a>9.初始化集合时指定大小</h2><p>在创建集合时指定了大小，比没有指定大小，添加10万个元素的效率提升了一倍。</p>
<p>如果你看过<em><strong>ArrayList</strong></em>源码，你就会发现它的默认大小是<em><strong>10</strong></em>，如果添加元素超过了一定的阀值，会按<em><strong>1.5</strong></em>倍的大小扩容。</p>
<p>你想想，如果装10万条数据，需要扩容多少次呀？而每次扩容都需要不停的复制元素，从老集合复制到新集合中，需要浪费多少时间呀。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//正例 </span></span><br><span class="line">List&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">100000</span>);</span><br></pre></td></tr></table></figure>

<h2 id="10-不要满屏try…catch异常"><a href="#10-不要满屏try…catch异常" class="headerlink" title="10.不要满屏try…catch异常"></a>10.不要满屏try…catch异常</h2><p>可以使用全局异常处理：<em><strong>RestControllerAdvice</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ArithmeticException) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;数据异常&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;服务器内部异常&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        retur nnull;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-位运算效率更高"><a href="#11-位运算效率更高" class="headerlink" title="11.位运算效率更高"></a>11.位运算效率更高</h2><h2 id="12-巧用第三方工具类"><a href="#12-巧用第三方工具类" class="headerlink" title="12.巧用第三方工具类"></a>12.巧用第三方工具类</h2><p>如果你引入<em><strong>com.google.guava</strong></em>的pom文件，会获得很多好用的小工具。这里推荐一款<em><strong>com.google.common.collect</strong></em>包下的集合工具：<em><strong>Lists</strong></em>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//guava提供的字符串工具类</span></span><br><span class="line">Strings.isNullOrEmpty(<span class="string">&quot;&quot;</span>);<span class="comment">//返回true</span></span><br><span class="line">Strings.nullToEmpty(<span class="literal">null</span>);<span class="comment">//&quot;&quot;</span></span><br><span class="line">Strings.nullToEmpty(<span class="string">&quot;chen&quot;</span>);<span class="comment">//返回&quot;chen&quot;</span></span><br><span class="line">Strings.emptyToNull(<span class="string">&quot;&quot;</span>);<span class="comment">//返回null</span></span><br><span class="line">Strings.emptyToNull(<span class="string">&quot;chen&quot;</span>);<span class="comment">//返回&quot;chen&quot;  </span></span><br><span class="line"> </span><br><span class="line">Strings.commonPrefix(<span class="string">&quot;aaab&quot;</span>, <span class="string">&quot;aac&quot;</span>);<span class="comment">//&quot;aa&quot;否则返回&quot;&quot;</span></span><br><span class="line">Strings.commonSuffix(<span class="string">&quot;aaac&quot;</span>, <span class="string">&quot;aac&quot;</span>);<span class="comment">//&quot;aac&quot;否则返回&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="13-用同步代码块代替同步方法"><a href="#13-用同步代码块代替同步方法" class="headerlink" title="13.用同步代码块代替同步方法"></a>13.用同步代码块代替同步方法</h2><p>在某些业务场景中，为了防止多个线程并发修改某个共享数据，造成数据异常。</p>
<p>为了解决并发场景下，多个线程同时修改数据，造成数据不一致的情况。通常情况下，我们会：<em><strong>加锁</strong></em>。</p>
<p>但如果锁加得不好，导致<em><strong>锁的粒度太粗</strong></em>，也会非常影响接口性能。</p>
<p>在java中提供了<em><strong>synchronized</strong></em>关键字给我们的代码加锁。</p>
<p>通常有两种写法：<em><strong>在方法上加锁</strong></em> 和 <em><strong>在代码块上加锁</strong></em>。</p>
<p>先看看如何在方法上加锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="title function_">doSave</span><span class="params">(String fileUrl)</span> &#123;</span><br><span class="line">    mkdir();</span><br><span class="line">    uploadFile(fileUrl);</span><br><span class="line">    sendMessage(fileUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里加锁的目的是为了防止并发的情况下，创建了相同的目录，第二次会创建失败，影响业务功能。</p>
<p>但这种直接在方法上加锁，锁的粒度有点粗。因为doSave方法中的上传文件和发消息方法，是不需要加锁的。只有创建目录方法，才需要加锁。</p>
<p>我们都知道文件上传操作是非常耗时的，如果将整个方法加锁，那么需要等到整个方法执行完之后才能释放锁。显然，这会导致该方法的性能很差，变得得不偿失。</p>
<p>这时，我们可以改成在代码块上加锁了，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSave</span><span class="params">(String path,String fileUrl)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!exists(path)) &#123;</span><br><span class="line">          mkdir(path);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    uploadFile(fileUrl);</span><br><span class="line">    sendMessage(fileUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样改造之后，锁的粒度一下子变小了，只有并发创建目录功能才加了锁。而创建目录是一个非常快的操作，即使加锁对接口的性能影响也不大。</p>
<p>最重要的是，其他的上传文件和发送消息功能，任然可以并发执行。</p>
<h2 id="14-不用的数据及时清理"><a href="#14-不用的数据及时清理" class="headerlink" title="14.不用的数据及时清理"></a>14.不用的数据及时清理</h2><p>在Java中保证线程安全的技术有很多，可以使用<em><strong>synchroized</strong></em>、<em><strong>Lock</strong></em>等关键字给代码块<code>加锁</code>。</p>
<p>但是它们有个共同的特点，就是加锁会对代码的性能有一定的损耗。</p>
<p>其实，在jdk中还提供了另外一种思想即：<code>用空间换时间</code>。</p>
<p>没错，使用<em><strong>ThreadLocal</strong></em>类就是对这种思想的一种具体体现。</p>
<p>ThreadLocal为每个使用变量的线程提供了一个独立的变量副本，这样每一个线程都能独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<p>ThreadLocal的用法大致是这样的：</p>
<ol>
<li><p>先创建一个CurrentUser类，其中包含了ThreadLocal的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CurrentUser</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserInfo&gt; THREA_LOCAL = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(UserInfo userInfo)</span> &#123;</span><br><span class="line">        THREA_LOCAL.set(userInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserInfo <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">       THREA_LOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">       THREA_LOCAL.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在业务代码中调用CurrentUser类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSamething</span><span class="params">(UserDto userDto)</span> &#123;</span><br><span class="line">   <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> convert(userDto);</span><br><span class="line">   CurrentUser.set(userInfo);</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   <span class="comment">//业务代码</span></span><br><span class="line">   <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> CurrentUser.get();</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在业务代码的第一行，将userInfo对象设置到CurrentUser，这样在业务代码中，就能通过CurrentUser.get()获取到刚刚设置的userInfo对象。特别是对业务代码调用层级比较深的情况，这种用法非常有用，可以减少很多不必要传参。</p>
<p>但在高并发的场景下，这段代码有问题，只往ThreadLocal存数据，数据用完之后并没有及时清理。</p>
<p>ThreadLocal即使使用了<em><strong>WeakReference</strong></em>（弱引用）也可能会存在<code>内存泄露</code>问题，因为 entry对象中只把key(即threadLocal对象)设置成了弱引用，但是value值没有。</p>
<p>那么，如何解决这个问题呢？</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSamething</span><span class="params">(UserDto userDto)</span> &#123;</span><br><span class="line">   <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> convert(userDto);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">     CurrentUser.set(userInfo);</span><br><span class="line">     ...</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//业务代码</span></span><br><span class="line">     <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> CurrentUser.get();</span><br><span class="line">     ...</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      CurrentUser.remove();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要在<em><strong>finally</strong></em>代码块中，调用<em><strong>remove</strong></em>方法清理没用的数据。</p>
<h2 id="15-用equals方法比较是否相等"><a href="#15-用equals方法比较是否相等" class="headerlink" title="15.用equals方法比较是否相等"></a>15.用equals方法比较是否相等</h2><h2 id="16-避免创建大集合"><a href="#16-避免创建大集合" class="headerlink" title="16.避免创建大集合"></a>16.避免创建大集合</h2><p>尽量分页处理</p>
<h2 id="17-状态用枚举"><a href="#17-状态用枚举" class="headerlink" title="17.状态用枚举"></a>17.状态用枚举</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OrderStatusEnum</span> &#123;  </span><br><span class="line">     CREATE(<span class="number">1</span>, <span class="string">&quot;下单&quot;</span>),  </span><br><span class="line">     PAY(<span class="number">2</span>, <span class="string">&quot;支付&quot;</span>),  </span><br><span class="line">     DONE(<span class="number">3</span>, <span class="string">&quot;完成&quot;</span>),  </span><br><span class="line">     CANCEL(<span class="number">4</span>, <span class="string">&quot;撤销&quot;</span>);  </span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> code;  </span><br><span class="line">     <span class="keyword">private</span> String message;  </span><br><span class="line"></span><br><span class="line">     OrderStatusEnum(<span class="type">int</span> code, String message) &#123;  </span><br><span class="line">         <span class="built_in">this</span>.code = code;  </span><br><span class="line">         <span class="built_in">this</span>.message = message;  </span><br><span class="line">     &#125;  </span><br><span class="line">   </span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.code;  </span><br><span class="line">     &#125;  </span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.message;  </span><br><span class="line">     &#125;  </span><br><span class="line">  </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> OrderStatusEnum <span class="title function_">getOrderStatusEnum</span><span class="params">(<span class="type">int</span> code)</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(OrderStatusEnum.values()).filter(x -&gt; x.code == code).findFirst().orElse(<span class="literal">null</span>);  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而且使用枚举的好处是：</p>
<ol>
<li><p>代码的可读性变强了，不同的状态，有不同的枚举进行统一管理和维护。</p>
</li>
<li><p>枚举是天然单例的，可以直接使用&#x3D;&#x3D;号进行比较。</p>
</li>
<li><p>code和message可以成对出现，比较容易相关转换。</p>
</li>
<li><p>枚举可以消除if…else过多问题。</p>
</li>
</ol>
<h2 id="18-把固定值定义成静态常量"><a href="#18-把固定值定义成静态常量" class="headerlink" title="18.把固定值定义成静态常量"></a>18.把固定值定义成静态常量</h2><p>使用<em><strong>static final</strong></em>关键字修饰静态常量，<em><strong>static</strong></em>表示<code>静态</code>的意思，即类变量，而<em><strong>final</strong></em>表示<em><strong>不允许修改</strong></em>。</p>
<p>两个关键字加在一起，告诉Java虚拟机这种变量，在内存中只有一份，在全局上是唯一的，不能修改，也就是<em><strong>静态常量</strong></em>。</p>
<h2 id="19-避免大事务"><a href="#19-避免大事务" class="headerlink" title="19.避免大事务"></a>19.避免大事务</h2><p>很多小伙伴在使用spring框架开发项目时，为了方便，喜欢使用***@Transactional***注解提供事务功能。</p>
<p>没错，使用@Transactional注解这种声明式事务的方式提供事务功能，确实能少写很多代码，提升开发效率。</p>
<p>但也容易造成大事务，引发其他的问题。</p>
<p>下面用一张图看看大事务引发的问题。</p>
<p><img src="https://img-blog.csdnimg.cn/d313f62e4a01487790cbf8cf4c474787.png"></p>
<p>从图中能够看出，大事务问题可能会造成接口超时，对接口的性能有直接的影响。</p>
<p>我们该如何优化大事务呢？</p>
<ol>
<li><p>少用@Transactional注解</p>
</li>
<li><p>将查询(select)方法放到事务外</p>
</li>
<li><p>事务中避免远程调用</p>
</li>
<li><p>事务中避免一次性处理太多数据</p>
</li>
<li><p>有些功能可以非事务执行</p>
</li>
<li><p>有些功能可以异步处理</p>
</li>
</ol>
<p>大家可以参考关于大事务的这篇文章《<a href="https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&mid=2247490259&idx=1&sn=1dd11c5f49103ca303a61fc82ce406e0&chksm=c0ebc23bf79c4b2db58b28ef752560bd91a1932ceb6713c9b19b821db0f29e1c58275d334076&token=2041133408&lang=zh_CN&scene=21#wechat_redirect" title="让人头痛的大事务问题到底要如何解决？">让人头痛的大事务问题到底要如何解决？</a>》</p>
<h2 id="20-消除过长的if…else"><a href="#20-消除过长的if…else" class="headerlink" title="20.消除过长的if…else"></a>20.消除过长的if…else</h2><p>更详细的内容可以看看这篇文章《<a href="https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&mid=2247490272&idx=1&sn=c5db63c7b52e7518b7a42e48c70927fc&scene=21#wechat_redirect" title="消除if...else是9条锦囊妙计">消除if…else是9条锦囊妙计</a>》</p>
<h2 id="21-防止死循环"><a href="#21-防止死循环" class="headerlink" title="21.防止死循环"></a>21.防止死循环</h2><h2 id="22-注意BigDecimal的坑"><a href="#22-注意BigDecimal的坑" class="headerlink" title="22.注意BigDecimal的坑"></a>22.注意BigDecimal的坑</h2><p>通常我们会把一些小数类型的字段（比如：金额），定义成<em><strong>BigDecimal</strong></em>，而不是<em><strong>Double</strong></em>，避免丢失精度问题。</p>
<p>常识告诉我们使用<em><strong>BigDecimal</strong></em>能避免丢失精度。</p>
<p>但是使用BigDecimal能避免丢失精度吗？</p>
<p>答案是否定的。</p>
<p>为什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">amount1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.02</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">amount2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.03</span>);</span><br><span class="line">System.out.println(amount2.subtract(amount1));</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<blockquote>
<p>0.0099999999999999984734433411404097569175064563751220703125</p>
</blockquote>
<p>不科学呀，为啥还是丢失精度了？</p>
<p>使用BigDecimal构造函数初始化对象，也会丢失精度。</p>
<p>那么，如何才能不丢失精度呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">amount1</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">0.02</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">amount2</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">0.03</span>);</span><br><span class="line">System.out.println(amount2.subtract(amount1));</span><br></pre></td></tr></table></figure>

<h2 id="23-尽可能复用代码"><a href="#23-尽可能复用代码" class="headerlink" title="23.尽可能复用代码"></a>23.尽可能复用代码</h2><h2 id="24-foreach循环中不remove元素"><a href="#24-foreach循环中不remove元素" class="headerlink" title="24.foreach循环中不remove元素"></a>24.foreach循环中不remove元素</h2><p>循环有很多种写法，比如：while、for、foreach等。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = Lists.newArrayList(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String temp : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;c&quot;</span>.equals(temp)) &#123;</span><br><span class="line">                list.remove(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果：</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.util.ConcurrentModificationException</span><br><span class="line"> at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">901</span>)</span><br><span class="line"> at java.util.ArrayList$Itr.next(ArrayList.java:<span class="number">851</span>)</span><br><span class="line"> at com.sue.jump.service.test1.Test2.main(Test2.java:<span class="number">24</span>)</span><br></pre></td></tr></table></figure>

<p>这种在<em><strong>foreach</strong></em>循环中调用<em><strong>remove</strong></em>方法删除元素，可能会报<em><strong>ConcurrentModificationException</strong></em>异常。</p>
<p>如果想在遍历集合时，删除其中的元素，可以用for循环，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">           <span class="keyword">if</span> (<span class="string">&quot;c&quot;</span>.equals(temp)) &#123;</span><br><span class="line">               list.remove(temp);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(list);</span><br></pre></td></tr></table></figure>

<h2 id="25-避免随意打印日志"><a href="#25-避免随意打印日志" class="headerlink" title="25.避免随意打印日志"></a>25.避免随意打印日志</h2><p>使用<em><strong>isDebugEnabled</strong></em>判断一下，如果当前的日志级别是<em><strong>debug</strong></em>才打印日志。生产环境默认日志级别是<em><strong>info</strong></em>，在有些紧急情况下，把某个接口或者方法的日志级别改成debug，打印完我们需要的日志后，又调整回去。</p>
<p>方便我们定位问题，又不会产生大量的垃圾日志，一举两得</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/query&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">query</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;request params:&#123;&#125;&quot;</span>, ids);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; userList = userService.query(ids);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;response:&#123;&#125;&quot;</span>, userList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="26-比较时把常量写前面"><a href="#26-比较时把常量写前面" class="headerlink" title="26.比较时把常量写前面"></a>26.比较时把常量写前面</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FOUND_NAME</span> <span class="operator">=</span> <span class="string">&quot;苏三&quot;</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">null</span> == user) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(FOUND_NAME.equals(user.getName())) &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;找到：&quot;</span>+user.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用<em><strong>equals</strong></em>做比较时，尽量将<em><strong>常量</strong></em>写在前面，即equals方法的左边。</p>
<p>这样即使user.getName()返回的数据为null，equals方法会直接返回false，而不再是报空指针异常。</p>
<h2 id="27-名称要见名知意"><a href="#27-名称要见名知意" class="headerlink" title="27.名称要见名知意"></a>27.名称要见名知意</h2><h2 id="28-SimpleDateFormat线程不安全"><a href="#28-SimpleDateFormat线程不安全" class="headerlink" title="28.SimpleDateFormat线程不安全"></a>28.SimpleDateFormat线程不安全</h2><p>使用java8的DateTimeFormatter类。  </p>
<h2 id="29-少用Executors创建线程池"><a href="#29-少用Executors创建线程池" class="headerlink" title="29.少用Executors创建线程池"></a>29.少用Executors创建线程池</h2><p>我们都知道<em><strong>JDK5</strong></em>之后，提供了<em><strong>ThreadPoolExecutor</strong></em>类，用它可以<em><strong>自定义线程池</strong></em>。</p>
<p>线程池的好处有很多，下面主要说说这3个方面。</p>
<ol>
<li><p><em><strong>降低资源消耗</strong></em>：避免了频繁的创建线程和销毁线程，可以直接复用已有线程。而我们都知道，创建线程是非常耗时的操作。</p>
</li>
<li><p><em><strong>提供速度</strong></em>：任务过来之后，因为线程已存在，可以拿来直接使用。</p>
</li>
<li><p><em><strong>提高线程的可管理性</strong></em>：线程是非常宝贵的资源，如果创建过多的线程，不仅会消耗系统资源，甚至会影响系统的稳定。使用线程池，可以非常方便的创建、管理和监控线程。</p>
</li>
</ol>
<p>当然JDK为了我们使用更便捷，专门提供了：<em><strong>Executors</strong></em>类，给我们快速创建<em><strong>线程池</strong></em>。</p>
<p>该类中包含了很多<em><strong>静态方法</strong></em>：</p>
<ul>
<li><p><em><strong>newCachedThreadPool</strong></em>：创建一个可缓冲的线程，如果线程池大小超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>
</li>
<li><p><em><strong>newFixedThreadPool</strong></em>：创建一个固定大小的线程池，如果任务数量超过线程池大小，则将多余的任务放到队列中。</p>
</li>
<li><p><em><strong>newScheduledThreadPool</strong></em>：创建一个固定大小，并且能执行定时周期任务的线程池。</p>
</li>
<li><p><em><strong>newSingleThreadExecutor</strong></em>：创建只有一个线程的线程池，保证所有的任务安装顺序执行。</p>
</li>
</ul>
<p>在高并发的场景下，如果大家使用这些静态方法创建线程池，会有一些问题。</p>
<p>那么，我们一起看看有哪些问题？</p>
<ul>
<li><p><em><strong>newFixedThreadPool</strong></em>：允许请求的队列长度是Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。</p>
</li>
<li><p><em><strong>newSingleThreadExecutor</strong></em>：允许请求的队列长度是Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。</p>
</li>
<li><p><em><strong>newCachedThreadPool</strong></em>：允许创建的线程数是Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。</p>
</li>
</ul>
<p>那我们该怎办呢？</p>
<p>优先推荐使用<em><strong>ThreadPoolExecutor</strong></em>类，我们自定义线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">8</span>, <span class="comment">//corePoolSize线程池中核心线程数</span></span><br><span class="line">    <span class="number">10</span>, <span class="comment">//maximumPoolSize 线程池中最大线程数</span></span><br><span class="line">    <span class="number">60</span>, <span class="comment">//线程池中线程的最大空闲时间，超过这个时间空闲线程将被回收</span></span><br><span class="line">    TimeUnit.SECONDS,<span class="comment">//时间单位</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">500</span>), <span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()); <span class="comment">//拒绝策略</span></span><br></pre></td></tr></table></figure>

<p>顺便说一下，如果是一些低并发场景，使用<em><strong>Executors</strong></em>类创建线程池也未尝不可，也不能完全一棍子打死。在这些低并发场景下，很难出现<em><strong>OOM</strong></em>问题，所以我们需要根据实际业务场景选择。</p>
<h2 id="30-Arrays-asList转换的集合别修改"><a href="#30-Arrays-asList转换的集合别修改" class="headerlink" title="30.Arrays.asList转换的集合别修改"></a>30.Arrays.asList转换的集合别修改</h2><p>在我们日常工作中，经常需要把<em><strong>数组</strong></em>转换成<em><strong>List</strong></em>集合。</p>
<p>因为数组的长度是固定的，不太好扩容，而List的长度是可变的，它的长度会根据元素的数量动态扩容。</p>
<p>在JDK的<em><strong>Arrays</strong></em>类中提供了<em><strong>asList</strong></em>方法，可以把<em><strong>数组</strong></em>转换成<em><strong>List</strong></em>。</p>
<p><em><strong>正例</strong></em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String [] array = <span class="keyword">new</span> <span class="title class_">String</span> [] &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(array);</span><br><span class="line"><span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，使用Arrays.asList方法将array数组，直接转换成了list。然后在for循环中遍历list，打印出它里面的元素。</p>
<p>如果转换后的list，只是使用，没新增或修改元素，不会有问题。</p>
<p><em><strong>反例</strong></em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] array = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(array);</span><br><span class="line">list.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.UnsupportedOperationException</span><br><span class="line">at java.util.AbstractList.add(AbstractList.java:<span class="number">148</span>)</span><br><span class="line">at java.util.AbstractList.add(AbstractList.java:<span class="number">108</span>)</span><br><span class="line">at com.sue.jump.service.test1.Test2.main(Test2.java:<span class="number">24</span>)</span><br></pre></td></tr></table></figure>

<p>会直接报<code>UnsupportedOperationException</code>异常。</p>
<p>为什么呢？</p>
<p>答：使用<em><strong>Arrays.asList</strong></em>方法转换后的<em><strong>ArrayList</strong></em>，是<em><strong>Arrays</strong></em>类的内部类，并非<em><strong>java.util</strong></em>包下我们常用的<em><strong>ArrayList</strong></em>。</p>
<p>Arrays类的内部ArrayList类，它没有实现父类的add和remove方法,用的是父类AbstractList的默认实现。</p>
<p>我们看看<em><strong>AbstractList</strong></em>是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类的<em><strong>add</strong></em>和<em><strong>remove</strong></em>方法直接抛异常了，因此调用Arrays类的内部ArrayList类的add和remove方法，同样会抛异常。</p>
<p>说实话，Java代码优化是一个比较大的话题，它里面可以优化的点非常多，我没办法一一列举完。在这里只能抛砖引玉，介绍一下比较常见的知识点，更全面的内容，需要小伙伴们自己去思考和探索。</p>
<p>这篇文章写了很久，花了很多时间和心思，如果你看了文章有些收获，记得给我点赞鼓励一下喔。</p>
<p>bye</p>
<br />]]></content>
      <categories>
        <category>代码优化</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>java常用第三方工具库</title>
    <url>/2023/06/04/java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%BA%93/</url>
    <content><![CDATA[<br />

<h3 id="Java常用工具类库"><a href="#Java常用工具类库" class="headerlink" title="Java常用工具类库"></a>Java常用工具类库</h3><ul>
<li><a href="#1_java_2">1. java自带工具方法</a></li>
<li><a href="#2_apache_commons_118">2. apache commons工具类库</a><ul>
<li></li>
<li><a href="#21_commonslangjavalang_121">2.1 commons-lang，java.lang的增强版</a></li>
<li><a href="#22_commonscollections__211">2.2 commons-collections 集合工具类</a></li>
<li><a href="#23_commonbeanutils__269">2.3 common-beanutils 操作对象</a></li>
<li><a href="#24_commonsio__335">2.4 commons-io 文件流处理</a></li>
</ul>
</li>
<li><a href="#3_Google_guava_383">3. Google guava工具类库</a></li>
<li><a href="#4_Hutool_510">4. Hutool工具类库</a></li>
<li><a href="#5_json_527">5. json处理工具</a></li>
</ul>
<br />

]]></content>
      <categories>
        <category>java工具类库</category>
      </categories>
      <tags>
        <tag>hutool</tag>
        <tag>apache common</tag>
        <tag>guava</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用命令</title>
    <url>/2023/06/04/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<hr>
<p><a href="https://blog.csdn.net/weixin_44624117/article/details/101368670">1、常用Linux命令</a><br><a href="https://blog.csdn.net/lydms/article/details/128926048">2、Linux下脚本编写</a><br><a href="https://blog.csdn.net/weixin_44624117/article/details/103768670">3、windows下CMD常用命令</a></p>
<hr>
<br />

<h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><ul>
<li><ul>
<li><a href="#_35">一、目录操作</a><ul>
<li></li>
<li><a href="#1_99">1、批量操作</a></li>
</ul>
</li>
<li><a href="#_108">二、文件操作</a></li>
<li><a href="#font_colordd0000font_186">三、文件内容操作（查看日志，更改配置文件）</a><ul>
<li></li>
<li><a href="#1grep_245">1、grep(检索文件内容)</a></li>
<li><a href="#2awk_262">2、awk(数据统计)</a></li>
<li><a href="#3sed_321">3、sed(替换文件内容)</a></li>
<li><a href="#4_391">4、管道操作符`|`</a></li>
<li><a href="#5cut_436">5、cut(数据裁剪)</a></li>
</ul>
</li>
<li><a href="#_466">四、系统日志位置</a></li>
<li><a href="#_483">五、创建与删除软连接</a></li>
<li><a href="#_501">六、压缩和解压缩</a></li>
<li><a href="#Linux_554">七、Linux下文件的详细信息</a></li>
<li><a href="#docker_577">八、常用的docker容器的命令：</a></li>
<li><a href="#_609">九、运维常用命令</a><ul>
<li></li>
<li><a href="#1_610">1、查看服务器端口号是否可用</a></li>
</ul>
</li>
<li><a href="#yum_753">十、yum常用命令</a></li>
<li><a href="#_764">十一、其他命令</a><ul>
<li></li>
<li><a href="#1xargs_765">1、xargs</a></li>
<li><a href="#2curl_885">2、curl语法</a></li>
<li><a href="#3_903">3、查询支持解析器</a></li>
</ul>
</li>
<li><a href="#Linux_927">十二、Linux内核优化</a></li>
<li><a href="#_941">十三、用户权限操作</a><ul>
<li></li>
<li><a href="#1_943">1、用户操作</a></li>
<li><a href="#2_1025">2、添加组</a></li>
<li><a href="#3sudo_1057">3、sudo用户权限操作</a></li>
<li><a href="#4_1072">4、更换文件所有者</a></li>
</ul>
</li>
<li><a href="#TOP_1088">十四、TOP</a><ul>
<li></li>
<li><a href="#1_1100">1、统计信息区</a></li>
<li><a href="#2_1142">2、进程信息区</a></li>
</ul>
</li>
<li><a href="#_1174">十五、文件安装</a><ul>
<li></li>
<li><a href="#1lrzsz_1175">1、文件下载(lrzsz)</a></li>
</ul>
</li>
<li><a href="#PDF_1190">十六、文章PDF版本</a></li>
</ul>
</li>
</ul>
<br />

<hr>
<p>Linux 系统目录</p>
<figure class="highlight plaintext"><figcaption><span>language-shell</span></figcaption><table><tr><td class="code"><pre><span class="line">├── bin -&gt; usr/bin # 用于存放二进制命令</span><br><span class="line">├── boot # 内核及引导系统程序所在的目录</span><br><span class="line">├── dev # 所有设备文件的目录（如磁盘、光驱等）</span><br><span class="line">├── etc # 配置文件默认路径、服务启动命令存放目录</span><br><span class="line">├── home # 用户家目录，root用户为/root</span><br><span class="line">├── lib -&gt; usr/lib # 32位库文件存放目录</span><br><span class="line">├── lib64 -&gt; usr/lib64 # 64位库文件存放目录</span><br><span class="line">├── media # 媒体文件存放目录</span><br><span class="line">├── mnt # 临时挂载设备目录</span><br><span class="line">├── opt # 自定义软件安装存放目录</span><br><span class="line">├── proc # 进程及内核信息存放目录</span><br><span class="line">├── root # Root用户家目录</span><br><span class="line">├── run # 系统运行时产生临时文件，存放目录</span><br><span class="line">├── sbin -&gt; usr/sbin # 系统管理命令存放目录</span><br><span class="line">├── srv # 服务启动之后需要访问的数据目录</span><br><span class="line">├── sys # 系统使用目录</span><br><span class="line">├── tmp # 临时文件目录</span><br><span class="line">├── usr # 系统命令和帮助文件目录</span><br><span class="line">└── var # 存放内容易变的文件的目录</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>接口性能优化</title>
    <url>/2023/06/04/%E6%8E%A5%E5%8F%A3%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>前言 </p>
]]></content>
      <categories>
        <category>代码优化</category>
      </categories>
      <tags>
        <tag>接口优化</tag>
        <tag>sql优化</tag>
      </tags>
  </entry>
</search>
