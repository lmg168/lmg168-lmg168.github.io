<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ELK分布式部署</title>
    <url>/2023/06/04/ELK%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍 "></a>一、基本介绍 </h2><h3 id="1-什么是分布式日志"><a href="#1-什么是分布式日志" class="headerlink" title="1. 什么是分布式日志"></a>1. 什么是分布式日志</h3><p>相信大家平时工作中，在生产环境中经常会遇到很多异常，报错信息，需要查看日志信息排查错误，并且这个项目是分布式应用，日志被分散在储存不同的设备上。如果你管理数十上百台服务器，还使用依次登录每台机器的传统方法查阅日志。这样是不是感觉很繁琐和效率低下。所以我们使用集中化的日志管理，分布式日志就是对大规模日志数据进行采集、追踪、处理。</p>
<p>一般我们需要进行日志分析场景：直接在日志文件中<code>grep</code>、<code>awk</code>就可以获得自己想要的信息。但在规模较大的场景中，此方法效率低下，面临问题包括日志量太大如何归档、文本搜索太慢怎么办、如何多维度查询。需要集中化的日志管理，所有服务器上的日志收集汇总。常见解决思路是建立集中式日志收集系统，将所有节点上的日志统一收集，管理，访问。</p>
<h3 id="2-ELK-分布式日志"><a href="#2-ELK-分布式日志" class="headerlink" title="2. ELK 分布式日志"></a>2. ELK 分布式日志</h3><p>实际上<code>ELK</code>是三款软件的简称，分别是<code>Elasticsearch</code>、 <code>Logstash</code>、<code>Kibana</code>组成。</p>
<p><strong>Elasticsearch</strong> 基于<code>java</code>，是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，<code>restful</code>风格接口，多数据源，自动搜索负载等。</p>
<p><strong>Kibana</strong> 基于<code>nodejs</code>，也是一个开源和免费的工具，<code>Kibana</code>可以为<code>Logstash</code>和<code>ElasticSearch</code>提供的日志分析友好的 Web 界面，可以汇总、分析和搜索重要数据日志。</p>
<p><strong>Logstash</strong> 基于<code>java</code>，是一个开源的用于收集,分析和存储日志的工具。</p>
<p>下面是<code>ELK</code>的工作原理： <img src="https://imge.ablog168.cn/blog_img/6c83ad78c0d4dc5c665af3d20fb5863f.png" alt="elk"></p>
<p>假如，我们的项目部署在了 3 台服务器上，一般情况下，3 台全部需要安装 <code>Elasticsearch</code>，作为主节点的服务器上安装 <code>Kibana</code>，其中一个节点服务器上安装 <code>Logstash</code>。</p>
<p>接下来，我们就来搭建一下。</p>
<h2 id="二、搭建-ELK"><a href="#二、搭建-ELK" class="headerlink" title="二、搭建 ELK"></a>二、搭建 ELK</h2><p>大家搭建过程中，一定要注意版本之间的对应，如果版本不对应，会出现各种启动报错。</p>
<p><strong>版本说明：</strong></p>
<ul>
<li><code>CentOS 7.9</code></li>
<li><code>JDK 1.8</code></li>
<li><code>Elasticsearch-8.0.0</code></li>
<li><code>Logstash-8.0.0</code></li>
<li><code>Kibana-8.0.0</code></li>
</ul>
<h3 id="1-Elasticsearch"><a href="#1-Elasticsearch" class="headerlink" title="1. Elasticsearch"></a>1. Elasticsearch</h3><h4 id="1-1-、简介"><a href="#1-1-、简介" class="headerlink" title="1.1 、简介"></a>1.1 、简介</h4><p>ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。</p>
<h4 id="1-2、安装配置"><a href="#1-2、安装配置" class="headerlink" title="1.2、安装配置"></a>1.2、安装配置</h4><p>首先去官网下载：<a href="https://www.elastic.co/cn/downloads/elasticsearch">Download Elasticsearch | Elastic</a>，选择 <code>Linux</code> 版本</p>
<p><img src="https://imge.ablog168.cn/blog_img/49744b1939f185a34333eb99d3f36c37.png" alt="image-20220221143822296"></p>
<blockquote>
<p>PS：官网的下载速度还是挺快的</p>
</blockquote>
<p>本次我使用的是虚拟机中的 <code>CentOS 7</code> ，首先将下载下来的 <code>tar</code> 包复制到虚拟机中的 <code>/usr/local</code> 下，</p>
<ul>
<li>解压</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf elasticsearch-8.0.0-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure>
<ul>
<li>修改配置</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/elasticsearch-8.0.0/config/</span><br><span class="line">vim elasticsearch.yml</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cluster.name:</span> <span class="string">my-application</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-1</span></span><br><span class="line"><span class="attr">path.data:</span> <span class="string">/home/esuser/data</span>	<span class="comment"># 数据文件存放目录</span></span><br><span class="line"><span class="attr">path.logs:</span> <span class="string">/home/esuser/logs</span>	<span class="comment"># 日志文件存放目录</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>			<span class="comment"># 对所有IP开放</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span>					<span class="comment"># 端口号</span></span><br><span class="line"><span class="attr">discovery.seed_hosts:</span> [<span class="string">&quot;192.168.20.105&quot;</span>]</span><br><span class="line"><span class="attr">cluster.initial_master_nodes:</span> [<span class="string">&quot;node-1&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>注意：<code>path.data</code> 和 <code>path.logs</code> 目录需要自己手动创建出来 <code>mkdir</code></p>
<blockquote>
<p>注：这些配置默认是被注释的状态，修改之后打开注释即可</p>
</blockquote>
<p>除此之外，因本次我们只是测试学习，所以我们可以把安全相关的配置给关掉，都从 <code>true</code> 改为了 <code>false</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Enable security features</span></span><br><span class="line"><span class="attr">xpack.security.enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">xpack.security.enrollment.enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># Enable encryption for HTTP API client connections, such as Kibana, Logstash, and Agents</span></span><br><span class="line"><span class="attr">xpack.security.http.ssl:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">keystore.path:</span> <span class="string">certs/http.p12</span></span><br><span class="line"><span class="comment"># Enable encryption and mutual authentication between cluster nodes</span></span><br><span class="line"><span class="attr">xpack.security.transport.ssl:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>修改完成后保存退出编辑</p>
<ul>
<li>创建 esuser 用户</li>
</ul>
<p>因为<code>ElasticSearch</code>不支持<code>Root</code>用户直接操作，因此我们需要创建一个<code>esuser</code>用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建用户</span></span><br><span class="line">useradd esuser</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置密码</span></span><br><span class="line">passwd esuser</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋予用户权限</span></span><br><span class="line">chown -R esuser:esuser /usr/local/elasticsearch-8.0.0</span><br></pre></td></tr></table></figure>
<h4 id="1-3、启动"><a href="#1-3、启动" class="headerlink" title="1.3、启动"></a>1.3、启动</h4><p>切换用户成 esuser 用户进行操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su esuser</span><br><span class="line">cd /usr/local/elasticsearch-8.0.0/bin</span><br><span class="line">./elasticsearch -d &amp; tail -f /home/esuser/logs/my-application.log 	# 后台启动并查看启动日志</span><br></pre></td></tr></table></figure>
<p>如果启动没有报错，宿主机浏览器访问地址：<a href="http://192.168.20.105:9200/">http://192.168.20.105:9200/</a></p>
<p>其中 192.168.20.105 是虚拟机的静态 ip ，访问成功如下图（注意防火墙）</p>
<p><img src="https://imge.ablog168.cn/blog_img/8b31b024d72761b8a5ad36f989beb84d.png" alt="image-20220221150331066"></p>
<h3 id="2-Logstash"><a href="#2-Logstash" class="headerlink" title="2. Logstash"></a>2. Logstash</h3><h4 id="2-1、简介"><a href="#2-1、简介" class="headerlink" title="2.1、简介"></a>2.1、简介</h4><p><code>Logstash</code> 是一个开源的服务器端数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到存储库中，本篇中我们的存储库当然就是<code>ElasticSearch</code> 了。</p>
<h4 id="2-2、安装配置"><a href="#2-2、安装配置" class="headerlink" title="2.2、安装配置"></a>2.2、安装配置</h4><p>官网下载地址：<a href="https://www.elastic.co/cn/downloads/logstash">Download Logstash Free | Get Started Now | Elastic</a></p>
<p><img src="https://imge.ablog168.cn/blog_img/4cfc04613f8ac7afc44ddfa261eadc74.png" alt="image-20220221150759334"></p>
<p>将下载下来的 <code>tar</code> 包复制到虚拟机中的 <code>/usr/local</code> 下，</p>
<ul>
<li>解压</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf logstash-8.0.0-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure>
<ul>
<li>新增配置文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/logstash-8.0.0/bin</span><br><span class="line">touch logstash-elasticsearch.conf</span><br><span class="line">vim logstash-elasticsearch.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">	stdin &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">	elasticsearch &#123;</span><br><span class="line">		hosts =&gt; &#x27;192.168.20.105:9200&#x27;</span><br><span class="line">	&#125;</span><br><span class="line">	stdout &#123;</span><br><span class="line">		codec =&gt; rubydebug</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意里面 <code>elasticsearch</code> 的地址</p>
<h4 id="2-3、启动"><a href="#2-3、启动" class="headerlink" title="2.3、启动"></a>2.3、启动</h4><p>此时是在 root 用户下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/logstash-8.0.0/bin</span><br><span class="line">nohup ./logstash -f logstash-elasticsearch.conf &amp;		# 后台启动</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：执行后台启动命令，查看 <code>nohup.out</code> 日志时发现有报错，但好像也启动成功了，不影响使用，不用 nohup 则不会报错。</p>
</blockquote>
<p>使用 <code>jps</code>查看当前所有 java 进程</p>
<p><img src="https://imge.ablog168.cn/blog_img/0993d5a2d2ac963f85e82ccf19e2941f.png" alt="image-20220221152813960"></p>
<p>发现启动成功了。</p>
<h3 id="3-Kibana"><a href="#3-Kibana" class="headerlink" title="3. Kibana"></a><em>3. Kibana</em></h3><h4 id="3-1、简介"><a href="#3-1、简介" class="headerlink" title="3.1、简介"></a>3.1、简介</h4><p>Kibana 是一款开源的数据分析和可视化平台，它是 Elastic Stack 成员之一，设计用于和 Elasticsearch 协作。您可以使用 Kibana 对 Elasticsearch 索引中的数据进行搜索、查看、交互操作。您可以很方便的利用图表、表格及地图对数据进行多元化的分析和呈现。</p>
<h4 id="3-2、安装配置"><a href="#3-2、安装配置" class="headerlink" title="3.2、安装配置"></a>3.2、安装配置</h4><p>官网下载地址：<a href="https://www.elastic.co/cn/downloads/kibana">Download Kibana Free | Get Started Now | Elastic</a></p>
<p><img src="https://imge.ablog168.cn/blog_img/c50267d3fd29500b01612f5fea5e7213.png" alt="image-20220221153019991"></p>
<p>将下载下来的 <code>tar</code> 包复制到虚拟机中的 <code>/usr/local</code> 下，</p>
<ul>
<li>解压</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf kibana-8.0.0-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure>
<ul>
<li>修改配置</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/kibana-8.0.0/config/</span><br><span class="line">vim kibana.yml</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port:</span> <span class="number">5601</span>			<span class="comment"># 端口号</span></span><br><span class="line"><span class="attr">server.host:</span> <span class="string">&quot;0.0.0.0&quot;</span>		<span class="comment"># 对所有ip开放访问</span></span><br><span class="line"><span class="attr">server.name:</span> <span class="string">&quot;my-kibana&quot;</span></span><br><span class="line"><span class="attr">elasticsearch.hosts:</span> [<span class="string">&quot;http://192.168.20.105:9200&quot;</span>]		<span class="comment"># es 地址</span></span><br><span class="line"><span class="attr">i18n.locale:</span> <span class="string">&quot;zh-CN&quot;</span>	<span class="comment"># 汉化</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：这些配置默认是被注释的状态，修改之后打开注释即可</p>
</blockquote>
<ul>
<li>kibana 同样不能使用 root 用户启动，所以我们使用前面创建的 esuser 用户，先授权</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown -R esuser:esuser /usr/local/kibana-8.0.0</span><br></pre></td></tr></table></figure>
<h4 id="3-3、启动"><a href="#3-3、启动" class="headerlink" title="3.3、启动"></a>3.3、启动</h4><p>切换到 esuser 用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su esuser</span><br></pre></td></tr></table></figure>
<p>后台启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/kibana-8.0.0/bin &amp;</span><br></pre></td></tr></table></figure>
<p>启动成功，浏览器访问地址：<a href="http://192.168.20.105:5601/">http://192.168.20.105:5601/</a></p>
<p>出现以下页面，说明启动成功</p>
<p><img src="https://imge.ablog168.cn/blog_img/80a7581ca2ad6dc1a8210493b9a3e402.png" alt="image-20220221155653678"></p>
<p>我们点击 <code>适用样例数据</code>，点击添加数据</p>
<p><img src="https://imge.ablog168.cn/blog_img/1318a1025a55e6440b26bafc5cba50f4.png" alt="image-20220221155825927"></p>
<p>点击 <code>Discover</code></p>
<p><img src="https://imge.ablog168.cn/blog_img/b6d45ca7c19e1585a3a264b83cbf163e.png" alt="image-20220221155911850"></p>
<p>就可以看到样例数据</p>
<p><img src="https://imge.ablog168.cn/blog_img/ddd06ab10fa3d322db8947a2ba6ad564.png" alt="image-20220221155950150"></p>
<p>到这里，我们分布式日志所需要的软件都已经安装配置并启动成功</p>
<p>至于如何使用，感觉还需要一篇文章来写。</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>微服务</tag>
        <tag>ELK</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>java项目安全问题</title>
    <url>/2023/06/04/Java%E9%A1%B9%E7%9B%AE%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p><strong>1.弱口令漏洞</strong></p>
<blockquote>
<p>解决方案：最好使用至少6位的数字、字母及特殊字符组合作为密码。数据库不要存储明文密码，应存储MD5加密后的密文，由于目前普通的MD5加密已经可以被破解，最好可以多重MD5加密，或者多种加密方式叠加组合。</p>
</blockquote>
<p><strong>2.未使用用户名及密码登录后台可直接输入后台URL登录系统。</strong></p>
<blockquote>
<p>解决方案：通过配置filter来过滤掉无效用户的连接请求。</p>
</blockquote>
<p><strong>3．JSP页面抛出的异常可能暴露程序信息。有经验的入侵者，可以从JSP程序的异常中获取很多信息，比如程序的部分架构、程序的物理路径、SQL注入爆出来的信息等。</strong></p>
<blockquote>
<p>解决方案：自定义一个Exception，将异常信息包装起来不要抛到页面上。</p>
</blockquote>
<p><strong>4.合法用户”注销”后，在未关闭浏览器的情况下，点击浏览器”后退”按钮，可从本地页面缓存中读取数据，绕过了服务端filter过滤。</strong></p>
<blockquote>
<blockquote>
<p>解决方案：配置filter对存放敏感信息的页面限制页面缓存。如：</p>
</blockquote>
<p>httpResponse.setHeader(“Cache-Control”,”no-cache”);<br>httpResponse.setHeader(“Cache-Control”,”no-store”);<br>httpResponse.setDateHeader(“Expires”, 0);<br>httpResponse.setHeader(“Pragma”,”no-cache”);</p>
</blockquote>
<p><strong>5.SQL注入漏洞。</strong></p>
<blockquote>
<p>解决方案：在数据库访问层中不要使用”+”来拼接SQL语句！如：</p>
<p>String sql= “SELECT * FROM USERS WHERE 1=1”; if(null !=<br>user.getUserName() \&amp;\&amp; !””.equals(user.getUserName())){<br>sql += “ and UNAME = ‘“+user.getUserName()+”‘“; } 而应使用PreparedStatement。如：</p>
<p>PreparedStatement pstmt = con.prepareStatement(“SELECT * FROM USERS<br>WHERE UNAME=?”); pstmt.setString(1, “Neeke”);<br>如果项目中使用了Hibernate框架，则推荐使用named parameter。如：</p>
<p>String queryString = “from Users where uname like :name”; 冒号后面是一个named<br>parameter，我们可以使用Query接口将一个参数绑定到name参数上：</p>
<p>List result = session.createQuery(queryString)<br>.setString(“name”, user.getUserName())<br>.list();</p>
</blockquote>
<p><strong>6.文件上传漏洞。前台仅使用JS对文件后缀做了过滤，这只能针对普通的用户，而恶意攻击者完全可以修改表单去掉JS校验。</strong></p>
<blockquote>
<p>解决方案：前台JS过滤加服务器端程序过滤。具体过滤掉哪些文件类型视具体情况而定。</p>
</blockquote>
<p><strong>7.可执行脚本漏洞。对用户提交的数据未转义，一些用户提交的含有JavaScript脚本的信息被直接输出到页面中从而被浏览器执行。</strong></p>
<blockquote>
<p>解决方案：使用org.apache.commons.lang.StringEscapeUtils对用户提交的数据进行转义。如：</p>
<p>@RequestMapping(params=”method=addTopic”,method=RequestMethod.POST)<br>public ModelAndView addTopic(HttpServletRequest request,<br>HttpServletResponse response, BbsTopic topic) { BaseAdmin user =<br>(BaseAdmin) request.getSession().getAttribute(Constant.SESSION_USER);<br>topic.setBaseAdmin(user); topic.setTopicDate(new<br>Timestamp(System.currentTimeMillis()));<br>topic.setTopicContent(StringEscapeUtils.escapeHtml(topic.getTopicContent()));<br>topic.setTopicTitle(StringEscapeUtils.escapeHtml(topic.getTopicTitle()));<br>this.bbsTopicService.save(topic); return new ModelAndView(new<br>RedirectView(“<a href="http://bbs.do?method=topicList&amp;bfid=">bbs.do?method=topicList\&amp;bfid=</a>“+ topic.getBfid())); }</p>
</blockquote>
<p><strong>8.Java WEB容器默认配置漏洞。如TOMCAT后台管理漏洞，默认用户名及密码登录后可直接上传war文件获取webshell。</strong></p>
<blockquote>
<p>解决方案：最好删除，如需要使用它来管理维护，可更改其默认路径，口令及密码。</p>
</blockquote>
<p><strong>9.日志，建议增加服务器的访问日志，记录来访者的IP,传递参数，对后台操作用户建立日志，记录操作内容，完善日志记录可以帮助你发现潜在危险，找到已经发生的问题。<br>10.重放攻击<br>11.僵尸网络暴力破解<br>12.登陆表单http明文提交<br>13.千万不要乱用数据类型，使用基本数据类型，少用包装类，包装类容易被攻击，不要用string去接受所有类型数据。原则上：是什么类型就用什么类型去接收。<br>14.通过架构设计，添加一层设置处理http参数。一般都是通过aop来实现.比如：对邮件，手机验证对整数最大值验证，对字符串最大长度验证<br>15.点击劫持，大概有两种方式，一是攻击者使用一个透明的iframe，覆盖在一个网页上，然后诱使用户在该页面上进行操作，此时用户将在不值钱的情况下点击透明的iframe页面，二是攻击者使用一张图片覆盖在网页，遮挡网页原有位置的含义。</strong></p>
]]></content>
      <categories>
        <category>java安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>sql注入</tag>
        <tag>上传漏洞</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown常用语法</title>
    <url>/2023/06/04/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p><br></p>
<p><strong>前言</strong><br>写过博客或者github上面的文档的，应该知道Markdown语法的重要性，不知道的朋友们也别着急，一篇博客轻松搞定Markdown语法。话说这个语法超级简单，一看就会，不信你点进来看看。</p>
<ol>
<li>快捷键</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>加粗</td>
<td>Ctrl + B</td>
</tr>
<tr>
<td>斜体</td>
<td>Ctrl + I</td>
</tr>
<tr>
<td>引用</td>
<td>Ctrl + Q</td>
</tr>
<tr>
<td>插入链接</td>
<td>Ctrl + L</td>
</tr>
<tr>
<td>插入代码</td>
<td>Ctrl + K</td>
</tr>
<tr>
<td>插入图片</td>
<td>Ctrl + G</td>
</tr>
<tr>
<td>提升标题</td>
<td>Ctrl + H</td>
</tr>
<tr>
<td>有序列表</td>
<td>Ctrl + O</td>
</tr>
<tr>
<td>无序列表</td>
<td>Ctrl + U</td>
</tr>
<tr>
<td>横线</td>
<td>Ctrl + R</td>
</tr>
<tr>
<td>撤销</td>
<td>Ctrl + Z</td>
</tr>
<tr>
<td>重做</td>
<td>Ctrl + Y</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>基本语法</li>
</ol>
<h3 id="2-1-字体设置斜体、粗体、删除线"><a href="#2-1-字体设置斜体、粗体、删除线" class="headerlink" title="2.1 字体设置斜体、粗体、删除线"></a>2.1 字体设置斜体、粗体、删除线</h3><p>*这里是文字*<br><em>这里是文字</em><br>**这里是文字**<br>***这里是文字***<br>~~这里是文字~~  </p>
<p><img src="https://imge.ablog168.cn/blog_img/20180802154402427" alt="这里写图片描述"></p>
<h3 id="2-2-分级标题"><a href="#2-2-分级标题" class="headerlink" title="2.2 分级标题"></a>2.2 分级标题</h3><p><strong>写法1：</strong></p>
<h1 id="一级标题-二级标题-三级标题-四级标题-五级标题-六级标题-这个写法和-文字-效果是一样的"><a href="#一级标题-二级标题-三级标题-四级标题-五级标题-六级标题-这个写法和-文字-效果是一样的" class="headerlink" title="一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 这个写法和 **文字**效果是一样的"></a>一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 这个写法和 **文字**效果是一样的</h1><p><img src="https://imge.ablog168.cn/blog_img/2018080215454373" alt="这里写图片描述"></p>
<p><strong>写法2：</strong>   </p>
<h1 id="这是一个一级标题"><a href="#这是一个一级标题" class="headerlink" title="这是一个一级标题  "></a>这是一个一级标题  </h1><p>或者  </p>
<p>二级标题  </p>
<hr>
<p><img src="https://imge.ablog168.cn/blog_img/20180802154915835" alt="这里写图片描述"></p>
<p><br /></p>
<h3 id="2-3-链接"><a href="#2-3-链接" class="headerlink" title="2.3 链接"></a>2.3 链接</h3><p>（1）插入本地图片链接<br>语法规则，有两种写法：<br><img src="https://imge.ablog168.cn/blog_img/20180802155057285" alt="这里写图片描述"><br>注意：这个图片描述可以不写。</p>
<p>示例图如下：<br><img src="https://imge.ablog168.cn/blog_img/20180802155239626" alt="这里写图片描述"></p>
<p>（2）插入互联网上图片<br>语法规则：<br><img src="https://imge.ablog168.cn/blog_img/20180802155336302" alt="这里写图片描述"><br>注意：这个图片描述可以不写。</p>
<p>示例如下：<br><img src="https://imge.ablog168.cn/blog_img/20180802155413115" alt="这里写图片描述"><br>（3）自动连接<br>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用\&lt;>包起来， Markdown 就会自动把它转成链接。也可以直接写，也是可以显示成链接形式的<br>例如：<br><img src="https://imge.ablog168.cn/blog_img/20180802155459346" alt="这里写图片描述"></p>
<h3 id="2-4-分割线"><a href="#2-4-分割线" class="headerlink" title="2.4 分割线"></a>2.4 分割线</h3><p>你可以在一行中用三个以上的星号(*)、减号(-)、底线(_)来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。<br><img src="https://imge.ablog168.cn/blog_img/20180802155556110" alt="这里写图片描述"></p>
<h3 id="2-5-代码块"><a href="#2-5-代码块" class="headerlink" title="2.5 代码块"></a>2.5 代码块</h3><p>对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(tab), 另一种是利用英文”`“符号（一般在ESC键下方，和~同一个键）包裹代码。</p>
<p>（1）代码块：缩进 4 个空格或是 1 个制表符。效果如下：<br><img src="https://imge.ablog168.cn/blog_img/20180802155701855" alt="这里写图片描述"><br>（2）行内式：如果在一个行内需要引用代码，只要用反引号`引起来就好（一般在ESC键下方，和~同一个键）<br><img src="https://imge.ablog168.cn/blog_img/20180802155907712" alt="这里写图片描述"></p>
<p>（3）多行代码块与语法高亮：在需要高亮的代码块的前一行及后一行使用三个单反引号”`“包裹，就可以了。<br>示例如下：<br><img src="https://imge.ablog168.cn/blog_img/20180802160015673" alt="这里写图片描述"></p>
<p>（4）代码块里面包含html代码<br>在代码区块里面， \&amp; 、 \&lt; 和 > 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理。</p>
<p><strong>注意：简书代码块里不支持html。</strong></p>
<p>示例如下：<br><img src="https://imge.ablog168.cn/blog_img/20180802160155483" alt="这里写图片描述"></p>
<h3 id="2-6-引用"><a href="#2-6-引用" class="headerlink" title="2.6 引用"></a>2.6 引用</h3><p>在被引用的文本前加上>符号，以及一个空格就可以了，如果只输入了一个>符号会产生一个空白的引用。</p>
<p>（1）基本使用<br>使用如下图所示：<br><img src="https://imge.ablog168.cn/blog_img/20180802160324418" alt="这里写图片描述"></p>
<p>（2）引用的嵌套使用<br>使用如图所示：<br><img src="https://imge.ablog168.cn/blog_img/20180802160343802" alt="这里写图片描述"><br>（3）引用其它要素<br>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等。<br>使用如图所示：<br><img src="https://imge.ablog168.cn/blog_img/20180802160421785" alt="这里写图片描述"></p>
<h3 id="2-7-列表"><a href="#2-7-列表" class="headerlink" title="2.7 列表"></a>2.7 列表</h3><p>（1）无序列表<br>使用 *，+，- 表示无序列表。<br>注意：符号后面一定要有一个空格，起到缩进的作用。<br><img src="https://imge.ablog168.cn/blog_img/2018080216053733" alt="这里写图片描述"></p>
<p>（2）有序列表<br>使用数字和一个英文句点表示有序列表。<br>注意：英文句点后面一定要有一个空格，起到缩进的作用。<br><img src="https://imge.ablog168.cn/blog_img/2018080216061165" alt="这里写图片描述"></p>
<p>（3）无序列表和有序列表同时使用<br><img src="https://imge.ablog168.cn/blog_img/20180802160735370" alt="这里写图片描述"></p>
<p>（4）列表和其它要素混合使用<br>列表不光可以单独使用，也可以使用其他的 Markdown 语法，包括标题、引用、代码区块等。</p>
<p><strong>注意事项：</strong></p>
<blockquote>
<p>（1）加粗效果不能直接用于列表标题里面，但是可以嵌套在列表里面混合使用。<br>（2）列表中包含代码块（前面加2个tab或者8个空格，并且需要空一行，否则不显示）。<br>.<br>使用示例如下图：<br><img src="https://imge.ablog168.cn/blog_img/20180802160851570" alt="这里写图片描述"></p>
</blockquote>
<p>（5）注意事项<br>在使用列表时，只要是数字后面加上英文的点，就会无意间产生列表，比如2017.12.30 这时候想表达的是日期，有些软件把它被误认为是列表。解决方式：在每个点前面加上\就可以了。如下图所示：<br><img src="https://imge.ablog168.cn/blog_img/20180802161039348" alt="这里写图片描述"></p>
<h3 id="2-8-表格"><a href="#2-8-表格" class="headerlink" title="2.8 表格"></a>2.8 表格</h3><p>表格的基本写法很简单，就跟表格的形状很相似：<br><img src="https://imge.ablog168.cn/blog_img/20180802161209660" alt="这里写图片描述"></p>
<p>表格对齐方式：我们可以指定表格单元格的对齐方式，冒号在左边表示左对齐，右边表示有对齐，两边都有表示居中。</p>
<p>如下图所示：<br><img src="https://imge.ablog168.cn/blog_img/20180802161235917" alt="这里写图片描述"></p>
<h2 id="3-常用技巧"><a href="#3-常用技巧" class="headerlink" title="3. 常用技巧"></a>3. 常用技巧</h2><h3 id="3-1-换行"><a href="#3-1-换行" class="headerlink" title="3.1 换行"></a>3.1 换行</h3><p>方法1: 连续两个以上空格+回车<br>方法2：使用html语言换行标签：  </p>
<h3 id="3-2-缩进字符"><a href="#3-2-缩进字符" class="headerlink" title="3.2 缩进字符"></a>3.2 缩进字符</h3><p>不断行的空白格 或 半角的空格   或  全角的空格   或  <br><img src="https://imge.ablog168.cn/blog_img/20180802162415963" alt="这里写图片描述"></p>
<h3 id="3-3-特殊符号"><a href="#3-3-特殊符号" class="headerlink" title="3.3 特殊符号"></a>3.3 特殊符号</h3><p>（1）对于 Markdown 中的语法符号，前面加反斜线\即可显示符号本身。</p>
<p>示例如下：<br><img src="https://imge.ablog168.cn/blog_img/20180802162507298" alt="这里写图片描述"></p>
<p>（2）其他特殊字符，示例如下：<br><img src="https://imge.ablog168.cn/blog_img/20180802162542616" alt="这里写图片描述"><br>想知道字符对应的Unicode码，可以看这个网站：<a href="https://unicode-table.com/cn/">https://unicode-table.com/cn/</a></p>
<p><strong>附上几个工具对特殊字符的支持的对比图:</strong><br><img src="https://img-blog.csdn.net/20180802162726962?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQwNjE2MzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h3 id="3-4-字体、字号与颜色"><a href="#3-4-字体、字号与颜色" class="headerlink" title="3.4 字体、字号与颜色"></a>3.4 字体、字号与颜色</h3><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通文本内容具有一定的格式。但是它本身是不支持修改字体、字号与颜色等功能的！</p>
<p>CSDN-markdown编辑器是其衍生版本，扩展了Markdown的功能（如表格、脚注、内嵌HTML等等）！对，就是内嵌HTML，接下来要讲的功能就需要使用内嵌HTML的方法来实现。</p>
<p>字体，字号和颜色编辑如下代码<br><img src="https://imge.ablog168.cn/blog_img/20180802162832307" alt="这里写图片描述"></p>
<p>具体颜色分类及标记请看下表：<br><img src="https://imge.ablog168.cn/blog_img/20180802162907453" alt="这里写图片描述"></p>
<h3 id="3-5-链接的高级操作"><a href="#3-5-链接的高级操作" class="headerlink" title="3.5 链接的高级操作"></a>3.5 链接的高级操作</h3><p>链接的高级操作（这个需要掌握一下，很有用）</p>
<h4 id="1-行内式"><a href="#1-行内式" class="headerlink" title="1.行内式"></a>1.行内式</h4><p>这个在上文第二条基本语法的 链接这个小节已经过，这里就不继续讲解了。</p>
<h4 id="2-参考式链接"><a href="#2-参考式链接" class="headerlink" title="2.参考式链接"></a>2.参考式链接</h4><p>在文档要插入图片的地方写![图片或网址链接][标记]，在文档的最后写上[标记]:图片地址 “标题”。（最后这个”标题”可以不填写）</p>
<p>示例如下：<br><img src="https://imge.ablog168.cn/blog_img/2018080216303854" alt="这里写图片描述"></p>
<h4 id="3-内容目录"><a href="#3-内容目录" class="headerlink" title="3.内容目录"></a>3.内容目录</h4><p>在段落中填写 [TOC] 以显示全文内容的目录结构。</p>
<h4 id="4-锚点"><a href="#4-锚点" class="headerlink" title="4.锚点"></a>4.锚点</h4><p>锚点其实就是页内超链接。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。</p>
<p><strong>注意</strong>：在简书中使用锚点时，点击会打开一个新的当前页面，虽然锚点用的不是很舒服，但是可以用注脚实现这个功能。</p>
<p><strong>语法说明：</strong><br>在你准备跳转到的指定标题后插入锚点，然后在文档的其它地方写上连接到锚点的链接。</p>
<p>使用如下图所示：<br><img src="https://imge.ablog168.cn/blog_img/20180802163343495" alt="这里写图片描述"></p>
<h4 id="5-注脚"><a href="#5-注脚" class="headerlink" title="5.注脚"></a>5.注脚</h4><p><strong>语法说明：</strong><br>在需要添加注脚的文字后加上脚注名字[\^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。</p>
<p>示例如下：<br><img src="https://imge.ablog168.cn/blog_img/20180802163447739" alt="这里写图片描述"><br>注：</p>
<blockquote>
<ol>
<li>脚注自动被搬运到最后面，请到文章末尾查看，并且脚注后方的链接可以直接跳转回到加注的地方。</li>
<li>由于简书不支持锚点，所以可以用注脚实现页面内部的跳转。</li>
</ol>
</blockquote>
<h3 id="3-6-背景色"><a href="#3-6-背景色" class="headerlink" title="3.6 背景色"></a>3.6 背景色</h3><p>Markdown本身不支持背景色设置，需要采用内置html的方式实现：借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色的功能。举例如下：</p>
<p>\<table\>\<tr\>\<td bgcolor=orange\>背景色是：orange\&lt;/td>\&lt;/tr>\&lt;/table></p>
<p><img src="https://imge.ablog168.cn/blog_img/20180802164159599" alt="这里写图片描述"></p>
<h3 id="3-7-emoji表情符号"><a href="#3-7-emoji表情符号" class="headerlink" title="3.7 emoji表情符号"></a>3.7 emoji表情符号</h3><p>emoji表情使用:EMOJICODE:的格式，详细列表可见<br><a href="https://www.webpagefx.com/tools/emoji-cheat-sheet/">https://www.webpagefx.com/tools/emoji-cheat-sheet/</a></p>
<p>当然现在很多markdown工具或者网站都不支持。</p>
<p>下面列出几个平台的对比：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>工具或网站</th>
<th>是否支持emoji表情符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>简书</td>
<td>否</td>
</tr>
<tr>
<td>MarkDownPad</td>
<td>否（不知道付费版是否支持）</td>
</tr>
<tr>
<td>有道云笔记</td>
<td>否</td>
</tr>
<tr>
<td>zybuluo.com</td>
<td>否</td>
</tr>
<tr>
<td>github</td>
<td>是</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://imge.ablog168.cn/blog_img/20180802164508437" alt="这里写图片描述"></p>
<h2 id="4-高端用法"><a href="#4-高端用法" class="headerlink" title="4. 高端用法"></a>4. 高端用法</h2><h3 id="4-1-Latex数学公式"><a href="#4-1-Latex数学公式" class="headerlink" title="4.1 Latex数学公式"></a>4.1 Latex数学公式</h3><p><strong>使用LaTex数学公式</strong></p>
<p>1.行内公式：使用两个”$”符号引用公式:</p>
<p>$公式$</p>
<p>2.行间公式：使用两对”$$”符号引用公式：</p>
<script type="math/tex; mode=display">公式</script><p>输入$\sqrt{x\^{2}}$<br>显示结果是 x2−−√ x 2 </p>
<p>具体可以参考 markdown编辑器使用LaTex数学公式（<a href="https://link.jianshu.com/?t=http%3A%2F%2Fblog.csdn.net%2Ftestcs_dn%2Farticle%2Fdetails%2F44229085">https://link.jianshu.com/?t=http%3A%2F%2Fblog.csdn.net%2Ftestcs_dn%2Farticle%2Fdetails%2F44229085</a>）</p>
<p>latex数学符号详见：<a href="https://www.mohu.org/info/symbols/symbols.htm">常用数学符号的 LaTeX 表示方法</a></p>
<h3 id="4-2-流程图"><a href="#4-2-流程图" class="headerlink" title="4.2 流程图"></a>4.2 流程图</h3><p>这里简单介绍一下流程图的语法，仅作为了解，如下图所示：<br><img src="https://imge.ablog168.cn/blog_img/20180802165820199" alt="这里写图片描述"></p>
<h3 id="4-3-制作一份待办事宜——Todo-列表"><a href="#4-3-制作一份待办事宜——Todo-列表" class="headerlink" title="4.3 制作一份待办事宜——Todo 列表"></a>4.3 制作一份待办事宜——Todo 列表</h3><p><img src="https://imge.ablog168.cn/blog_img/20180802165859799" alt="这里写图片描述"></p>
<h3 id="4-4-绘制-序列图"><a href="#4-4-绘制-序列图" class="headerlink" title="4.4 绘制 序列图"></a>4.4 绘制 序列图</h3><p><img src="https://imge.ablog168.cn/blog_img/2018080216592352" alt="这里写图片描述"></p>
<h3 id="4-5-绘制-甘特图"><a href="#4-5-绘制-甘特图" class="headerlink" title="4.5 绘制 甘特图"></a>4.5 绘制 甘特图</h3><p><img src="https://imge.ablog168.cn/blog_img/20180802165941601" alt="这里写图片描述"></p>
<h2 id="5-Markdown工具"><a href="#5-Markdown工具" class="headerlink" title="5. Markdown工具 "></a>5. Markdown工具 </h2><p>1.markdownpad软件，就是利用markdown语言写笔记的。官网下载地址：<a href="http://markdownpad.com/">http://markdownpad.com/</a></p>
<p>软件安装之后的示意图如下图所示：<br><img src="https://imge.ablog168.cn/blog_img/20180802170021581" alt="这里写图片描述"></p>
<p>2.有道云笔记支持markdownpad语法。官方网址：<a href="http://note.youdao.com/">http://note.youdao.com/</a> 它有在线网页版以及PC端可以下载。当然有道云笔记也支持html语法。</p>
<p>网页版使用markdown示例图如下：<br><img src="https://imge.ablog168.cn/blog_img/20180802170102176" alt="这里写图片描述"></p>
<p>3.在线编辑markdown <a href="https://www.zybuluo.com/mdeditor">https://www.zybuluo.com/mdeditor</a></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>corn表达式动态配置</title>
    <url>/2023/06/04/cron%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>由于业务需求，需要提供一个能够让用户动态配置定时任务的入口，定时去同步数据</p>
</blockquote>
<p>1、简单的业务处理，直接使用@Scheduled注解就能开启定时任务，例如在方法上@Scheduled(cron = “0 0/1 * * * ?”)，书写cron表达式就能配置定时任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每分钟触发一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0/1 * * * ?&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execEveryDay</span><span class="params">()</span> &#123;</span><br><span class="line">    checkPlan();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、但是随着业务复杂化，使用注解目前是满足不了动态配置定时任务的，以下代码能够实现cron表达式的动态配置。</p>
<p>第一步，在启动类新增注解@EnableScheduling</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(testApplication .class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步，编写定时任务类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Lazy(false)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutPutTask</span> <span class="keyword">implements</span> <span class="title class_">SchedulingConfigurer</span> &#123;</span><br><span class="line">	<span class="comment">// 默认的cron表达式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">cron</span> <span class="operator">=</span> <span class="string">&quot;0 55 23 ? * *&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时任务的执行顺序：由上而下按顺序执行，当服务启动时或者定时任务时间到了，先执行业务逻辑，再设置定时任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> &#123;</span><br><span class="line">        taskRegistrar.addTriggerTask(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// addTriggerTask这一代码块用于当定时任务到了或者服务启动时，执行的业务逻辑</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 分布式锁，避免高并发同时执行方法</span></span><br><span class="line">                <span class="type">Boolean</span> <span class="variable">lockStatus</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(RedisKeyPrefix.RECORD_OUT_PUT, <span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">                <span class="keyword">if</span> (lockStatus == <span class="literal">null</span> || !lockStatus) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(<span class="string">&quot;产能计算定时任务&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                <span class="comment">// 这个是自己写的自定义方法</span></span><br><span class="line">                recordOutput();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            	<span class="comment">// 释放锁</span></span><br><span class="line">                redisTemplate.delete(RedisKeyPrefix.RECORD_OUT_PUT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, triggerContext -&gt; &#123;</span><br><span class="line">            <span class="comment">// 此代码块用于动态拿到cron表达式并设置定时任务，当定时任务时间到了，就会重新获取cron表达式，重新设置定时任务</span></span><br><span class="line">            cron = <span class="built_in">this</span>.getCronString();</span><br><span class="line">            CronTrigger trigger;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            	<span class="comment">// 一旦设置，立即生效</span></span><br><span class="line">                trigger = <span class="keyword">new</span> <span class="title class_">CronTrigger</span>(cron);</span><br><span class="line">                <span class="keyword">return</span> trigger.nextExecutionTime(triggerContext);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 如果格式有问题就按默认时间（时间为每天23点55分）</span></span><br><span class="line">                trigger = <span class="keyword">new</span> <span class="title class_">CronTrigger</span>(<span class="string">&quot;0 55 23 ? * *&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> trigger.nextExecutionTime(triggerContext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拿到cron表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getCronString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取时间（当前方法返回的时间格式为yyyy-MM-dd HH:mm:ss）</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">beginDate</span> <span class="operator">=</span> dictService.getDayOutputBeginTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="comment">// 截取分钟和小时</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">hour</span> <span class="operator">=</span> beginDate.toString().substring(<span class="number">11</span>, <span class="number">13</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">min</span> <span class="operator">=</span> beginDate.toString().substring(<span class="number">14</span>, <span class="number">16</span>);</span><br><span class="line">        <span class="comment">// 替换min,hour</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cron</span> <span class="operator">=</span> <span class="string">&quot;0 min hour ? * *&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> cron.replaceAll(<span class="string">&quot;min&quot;</span>, min).replaceAll(<span class="string">&quot;hour&quot;</span>, hour);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们只需要在页面上提供一个能够让用户配置定时任务的入口或者在数据库里配置cron表达式，就能实现动态配置。<br>如果面向的用户懂得cron表达式，也可以直接让用户配置cron表达式也是可以的，省的程序员进行额外的数据处理，只要配置正确，任何处理方式都行，例如：  </p>
<p>点击确定后，会更新数据库，<strong>当定时任务时间到了，就会触发定时任务机制，重新设置定时任务</strong>。</p>
]]></content>
      <categories>
        <category>corn</category>
      </categories>
      <tags>
        <tag>动态配置</tag>
      </tags>
  </entry>
  <entry>
    <title>idea常用插件</title>
    <url>/2023/06/04/idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<hr>
<p><br /></p>
<p>大家好，我是shine🌟，本篇将详细介绍IDEA快捷键及插件，让你学习和开发事半功倍。IDEA的牛逼，众所皆知，不论是用来学习还是开发都是首选的IDE，拉爆其他开发工具，让你爱上代码。很多隐藏的功能等待着你去发现🔍。</p>
<p><img src="https://imge.ablog168.cn/blog_img/e2280ec0e5904537909571e9c022c863.png" alt=""></p>
<h1 id="🌾快捷键（提高码字速度）"><a href="#🌾快捷键（提高码字速度）" class="headerlink" title="🌾快捷键（提高码字速度） "></a>🌾快捷键（提高码字速度） </h1><p>1.快速生成main方法:psvm +Tab或 main+Tab</p>
<p>2.快速生成System.out.prinltn():sout+Tab</p>
<p>3.删除一行:Ctrl+Y</p>
<p>4.切换java文件（前提是工程有多个.java文件）</p>
<p><img src="https://imge.ablog168.cn/blog_img/77ccd24e7cc04eccaebb76a50e643fc0.png" alt=""></p>
<p>Alt+右箭头 或 Alt+左箭头</p>
<p>5,复制选中行到下一行:Ctrl+D</p>
<p>6.撤销上一步操作:Ctrl+Z</p>
<p>7.取消撤销:Ctrl+Shift+Z</p>
<p>8.将选中的行合并成一行:Ctrl+shift+J</p>
<p>9.Ctrl+N:查找类文件</p>
<p><img src="https://imge.ablog168.cn/blog_img/ed46440cea2a41e6ad4c661125ca27d4.png" alt=""></p>
<p>10.显示文件结构:Ctrl+F12</p>
<p>11.显示当前文件夹路径:Ctrl+Alt+F12</p>
<p>12.显示当前类的继承层次:Ctrl+H</p>
<p>13.定位至下一个错误:F2</p>
<p>14.定位到前一个错误:Shift+F2</p>
<p>15.展开代码:Ctrl+=</p>
<p>16.折叠代码:Ctrl+-</p>
<p>17.选中所有：Ctrl+A</p>
<p>18.复制:Ctrl+C</p>
<p>19.剪切:Ctrl+X:</p>
<p>20.粘贴:Ctrl+V</p>
<p>21.定位到文件的某一行:Ctrl+G</p>
<p>22.选中的行多行注释:Ctrl+Shift+/</p>
<p>23.选中的行注释或取消注释:Ctrl+/</p>
<p>24.运行当前文件:Ctrl+Shift+F10</p>
<p>25.提示方法的参数:Ctrl+P</p>
<p>26.跳到文件尾:Ctrl+End</p>
<p>27.跳到文件头:Ctrl+Home</p>
<p>28.选中的行代码格式化:Ctrl+Alt+L</p>
<p>29.在当前文件进行文本查找:Ctrl+R</p>
<p>30.选中的行打断点或取消断点:Ctrl+F8</p>
<h1 id="🤡自定义快捷键"><a href="#🤡自定义快捷键" class="headerlink" title="🤡自定义快捷键 "></a>🤡自定义快捷键 </h1><p>File->Setting->KeyMap</p>
<p><img src="https://imge.ablog168.cn/blog_img/288d4ae203b64bebae8cb7259a74ddb9.png" alt=""></p>
<p><img src="https://imge.ablog168.cn/blog_img/4e76124ac8a947938aec63991af43d9f.png" alt=""></p>
<h1 id="🐢搜索插件方法及安装"><a href="#🐢搜索插件方法及安装" class="headerlink" title="🐢搜索插件方法及安装 "></a>🐢搜索插件方法及安装 </h1><p>File->Settings->Plugins</p>
<p><img src="https://imge.ablog168.cn/blog_img/15a6e87c42914e3ea6ce38c8bde5124d.png" alt=""></p>
<h1 id="✨快捷键提示（让你脱离鼠标）"><a href="#✨快捷键提示（让你脱离鼠标）" class="headerlink" title="✨快捷键提示（让你脱离鼠标） "></a>✨快捷键提示（让你脱离鼠标） </h1><p>安装插件：Key Promoter X</p>
<p>右侧列表展开，会展示你近期使用的功能进行，需要经常使用的我们就可以记住快捷键，提高效率。</p>
<p><img src="https://imge.ablog168.cn/blog_img/e5d6c2bdd17149359d8d4e4597c9673f.png" alt=""></p>
<h1 id="🍎设置背景"><a href="#🍎设置背景" class="headerlink" title="🍎设置背景 "></a>🍎设置背景 </h1><p>安装插件：Backgroud Image Plus +</p>
<p>设置壁纸：File->Settings->Appearance->BackgoundImage</p>
<p><img src="https://imge.ablog168.cn/blog_img/b84701e9f7d14b57b4cf8c3b5a8c73cd.png" alt=""></p>
<p>有对象的放自己对象，没对象的自己new一个呗。</p>
<p><img src="https://imge.ablog168.cn/blog_img/16042fb60c804cab98965fabacd9eaad.png" alt=""></p>
<p>设置随机切换壁纸</p>
<p>Settings->Background Image Plus</p>
<p><img src="https://imge.ablog168.cn/blog_img/a01d65a4694c43eb8786072ac8073610.png" alt=""></p>
<h1 id="📈翻译"><a href="#📈翻译" class="headerlink" title="📈翻译 "></a>📈翻译 </h1><p>安装插件：Translation</p>
<p><img src="https://imge.ablog168.cn/blog_img/ef627c38fc584b169643d776048a79d5.png" alt=""></p>
<p><img src="https://imge.ablog168.cn/blog_img/401d2106dc6b48429f7607dbf92a9869.png" alt=""></p>
<p>是不是非常的方便！！！</p>
<h1 id="🍓简体中文"><a href="#🍓简体中文" class="headerlink" title="🍓简体中文 "></a>🍓简体中文 </h1><p>安装插件：Chinese (Simplified)</p>
<p><img src="https://imge.ablog168.cn/blog_img/f6770fee1e9d412bbdcbcb468a0ae804.png" alt=""></p>
<h1 id="🌈七彩括号"><a href="#🌈七彩括号" class="headerlink" title="🌈七彩括号 "></a>🌈七彩括号 </h1><p>安装插件：Rainbow Brackets</p>
<p>面对这样的一个表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> (<span class="literal">true</span>?<span class="literal">false</span>:(<span class="literal">false</span>?<span class="literal">true</span>:(<span class="literal">false</span> == <span class="literal">true</span>?<span class="literal">false</span>:<span class="literal">true</span>)))</span><br></pre></td></tr></table></figure>
<p><img src="https://imge.ablog168.cn/blog_img/612eaafcfc98414782db6dfade16dd21.png" alt=""></p>
<p><img src="https://imge.ablog168.cn/blog_img/db0ac18407c44f8ebbf6690b93a79bb6.png" alt=""></p>
<p>轻轻松松阅读！！！</p>
<p><img src="https://imge.ablog168.cn/blog_img/401b76defb1647379b7ab06bed4c3958.png" alt=""></p>
<h1 id="🤙小地图"><a href="#🤙小地图" class="headerlink" title="🤙小地图 "></a>🤙小地图 </h1><p>Code Glance</p>
<p><img src="https://imge.ablog168.cn/blog_img/ccb24b70e6a04a529269560a4e559c0f.png" alt=""></p>
<h1 id="🎯代码统计"><a href="#🎯代码统计" class="headerlink" title="🎯代码统计 "></a>🎯代码统计 </h1><p>安装插件：Statistic</p>
<p><img src="https://imge.ablog168.cn/blog_img/2f1b126f8c5247bab6bab46c3eb464f3.png" alt=""></p>
<p><img src="https://img-blog.csdnimg.cn/c31649fa2a6c45a48d288312afb095a7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ICAIOaYnw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p>
<h1 id="💎生成方法时序图"><a href="#💎生成方法时序图" class="headerlink" title="💎生成方法时序图 "></a>💎生成方法时序图 </h1><p>安装插件：SequenceDiagram</p>
<p><img src="https://imge.ablog168.cn/blog_img/6ac4b03d84bc4407b210d0d6394b309c.png" alt=""></p>
<h1 id="🥝代码补全"><a href="#🥝代码补全" class="headerlink" title="🥝代码补全 "></a>🥝代码补全 </h1><p>安装插件：Codota AI</p>
<p>IDEA自带的补全代码已经很强大，AI补全代码更加强大，越用越好用。</p>
<p><img src="https://imge.ablog168.cn/blog_img/c163d73b006a479aa5a4420d5ecac98c.png" alt=""></p>
<h1 id="🖐防沉迷"><a href="#🖐防沉迷" class="headerlink" title="🖐防沉迷 "></a>🖐防沉迷 </h1><p>安装插件：StopCoding</p>
<p>如果你经常沉迷于写代码，那么试试这个插件，设置工作时间和休息时间，别忘了起来喝杯水，走动几步，爱护身体，从你我做起💖。</p>
<p><img src="https://imge.ablog168.cn/blog_img/033ecdc326d24f5c8668b6d5cfd69a12.png" alt=""></p>
<p>大家可以试试看，有惊喜🎉。</p>
<h1 id="🏓LeetCode刷题"><a href="#🏓LeetCode刷题" class="headerlink" title="🏓LeetCode刷题 "></a>🏓LeetCode刷题 </h1><p>安装插件：LeetCode Editor</p>
<p>按提示登录即可。</p>
<p><img src="https://imge.ablog168.cn/blog_img/fc154247b619409aa3189f9c949b4b13.png" alt=""></p>
<h1 id="🎽快速生成文档注释"><a href="#🎽快速生成文档注释" class="headerlink" title="🎽快速生成文档注释 "></a>🎽快速生成文档注释 </h1><p>安装插件：JavaDoc</p>
<p>Windows上可以通过Alt+Insert，Mac可通过Ctrl+Enter。</p>
<p><img src="https://imge.ablog168.cn/blog_img/c5e97b598ae545ccb3def2828bb09384.png" alt=""></p>
<h1 id="🐳扫描代码问题"><a href="#🐳扫描代码问题" class="headerlink" title="🐳扫描代码问题 "></a>🐳扫描代码问题 </h1><p>安装插件：SonarLint</p>
<p>帮助你检查代码的问题，例如性能，安全、重复等问题。新手必备。</p>
<p><img src="https://imge.ablog168.cn/blog_img/486e0ce6f1cb4c4fac2d7be3634ee1da.png" alt=""></p>
<h1 id="🧣阿里巴巴编码规范检查工具"><a href="#🧣阿里巴巴编码规范检查工具" class="headerlink" title="🧣阿里巴巴编码规范检查工具"></a>🧣阿里巴巴编码规范检查工具</h1><p>安装插件 ：Alibaba Java Coding Guidelines</p>
<p><img src="https://imge.ablog168.cn/blog_img/69b1301e8a5b456395e5bfa62227cbd5.png" alt=""></p>
<h1 id="🍋日志信息着色"><a href="#🍋日志信息着色" class="headerlink" title="🍋日志信息着色 "></a>🍋日志信息着色 </h1><p>安装插件：Grep Console</p>
<p><img src="https://imge.ablog168.cn/blog_img/8f93bd0782bf45d6b40e63505e254503.png" alt=""></p>
]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>java生成二维码</title>
    <url>/2023/06/04/java%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/</url>
    <content><![CDATA[<p>一、介绍：生成二维码有很多种方法，比如微信公众号的生成二维码，但是这个二维码只能用微信扫描且会（可以带参数）自动跳转到微信的公众号页面，不支持跳转到其他网页。这里说的二维码是扫描（微信、QQ、浏览器等扫描）可以跳转到指定网址的二维码。二维码最早是由日本一家公司开发的，并且该二维码主要有两种方式：一种是QRCode 插件产生于日本 ；另一种是ZXing 插件由谷歌开发的。</p>
<p>二、ZXing插件开发：</p>
<p>1、引入依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- 生成二维码，spring boot 的maven项目 导入响应jar包 --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javase&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2、生成的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.zxing.BarcodeFormat;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.EncodeHintType;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.MultiFormatWriter;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.WriterException;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.common.BitMatrix;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需求说明：卖家在一个实体产品上贴一个二维码，买家收货后，微信扫码获取产品的详细信息</span></span><br><span class="line"><span class="comment"> * 实现说明：卖家在出货前，把服务器上的产品详情页的链接地址（含有ID）生成二维码，买家收货后微信扫码，跳转到产品信息页即可查看</span></span><br><span class="line"><span class="comment"> * 需要jar:zxing-code-2.3.jar,下载地址http://download.csdn.net/download/sanfye/8704583</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 加内特</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BLACK</span> <span class="operator">=</span> <span class="number">0xFF000000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WHITE</span> <span class="operator">=</span> <span class="number">0xFFFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> generateCode(<span class="string">&quot;518&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;成功生成二维码&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (WriterException | IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;生成二维码失败&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">generateCode</span><span class="params">(String productId)</span> <span class="keyword">throws</span> WriterException, IOException &#123;</span><br><span class="line">        <span class="comment">// 这里是URL，扫描之后就跳转到这个界面</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;https://www.baidu.com/?uudi=&quot;</span> + productId;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;E:/&quot;</span>; <span class="comment">// 图片生成的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">400</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">400</span>;</span><br><span class="line">        <span class="comment">// 二维码图片格式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> <span class="string">&quot;jpg&quot;</span>;</span><br><span class="line">        <span class="comment">// 设置编码，防止中文乱码</span></span><br><span class="line">        Hashtable&lt;EncodeHintType, Object&gt; ht = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;EncodeHintType, Object&gt;();</span><br><span class="line">        ht.put(EncodeHintType.CHARACTER_SET, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置二维码参数(编码内容，编码类型，图片宽度，图片高度,格式)</span></span><br><span class="line">        <span class="type">BitMatrix</span> <span class="variable">bitMatrix</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultiFormatWriter</span>().encode(text, BarcodeFormat.QR_CODE, width, height, ht);</span><br><span class="line">        <span class="comment">// 生成二维码(定义二维码输出服务器路径)</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">outputFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">        <span class="keyword">if</span> (!outputFile.exists()) &#123;</span><br><span class="line">            <span class="comment">// 创建文件夹</span></span><br><span class="line">            outputFile.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">b_width</span> <span class="operator">=</span> bitMatrix.getWidth();</span><br><span class="line">        <span class="type">int</span> <span class="variable">b_height</span> <span class="operator">=</span> bitMatrix.getHeight();</span><br><span class="line">        <span class="comment">// 建立图像缓冲器</span></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedImage</span>(b_width, b_height, BufferedImage.TYPE_3BYTE_BGR);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; b_width; x++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; b_height; y++) &#123;</span><br><span class="line">                image.setRGB(x, y, bitMatrix.get(x, y) ? BLACK : WHITE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成二维码</span></span><br><span class="line">        ImageIO.write(image, format, <span class="keyword">new</span> <span class="title class_">File</span>(path + <span class="string">&quot;/code.&quot;</span> + format));</span><br><span class="line">        <span class="comment">// 二维码的名称</span></span><br><span class="line">        <span class="comment">// code.jpg</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>二维码</category>
      </categories>
      <tags>
        <tag>二维码</tag>
        <tag>QRcode</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-plus连表查询</title>
    <url>/2023/06/04/mybatis-plus%E8%BF%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h1 id="mybatis-plus-join"><a href="#mybatis-plus-join" class="headerlink" title="mybatis-plus-join "></a>mybatis-plus-join </h1><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li><p>在项目中添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.yulichang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-join<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者clone代码到本地,执行mvn install,再引入以上依赖</p>
<p>注意: mybatis plus version >= 3.4.0</p>
</li>
</ol>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>mapper继承MPJBaseMapper (必选)</li>
<li>service继承MPJBaseService (可选)</li>
<li>serviceImpl继承MPJBaseServiceImpl (可选)</li>
</ul>
<h2 id="核心类-MPJLambdaWrapper和MPJQueryWrapper"><a href="#核心类-MPJLambdaWrapper和MPJQueryWrapper" class="headerlink" title="核心类 MPJLambdaWrapper和MPJQueryWrapper"></a>核心类 MPJLambdaWrapper和MPJQueryWrapper</h2><h3 id="MPJLambdaWrapper用法"><a href="#MPJLambdaWrapper用法" class="headerlink" title="MPJLambdaWrapper用法"></a>MPJLambdaWrapper用法</h3><h4 id="MPJLambdaWrapper示例"><a href="#MPJLambdaWrapper示例" class="headerlink" title="MPJLambdaWrapper示例"></a>MPJLambdaWrapper示例</h4><h4 id="简单的3表查询"><a href="#简单的3表查询" class="headerlink" title="简单的3表查询"></a>简单的3表查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testJoin</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;UserDTO&gt; list = userMapper.selectJoinList(UserDTO.class,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MPJLambdaWrapper</span>&lt;UserDO&gt;()</span><br><span class="line">                        .selectAll(UserDO.class)</span><br><span class="line">                        .select(UserAddressDO::getTel)</span><br><span class="line">                        .selectAs(UserAddressDO::getAddress, UserDTO::getUserAddress)</span><br><span class="line">                        .select(AreaDO::getProvince, AreaDO::getCity)</span><br><span class="line">                        .leftJoin(UserAddressDO.class, UserAddressDO::getUserId, UserDO::getId)</span><br><span class="line">                        .leftJoin(AreaDO.class, AreaDO::getId, UserAddressDO::getAreaId)</span><br><span class="line">                        .eq(UserDO::getId, <span class="number">1</span>)</span><br><span class="line">                        .like(UserAddressDO::getTel, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">                        .gt(UserDO::getId, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    t.id,</span><br><span class="line">    t.name,</span><br><span class="line">    t.sex,</span><br><span class="line">    t.head_img,</span><br><span class="line">    t1.tel,</span><br><span class="line">    t1.address <span class="keyword">AS</span> userAddress,</span><br><span class="line">    t2.province,</span><br><span class="line">    t2.city </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    <span class="keyword">user</span> t </span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> user_address t1 <span class="keyword">ON</span> t1.user_id <span class="operator">=</span> t.id </span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> area t2 <span class="keyword">ON</span> t2.id <span class="operator">=</span> t1.area_id </span><br><span class="line"><span class="keyword">WHERE</span> (</span><br><span class="line">    t.id <span class="operator">=</span> ? </span><br><span class="line">    <span class="keyword">AND</span> t1.tel <span class="keyword">LIKE</span> ? </span><br><span class="line">    <span class="keyword">AND</span> t.id <span class="operator">&gt;</span> ?)</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ul>
<li>UserDTO.class 查询结果返回类(resultType)</li>
<li>selectAll() 查询指定实体类的全部字段</li>
<li>select() 查询指定的字段,支持可变参数,同一个select只能查询相同表的字段<br>故将UserAddressDO和AreaDO分开为两个select()</li>
<li>selectAs() 字段别名查询,用于数据库字段与业务实体类属性名不一致时使用</li>
<li>leftJoin() 参数说明<br>第一个参数: 参与连表的实体类class<br>第二个参数: 连表的ON字段,这个属性必须是第一个参数实体类的属性<br>第三个参数: 参与连表的ON的另一个实体类属性</li>
<li>默认主表别名是t,其他的表别名以先后调用的顺序使用t1,t2,t3…</li>
<li>条件查询,可以查询主表以及参与连接的所有表的字段,全部调用mp原生的方法,正常使用没有sql注入风险</li>
</ul>
<h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testJoin</span><span class="params">()</span> &#123;</span><br><span class="line">        IPage&lt;UserDTO&gt; iPage = userMapper.selectJoinPage(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">2</span>, <span class="number">10</span>), UserDTO.class,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MPJLambdaWrapper</span>&lt;UserDO&gt;()</span><br><span class="line">                        .selectAll(UserDO.class)</span><br><span class="line">                        .select(UserAddressDO::getTel)</span><br><span class="line">                        .selectAs(UserAddressDO::getAddress, UserDTO::getUserAddress)</span><br><span class="line">                        .select(AreaDO::getProvince, AreaDO::getCity)</span><br><span class="line">                        .leftJoin(UserAddressDO.class, UserAddressDO::getUserId, UserDO::getId)</span><br><span class="line">                        .leftJoin(AreaDO.class, AreaDO::getId, UserAddressDO::getAreaId));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    t.id,</span><br><span class="line">    t.name,</span><br><span class="line">    t.sex,</span><br><span class="line">    t.head_img,</span><br><span class="line">    t1.tel,</span><br><span class="line">    t1.address <span class="keyword">AS</span> userAddress,</span><br><span class="line">    t2.province,</span><br><span class="line">    t2.city</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    <span class="keyword">user</span> t</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> user_address t1 <span class="keyword">ON</span> t1.user_id <span class="operator">=</span> t.id</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> area t2 <span class="keyword">ON</span> t2.id <span class="operator">=</span> t1.area_id</span><br><span class="line">LIMIT ?,?</span><br></pre></td></tr></table></figure>
<h3 id="MPJQueryWrapper"><a href="#MPJQueryWrapper" class="headerlink" title="MPJQueryWrapper"></a>MPJQueryWrapper</h3><h4 id="简单的3表查询-1"><a href="#简单的3表查询-1" class="headerlink" title="简单的3表查询"></a>简单的3表查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testJoin</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;UserDTO&gt; list = userMapper.selectJoinList(UserDTO.class,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MPJQueryWrapper</span>&lt;UserDO&gt;()</span><br><span class="line">                        .selectAll(UserDO.class)</span><br><span class="line">                        .select(<span class="string">&quot;addr.tel&quot;</span>, <span class="string">&quot;addr.address&quot;</span>, <span class="string">&quot;a.province&quot;</span>)</span><br><span class="line">                        .leftJoin(<span class="string">&quot;user_address addr on t.id = addr.user_id&quot;</span>)</span><br><span class="line">                        .rightJoin(<span class="string">&quot;area a on addr.area_id = a.id&quot;</span>)</span><br><span class="line">                        .like(<span class="string">&quot;addr.tel&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">                        .le(<span class="string">&quot;a.province&quot;</span>, <span class="string">&quot;1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    t.id,</span><br><span class="line">    t.name,</span><br><span class="line">    t.sex,</span><br><span class="line">    t.head_img,</span><br><span class="line">    addr.tel,</span><br><span class="line">    addr.address,</span><br><span class="line">    a.province</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    <span class="keyword">user</span> t</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> user_address addr <span class="keyword">on</span> t.id <span class="operator">=</span> addr.user_id</span><br><span class="line">    <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> area a <span class="keyword">on</span> addr.area_id <span class="operator">=</span> a.id</span><br><span class="line"><span class="keyword">WHERE</span> (</span><br><span class="line">    addr.tel <span class="keyword">LIKE</span> ?</span><br><span class="line">    <span class="keyword">AND</span> a.province <span class="operator">&lt;=</span> ?)</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ul>
<li>UserDTO.class 查询结果类(resultType)</li>
<li>selectAll(UserDO.class) 查询主表全部字段(主表实体类)默认主表别名 “t”</li>
<li>select() mp的select策略是覆盖,以最后一次为准,这里的策略是追加,可以一直select<br>主表字段可以用lambda,会自动添加表别名,主表别名默认是 t ,非主表字段必须带别名查询</li>
<li>leftJoin() rightJoin() innerJoin() 传sql片段 格式 (表 + 别名 + 关联条件)</li>
<li>条件查询,可以查询主表以及参与连接的所有表的字段,全部调用mp原生的方法,正常使用没有sql注入风险</li>
</ul>
<h4 id="分页查询-1"><a href="#分页查询-1" class="headerlink" title="分页查询"></a>分页查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testJoin</span><span class="params">()</span> &#123;</span><br><span class="line">        IPage&lt;UserDTO&gt; page = userMapper.selectJoinPage(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">10</span>), UserDTO.class,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MPJQueryWrapper</span>&lt;UserDO&gt;()</span><br><span class="line">                        .selectAll(UserDO.class)</span><br><span class="line">                        .select(<span class="string">&quot;addr.tel&quot;</span>, <span class="string">&quot;addr.address&quot;</span>)</span><br><span class="line">                        .select(<span class="string">&quot;a.province&quot;</span>)</span><br><span class="line">                        .leftJoin(<span class="string">&quot;user_address addr on t.id = addr.user_id&quot;</span>)</span><br><span class="line">                        .rightJoin(<span class="string">&quot;area a on addr.area_id = a.id&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    t.id,</span><br><span class="line">    t.name,</span><br><span class="line">    t.sex,</span><br><span class="line">    t.head_img,</span><br><span class="line">    addr.tel,</span><br><span class="line">    addr.address,</span><br><span class="line">    a.province</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    <span class="keyword">user</span> t</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> user_address addr <span class="keyword">on</span> t.id <span class="operator">=</span> addr.user_id</span><br><span class="line">    <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> area a <span class="keyword">on</span> addr.area_id <span class="operator">=</span> a.id </span><br><span class="line">LIMIT ?,?</span><br></pre></td></tr></table></figure>
<h4 id="还可以这么操作-但不建议"><a href="#还可以这么操作-但不建议" class="headerlink" title="还可以这么操作,但不建议"></a>还可以这么操作,但不建议</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testJoin</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;UserDTO&gt; list = userMapper.selectJoinList(UserDTO.class,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MPJQueryWrapper</span>&lt;UserDO&gt;()</span><br><span class="line">                        .selectAll(UserDO.class)</span><br><span class="line">                        .select(<span class="string">&quot;addr.tel&quot;</span>, <span class="string">&quot;addr.address&quot;</span>)</span><br><span class="line">                        <span class="comment">//行列转换</span></span><br><span class="line">                        .select(<span class="string">&quot;CASE t.sex WHEN &#x27;男&#x27; THEN &#x27;1&#x27; ELSE &#x27;0&#x27; END AS sex&quot;</span>)</span><br><span class="line">                        <span class="comment">//求和函数</span></span><br><span class="line">                        .select(<span class="string">&quot;sum(a.province) AS province&quot;</span>)</span><br><span class="line">                        <span class="comment">//自定义数据集</span></span><br><span class="line">                        .leftJoin(<span class="string">&quot;(select * from user_address) addr on t.id = addr.user_id&quot;</span>)</span><br><span class="line">                        .rightJoin(<span class="string">&quot;area a on addr.area_id = a.id&quot;</span>)</span><br><span class="line">                        .like(<span class="string">&quot;addr.tel&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">                        .le(<span class="string">&quot;a.province&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">                        .orderByDesc(<span class="string">&quot;addr.id&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    t.id,</span><br><span class="line">    t.name,</span><br><span class="line">    t.sex,</span><br><span class="line">    t.head_img,</span><br><span class="line">    addr.tel,</span><br><span class="line">    addr.address,</span><br><span class="line">    <span class="keyword">CASE</span> t.sex <span class="keyword">WHEN</span> <span class="string">&#x27;男&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">ELSE</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">END</span> <span class="keyword">AS</span> sex,</span><br><span class="line">    <span class="built_in">sum</span>(a.province) <span class="keyword">AS</span> province</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    <span class="keyword">user</span> t</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_address) addr <span class="keyword">on</span> t.id <span class="operator">=</span> addr.user_id</span><br><span class="line">    <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> area a <span class="keyword">on</span> addr.area_id <span class="operator">=</span> a.id</span><br><span class="line"><span class="keyword">WHERE</span> (</span><br><span class="line">    addr.tel <span class="keyword">LIKE</span> ?</span><br><span class="line">    <span class="keyword">AND</span> a.province <span class="operator">&lt;=</span> ?)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    addr.id <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>服务占用cpu过高排查</title>
    <url>/2023/06/04/%E6%9C%8D%E5%8A%A1%E5%8D%A0%E7%94%A8cpu%E8%BF%87%E9%AB%98%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<blockquote>
<p><strong>先用top命令找出CPU占比最高的</strong></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>
<p><img src="https://imge.ablog168.cn/blog_img/20201230214810341.png" alt="在这里插入图片描述"><br>CPU占用最高的是java进程，它的 <code>进程ID：3362</code></p>
<blockquote>
<p><strong>ps -ef 或者 jps 进一步定位，得知是怎样的程序</strong></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@192 ~] ps -ef | grep 3362 | grep -v grep</span><br><span class="line">root       3362   2340 42 21:47 pts/0    00:02:30 java HelloWorldApp</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>定位到具体的线程或者代码</strong></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -mp 3362 -o THREAD,tid,time</span><br></pre></td></tr></table></figure>
<p><img src="https://imge.ablog168.cn/blog_img/20201230220404953.png" alt="在这里插入图片描述"></p>
<p>如图所示，引起CPU过高的 <code>线程ID：3363</code></p>
<blockquote>
<p><strong>将线程ID转换为16进制格式（英文小写）</strong></p>
</blockquote>
<p>3365 转换为16进制结果：d23<br><img src="https://imge.ablog168.cn/blog_img/20201230220804137.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>jstack</p>
</blockquote>
<p>格式：jstack 进程ID | grep tid（16进制小写） -A60</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstack 3362 | grep d23 -A60</span><br></pre></td></tr></table></figure>
<p><img src="https://imge.ablog168.cn/blog_img/20201230221316830.png" alt="在这里插入图片描述"><br>这样，就能找出具体的异常代码位置</p>
]]></content>
      <categories>
        <category>性能提升</category>
      </categories>
      <tags>
        <tag>cpu飙高</tag>
      </tags>
  </entry>
  <entry>
    <title>获取客户端真实ip</title>
    <url>/2023/06/04/%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9C%9F%E5%AE%9Eip/</url>
    <content><![CDATA[<p><code>现在都流行显示 ip 归属地，那么我先来获取客户端的真实 ip 地址以及 mac 地址，上代码</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.NetworkInterface;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 常用获取客户端信息的工具</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetworkUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取ip地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getIpAddress</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;x-forwarded-for&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ip == <span class="literal">null</span> || ip.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(<span class="string">&quot;Proxy-Client-IP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ip == <span class="literal">null</span> || ip.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(<span class="string">&quot;WL-Proxy-Client-IP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ip == <span class="literal">null</span> || ip.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(<span class="string">&quot;HTTP_CLIENT_IP&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ip == <span class="literal">null</span> || ip.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(<span class="string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ip == <span class="literal">null</span> || ip.length() == <span class="number">0</span> || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getRemoteAddr();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 本机访问</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;localhost&quot;</span>.equalsIgnoreCase(ip) || <span class="string">&quot;127.0.0.1&quot;</span>.equalsIgnoreCase(ip) || <span class="string">&quot;0:0:0:0:0:0:0:1&quot;</span>.equalsIgnoreCase(ip))&#123;</span><br><span class="line">            <span class="comment">// 根据网卡取本机配置的IP</span></span><br><span class="line">            InetAddress inet;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inet = InetAddress.getLocalHost();</span><br><span class="line">                ip = inet.getHostAddress();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于通过多个代理的情况，第一个IP为客户端真实IP,多个IP按照&#x27;,&#x27;分割</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != ip &amp;&amp; ip.length() &gt; <span class="number">15</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ip.indexOf(<span class="string">&quot;,&quot;</span>) &gt; <span class="number">15</span>) &#123;</span><br><span class="line">                ip = ip.substring(<span class="number">0</span>, ip.indexOf(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取mac地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMacAddress</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 取mac地址</span></span><br><span class="line">        <span class="type">byte</span>[] macAddressBytes = NetworkInterface.getByInetAddress(InetAddress.getLocalHost()).getHardwareAddress();</span><br><span class="line">        <span class="comment">// 下面代码是把mac地址拼装成String</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; macAddressBytes.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// mac[i] &amp; 0xFF 是为了把byte转化为正整数</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Integer.toHexString(macAddressBytes[i] &amp; <span class="number">0xFF</span>);</span><br><span class="line">            sb.append(s.length() == <span class="number">1</span> ? <span class="number">0</span> + s : s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString().trim().toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，ip 获取到了至于查询 ip 归属地嘛<br><a href="https://github.com/lionsoul2014/ip2region">Ip2region</a></p>
]]></content>
      <categories>
        <category>IP地址</category>
      </categories>
      <tags>
        <tag>ip地址</tag>
        <tag>mac地址</tag>
      </tags>
  </entry>
  <entry>
    <title>docker十五问</title>
    <url>/2023/06/04/docker%E5%8D%81%E4%BA%94%E9%97%AE/</url>
    <content><![CDATA[<p><br /></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言 "></a>前言 </h1><p>本文总结了Docker常见的问题和坑，采用问答的形式，分享给大家</p>
<hr>
<h2 id="⛳️-1-什么是Docker？"><a href="#⛳️-1-什么是Docker？" class="headerlink" title="⛳️ 1.什么是Docker？"></a>⛳️ 1.什么是Docker？</h2><p><img src="https://imge.ablog168.cn/blog_img/d1d64446b6c24272af450ba6ad20ee87.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>📖 Docker 是一个开源的应用容器引擎，基于go 语言开发并遵循了apache2.0 协议开源<br>📖 Docker 是在Linux 容器里运行应用的开源工具，是一种轻量级的”虚拟机”<br>📖 Docker 的容器技术可以在一台主机上轻松为任何应用创建一个轻量级的，可移植的，自给自足的容器<br>也可以这样形象的比喻：<br>Docker 的Logo设计为蓝色鲸鱼，拖着许多集装箱，鲸鱼可以看作为宿主机，集装箱可以理解为相互隔离的容器，每个集装箱中都包含自己的应用程序。</p>
</blockquote>
<h2 id="⛳️-2-Docker的应用场景有哪些？"><a href="#⛳️-2-Docker的应用场景有哪些？" class="headerlink" title="⛳️ 2.Docker的应用场景有哪些？"></a>⛳️ 2.Docker的应用场景有哪些？</h2><blockquote>
<p>Web 应用的自动化打包和发布。<br>自动化测试和持续集成、发布。<br>在服务型环境中部署和调整数据库或其他的后台应用。<br>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</p>
</blockquote>
<p>📢📢📢 在这里我重点介绍下Docker作为内部开发环境的场景</p>
<blockquote>
<p>在容器技术出现之前，公司往往是通过为每个开发人员提供一台或者多台虚拟机来充当开发测试环境。<br>开发测试环境一般负载较低，大量的系统资源都被浪费在虚拟机本身的进程上了。<br>Docker容器没有任何CPU和内存上的额外开销，很适合用来提供公司内部的开发测试环境。<br>而且由于docker镜像可以很方便的在公司内部分享，这对开发环境的规范性也有极大的帮助。<br>如果要把容器作为开发机使用，需要解决的是远程登录容器和容器内进程管理问题。<br>虽然docker的初衷是为”微服务”架构设计的，但根据我们的实际使用经验，<br>在docker内运行多个程序，甚至sshd或者upstart也是可行的。</p>
</blockquote>
<h2 id="⛳️-3-Docker的优点有哪些？"><a href="#⛳️-3-Docker的优点有哪些？" class="headerlink" title="⛳️ 3.Docker的优点有哪些？"></a>⛳️ 3.Docker的优点有哪些？</h2><p>容器化越来越受欢迎，Docker的容器有点总结如下：<br>📖 灵活：即使是最复杂的应用也可以集装箱化。<br>📖 轻量级：容器利用并共享主机内核。<br>📖 可互换：可以即时部署更新和升级。<br>📖 便携式：可以在本地构建，部署到云，并在任何地方运行。<br>📖 可扩展：可以增加并白动分发容器副本。<br>📖 可堆叠：可以垂直和即时堆叠服务。</p>
<p><img src="https://imge.ablog168.cn/blog_img/b694f003ed8149a19c1c5b1f7ca94b84.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p>
</blockquote>
<h2 id="⛳️-4-Docker与虚拟机的区别是什么？"><a href="#⛳️-4-Docker与虚拟机的区别是什么？" class="headerlink" title="⛳️ 4.Docker与虚拟机的区别是什么？"></a>⛳️ 4.Docker与虚拟机的区别是什么？</h2><blockquote>
<p>虚拟机通过添加Hypervisor层（虚拟化中间层），虚拟出网卡、内存、CPU等虚拟硬件，再在其上建立虚拟机，每个虚拟机都有自己的系统内核。而Docker容器则是通过隔离（namesapce）的方式，将文件系统、进程、设备、网络等资源进行隔离，再对权限、CPU资源等进行控制（cgroup），最终让容器之间互不影响，容器无法影响宿主机。<br>与虚拟机相比，容器资源损耗要少。同样的宿主机下，能够建立容器的数量要比虚拟机多<br>但是，虚拟机的安全性要比容器稍好，而docker容器与宿主机共享内核、文件系统等资源，更有可能对其他容器、宿主机产生影响。</p>
</blockquote>
<p><img src="https://imge.ablog168.cn/blog_img/a773db41129944ecab4f43b045311410.png" alt="在这里插入图片描述"></p>
<h2 id="⛳️-5-Docker的三大核心是什么？"><a href="#⛳️-5-Docker的三大核心是什么？" class="headerlink" title="⛳️ 5.Docker的三大核心是什么？"></a>⛳️ 5.Docker的三大核心是什么？</h2><p>📢📢📢 镜像</p>
<blockquote>
<p>Docker的镜像是创建容器的基础，类似虚拟机的快照，可以理解为一个面向Docker容器引擎的只读模板。<br>通过镜像启动一个容器，一个镜像是一个可执行的包，其中包括运行应用程序所需要的所有内容包含代码，运行时间，库、环境变量、和配置文件。<br>Docker镜像也是一个压缩包，只是这个压缩包不只是可执行文件，环境部署脚本，它还包含了完整的操作系统。因为大部分的镜像都是基于某个操作系统来构建，所以很轻松的就可以构建本地和远端一样的环境，这也是Docker镜像的精髓。</p>
</blockquote>
<p>📢📢📢 容器</p>
<blockquote>
<p>Docker的容器是从镜像创建的运行实例，它可以被启动、停止和删除。所创建的每一个容器都是相互隔离、互不可见，以保证平台的安全性。可以把容器看做是一个简易版的linux环境（包括root用户权限、镜像空间、用户空间和网络空间等）和运行在其中的应用程序。</p>
</blockquote>
<p>📢📢📢 仓库</p>
<blockquote>
<p>仓库注册服务器上往往存放着多个仓库，每个仓库中包含了多个镜像，每个镜像有不同标签（tag）。<br>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。<br>最大的公开仓库是 Docker Hub:<a href="https://hub.docker.com，存放了数量庞大的镜像供用户下载。">https://hub.docker.com，存放了数量庞大的镜像供用户下载。</a><br>国内的公开仓库包括阿里云 、网易云等。</p>
</blockquote>
<h2 id="⛳️-6-如何快速安装Docker？"><a href="#⛳️-6-如何快速安装Docker？" class="headerlink" title="⛳️ 6.如何快速安装Docker？"></a>⛳️ 6.如何快速安装Docker？</h2><blockquote>
<p>执行以下安装命令去安装依赖包<br>yum install -y yum-utils device-mapper-persistent-data lvm2<br>sudo yum-config-manager<br>—add-repo<br><a href="https://download.docker.com/linux/centos/docker-ce.repo">https://download.docker.com/linux/centos/docker-ce.repo</a><br>[root@centos7 ~] yum -y install docker-ce docker-ce-cli containerd.io<br>[root@centos7 ~]# docker ps —查看docker</p>
</blockquote>
<p><img src="https://imge.ablog168.cn/blog_img/6a2b5382e1a44ed2b39b49c57d7a840d.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>[root@centos7 ~]# systemctl enable docker<br>[root@centos7 ~]# systemctl start docker<br>[root@centos7 ~]# systemctl status docker<br>[root@centos7 ~]# docker ps —查看容器<br>[root@centos7 ~]# docker version —查看版本<br>[root@centos7 ~]# docker info —查看版本</p>
</blockquote>
<h2 id="⛳️-7-如何修改Docker的存储位置？"><a href="#⛳️-7-如何修改Docker的存储位置？" class="headerlink" title="⛳️ 7.如何修改Docker的存储位置？"></a>⛳️ 7.如何修改Docker的存储位置？</h2><blockquote>
<p>默认情况下 Docker的存放位置为：/var/lib/docker<br>可以通过命令查看具体位置：docker info | grep “Docker Root Dir”</p>
</blockquote>
<p>📢📢📢 修改到其它目录</p>
<blockquote>
<p>首先停掉 Docker 服务：<br>systemctl stop docker<br>然后移动整个/var/lib/docker 目录到目的路径<br>mkdir -p /root/data/docker<br>mv /var/lib/docker /root/data/docker<br>ln -s /root/data/docker /var/lib/docker —快捷方式</p>
</blockquote>
<h2 id="⛳️-8-Docker镜像常用管理有哪些？"><a href="#⛳️-8-Docker镜像常用管理有哪些？" class="headerlink" title="⛳️ 8.Docker镜像常用管理有哪些？"></a>⛳️ 8.Docker镜像常用管理有哪些？</h2><blockquote>
<p>📢📢📢 快速检索镜像<br>格式： docker search 关键字<br>📢📢📢 获取镜像<br>格式： docker   pull   仓库名称[:标签]<br>如果下载镜像时不指定标签，则默认会下载仓库中最新版本的镜像，即选择标签为 latest 标签<br>📢📢📢 查看镜像信息<br>镜像下载后默认存放在 /var/lib/docker<br>📖 REPOSITORY: 镜像所属仓库<br>📖 TAG: 镜像的标签信息，标记同一个仓库中的不同镜像<br>📖 IMAGE ID ：镜像的唯一ID号，唯一标识一个镜像<br>📖 CREATED: 镜像创建时间<br>📖 SIZE: 镜像大小</p>
</blockquote>
<p><img src="https://imge.ablog168.cn/blog_img/eda87841fa714aa2997cc9a2a64fff0e.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>📢📢📢 获取镜像的详细信息<br>格式： docker   inspect   镜像ID号<br>镜像ID 号可以不用打全。</p>
</blockquote>
<p><img src="https://imge.ablog168.cn/blog_img/1ac1a933ede74038a05e341f6d6c7fe7.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>📢📢📢为本地镜像添加新的标签<br>格式： docker   tag  名称:[ 标签]<br>📢📢📢 删除镜像<br>格式1： docker   rmi   仓库名称:标签<br>当一个镜像有多个标签时，只是删除其中指定的标签<br>格式2: docker   rmi  镜像ID  [-f]<br>如果该镜像已经被容器使用，正确的做法是先删除依赖该镜像的所有容器，再去删除镜像<br>📢📢📢 将镜像保存为本地文件<br>格式： docker   save   -o  存储文件名   存储的镜像<br>[root@localhost ~]# docker save -o /opt/nginx.tar nginx:latest  </p>
<h1 id="将本地镜像传给另一台主机"><a href="#将本地镜像传给另一台主机" class="headerlink" title="将本地镜像传给另一台主机"></a>将本地镜像传给另一台主机</h1><p>[root@localhost ~]# scp /opt/nginx.tar 192.168.1.54:/opt</p>
</blockquote>
<h2 id="⛳️-9-如何创建Docker容器？"><a href="#⛳️-9-如何创建Docker容器？" class="headerlink" title="⛳️ 9.如何创建Docker容器？"></a>⛳️ 9.如何创建Docker容器？</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#docker images   --镜像</span></span><br><span class="line">docker run -d --name centos7.8 -h centos7.8 \</span><br><span class="line">-p 220:22 -p 3387:3389 \</span><br><span class="line">--privileged=<span class="literal">true</span> \</span><br><span class="line">centos:7.8.2003 /usr/sbin/init</span><br><span class="line"></span><br><span class="line"><span class="comment">#我想拥有一个 linux 8.2 的环境</span></span><br><span class="line">docker run -d --name centos8.2 -h centos8.2 \</span><br><span class="line">-p 230:22 -p 3386:3389 \</span><br><span class="line">--privileged=<span class="literal">true</span> \</span><br><span class="line">daocloud.io/library/centos:8.2.2004 init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it centos7.8bash</span><br><span class="line">docker <span class="built_in">exec</span> -it centos8.2 bash</span><br><span class="line"><span class="built_in">cat</span> /etc/redhat-release    --查看系统版本</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="⛳️-10-Docker在后台的标准运行过程是什么？"><a href="#⛳️-10-Docker在后台的标准运行过程是什么？" class="headerlink" title="⛳️ 10.Docker在后台的标准运行过程是什么？"></a>⛳️ 10.Docker在后台的标准运行过程是什么？</h2><blockquote>
<p>当利用 docker run 来创建容器时， Docker 在后台的标准运行过程是：<br>📖 检查本地是否存在指定的镜像。当镜像不存在时，会从公有仓库下载；<br>📖 利用镜像创建并启动一个容器；<br>📖 分配一个文件系统给容器，在只读的镜像层外面挂载一层可读写层；<br>📖 从宿主主机配置的网桥接口中桥接一个虚拟机接口到容器中；<br>📖 分配一个地址池中的 IP 地址给容器；<br>📖 执行用户指定的应用程序，执行完毕后容器被终止运行。</p>
</blockquote>
<h2 id="⛳️-11-Docker网络模式有哪些？"><a href="#⛳️-11-Docker网络模式有哪些？" class="headerlink" title="⛳️ 11.Docker网络模式有哪些？"></a>⛳️ 11.Docker网络模式有哪些？</h2><p>📢📢📢 host模式</p>
<blockquote>
<p>host 模式 ： 使用 —net=host 指定<br>相当于VMware 中的桥接模式，与宿主机在同一个网络中，但是没有独立IP地址<br>Docker 使用了Linux 的Namespace 技术来进行资源隔离，如PID Namespace隔离进程，Mount Namespace隔离文件系统，Network Namespace 隔离网络等。<br>一个Network Namespace 提供了一份独立的网络环境，包括网卡，路由，iptable 规则等都与其他Network Namespace 隔离。<br>一个Docker 容器一般会分配一个独立的Network Namespace<br>但是如果启动容器的时候使用host 模式，那么这个容器将不会获得一个独立的Network Namespace ，而是和宿主机共用一个Network Namespace 。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口.此时容器不再拥有隔离的、独立的网络栈。不拥有所有端口资源</p>
</blockquote>
<p><img src="https://imge.ablog168.cn/blog_img/f4d1751834a74dd1971215c8d6a8b9f1.png" alt="在这里插入图片描述"><br>📢📢📢 container模式</p>
<blockquote>
<p>container模式： 使用—net=contatiner:NAME_or_ID 指定<br>这个模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。**新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP，端口范围等。**可以在一定程度上节省网络资源，容器内部依然不会拥有所有端口。<br>同样，两个容器除了网络方面，其他的如文件系统，进程列表等还是隔离的。<br>两个容器的进程可以通过lo网卡设备通信<br><img src="https://imge.ablog168.cn/blog_img/4e63b0d4ed2a47548f3a33d15f88797a.png" alt="在这里插入图片描述"><br>📢📢📢 none 模式<br>none模式:使用 —net=none指定<br>使用none 模式，docker 容器有自己的network Namespace ，但是并不为Docker 容器进行任何网络配置。也就是说，这个Docker 容器没有网卡，ip， 路由等信息。<br>这种网络模式下，容器只有lo 回环网络，没有其他网卡。<br>这种类型没有办法联网，但是封闭的网络能很好的保证容器的安全性<br>该容器将完全独立于网络，用户可以根据需要为容器添加网卡。此模式拥有所有端口。（none网络模式配置网络)特殊情况下才会用到，一般不用</p>
</blockquote>
<p>📢📢📢 bridge 模式</p>
<blockquote>
<p>相当于Vmware中的 nat 模式，容器使用独立network Namespace，并连接到docker0虚拟网卡。通过docker0网桥以及iptables nat表配置与宿主机通信，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的 Docker 容器连接到一个虚拟网桥上。<br>当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。<br>从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡veth pair设备。veth设备总是成对出现的，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来。因此，veth设备常用来连接两个网络设备。<br>Docker将veth pair 设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中， 以veth*这样类似的名字命名，并将这个网络设备加入到docker0网桥中。可以通过 brctl show 命令查看。<br>容器之间通过veth pair进行访问<br>使用 docker run -p 时，docker实际是在iptables做了DNAT规则，实现端口转发功能。<br>可以使用iptables -t nat -vnL 查看。</p>
</blockquote>
<p><img src="https://imge.ablog168.cn/blog_img/962a60efc8074920b32f7fae121b9f2f.png" alt="在这里插入图片描述"></p>
<h2 id="⛳️-12-什么是Docker的数据卷"><a href="#⛳️-12-什么是Docker的数据卷" class="headerlink" title="⛳️ 12.什么是Docker的数据卷"></a>⛳️ 12.什么是Docker的数据卷</h2><blockquote>
<p>数据卷是一个供容器使用的特殊目录，位于容器中。可将宿主机的目录挂载到数据卷上，对数据卷的修改操作立刻可见，并且更新数据不会影响镜像，从而实现数据在宿主机与容器之间的迁移。数据卷的使用类似于Linux下对目录进行的mount操作。<br>如果需要在容器之间共享一些数据，最简单的方法就是使用数据卷容器。数据卷容器是一个普通的容器，专门提供数据卷给其他容器挂载使用。<br>容器互联是通过容器的名称在容器间建立一条专门的网络通信隧道。简单点说，就是会在源容器和接收容器之间建立一条隧道，接收容器可以看到源容器指定的信息</p>
</blockquote>
<h2 id="⛳️-13-如何搭建Docker私有仓库"><a href="#⛳️-13-如何搭建Docker私有仓库" class="headerlink" title="⛳️ 13.如何搭建Docker私有仓库"></a>⛳️ 13.如何搭建Docker私有仓库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.拉取私有仓库镜像</span><br><span class="line">[root@jeames ~]<span class="comment"># docker pull registry</span></span><br><span class="line">Using default tag: latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.启动私有仓库容器</span><br><span class="line">docker run -di --name registry -p 5000:5000 registry</span><br><span class="line">docker update --restart=always registry   --开机自启动</span><br><span class="line">docker ps -a  --format <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Names&#125;&#125;\t&#123;&#123;.Status&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 访问网址：http://192.168.1.54:5000/v2/_catalog</span><br><span class="line">3.设置信任</span><br><span class="line">[root@jeames ~]<span class="comment"># vi /etc/docker/daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;registry-mirrors&quot;</span>:[<span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>],</span><br><span class="line"><span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;192.168.1.54:5000&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@jeames ~]<span class="comment"># systemctl restart docker   --重启docker</span></span><br><span class="line"></span><br><span class="line">4.上传本地镜像</span><br><span class="line">[root@jeames ~]<span class="comment"># docker images</span></span><br><span class="line">[root@jeames ~]<span class="comment"># docker tag postgres:11 192.168.1.54:5000/postgres</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@jeames ~]<span class="comment"># docker push 192.168.1.54:5000/postgres</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5.重新拉取镜像</span><br><span class="line">[root@jeames ~]<span class="comment"># docker rmi 192.168.1.54:5000/postgres</span></span><br><span class="line">[root@jeames ~]<span class="comment"># docker images</span></span><br><span class="line">[root@jeames ~]<span class="comment"># docker pull 192.168.1.54:5000/postgres</span></span><br></pre></td></tr></table></figure>
<h2 id="⛳️-14-Docker如何迁移备份？"><a href="#⛳️-14-Docker如何迁移备份？" class="headerlink" title="⛳️ 14.Docker如何迁移备份？"></a>⛳️ 14.Docker如何迁移备份？</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.容器保存为镜像</span><br><span class="line">[root@jeames ~]<span class="comment"># docker images</span></span><br><span class="line">[root@jeames ~]<span class="comment"># docker ps -a</span></span><br><span class="line">docker ps -a --format <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Names&#125;&#125;\t&#123;&#123;.Status&#125;&#125;&quot;</span></span><br><span class="line">[root@jeames ~]<span class="comment"># docker commit redis myredis</span></span><br><span class="line"><span class="comment">##使用新的镜像创建容器</span></span><br><span class="line">docker run -di --name myredis myredis</span><br><span class="line">2.镜像的备份</span><br><span class="line">[root@jeames ~]<span class="comment"># docker save -o myredis.tar myredis</span></span><br><span class="line">默认放到当前目录</span><br><span class="line">[root@jeames ~]<span class="comment"># ll</span></span><br><span class="line">[root@jeames ~]<span class="comment"># pwd</span></span><br><span class="line">3.恢复过程</span><br><span class="line"><span class="comment">##删除容器</span></span><br><span class="line">docker ps --format <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Names&#125;&#125;\t&#123;&#123;.Status&#125;&#125;&quot;</span></span><br><span class="line">docker stop myredis</span><br><span class="line">docker <span class="built_in">rm</span> myredis</span><br><span class="line"><span class="comment">##删除镜像</span></span><br><span class="line">docker images</span><br><span class="line">docker rmi myredis</span><br><span class="line">[root@jeames ~]<span class="comment"># docker load -i myredis.tar</span></span><br></pre></td></tr></table></figure>
<h2 id="⛳️-15-Docker如何部署MySQL？"><a href="#⛳️-15-Docker如何部署MySQL？" class="headerlink" title="⛳️ 15. Docker如何部署MySQL？"></a>⛳️ 15. Docker如何部署MySQL？</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.下载镜像</span><br><span class="line">https://hub.docker.com/ 中搜索mysql</span><br><span class="line">[root@jeames ~]<span class="comment"># docker pull mysql:5.7.30</span></span><br><span class="line">[root@jeames ~]<span class="comment"># docker pull mysql:8.0.20</span></span><br><span class="line">2.安装部署</span><br><span class="line">2.1 创建容器</span><br><span class="line"><span class="built_in">mkdir</span> -p /usr/local/mysql5730/</span><br><span class="line"><span class="built_in">mkdir</span> -p /usr/local/mysql8020/</span><br><span class="line"></span><br><span class="line">docker run -d --name mysql5730 -h mysql5730 \</span><br><span class="line">-p 3309:3306 \</span><br><span class="line">-v /usr/local/mysql5730/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root -e TZ=Asia/Shanghai \</span><br><span class="line">mysql:5.7.30</span><br><span class="line"></span><br><span class="line">docker run -d --name mysql8020 -h mysql8020 \</span><br><span class="line">-p 3310:3306 \</span><br><span class="line">-v /usr/local/mysql8020/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root -e TZ=Asia/Shanghai \</span><br><span class="line">mysql:8.0.20</span><br><span class="line"></span><br><span class="line">2.2 访问Mysql</span><br><span class="line"><span class="comment">##登陆容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql5730 bash</span><br><span class="line">mysql -uroot -proot</span><br><span class="line">mysql&gt; <span class="keyword">select</span> user,host from mysql.user</span><br><span class="line"></span><br><span class="line"><span class="comment">##远程访问</span></span><br><span class="line">mysql -uroot -proot -h192.168.59.220 -P3309</span><br></pre></td></tr></table></figure>
<p><img src="https://imge.ablog168.cn/blog_img/f97bf2c0757644da889f8baa2390c754.gif" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中代码优化的30个小技巧</title>
    <url>/2023/05/28/java%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p><br /></p>
<h2 id="1-用String-format拼接字符串"><a href="#1-用String-format拼接字符串" class="headerlink" title="1.用String.format拼接字符串 "></a>1.用String.format拼接字符串 </h2><p><strong><em>String.format</em></strong>方法拼接url请求参数，日志打印等字符串。</p>
<p>但不建议在for循环中用它拼接字符串，因为它的执行效率，比使用+号拼接字符串，或者使用StringBuilder拼接字符串都要慢一些。</p>
<h2 id="2-创建可缓冲的IO流"><a href="#2-创建可缓冲的IO流" class="headerlink" title="2.创建可缓冲的IO流"></a>2.创建可缓冲的IO流</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尽量使用try-with-resources语句，可以在程序结束时自动关闭资源</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ServletOutputStream</span> <span class="variable">outStr</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">     <span class="type">BufferedOutputStream</span> <span class="variable">buff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(outStr))&#123;</span><br><span class="line">    buff.write(text.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    buff.flush();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;导出文件文件出错:&#123;&#125;&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用缓冲流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/Documents/test1/1.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/Documents/test1/2.txt&quot;</span>);</span><br><span class="line"><span class="keyword">try</span>(<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos)) &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    bos.flush();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="3-减少循环次数"><a href="#3-减少循环次数" class="headerlink" title="3.减少循环次数"></a>3.减少循环次数</h2><p>如果循环层级比较深，循环中套循环，可能会影响代码的执行效率。</p>
<p>如果有两层循环，如果userList和roleList数据比较多的话，需要循环遍历很多次，才能获取我们所需要的数据，非常消耗cpu资源。</p>
<p>如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正常逻辑2层for循环处理</span></span><br><span class="line"><span class="keyword">for</span>(User user: userList) &#123;</span><br><span class="line">   <span class="keyword">for</span>(Role role: roleList) &#123;</span><br><span class="line">      <span class="keyword">if</span>(user.getRoleId().equals(role.getId())) &#123;</span><br><span class="line">         user.setRoleName(role.getName());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Long, List&lt;Role&gt;&gt; roleMap = roleList.stream().collect(Collectors.groupingBy(Role::getId));</span><br><span class="line"><span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">    List&lt;Role&gt; roles = roleMap.get(user.getRoleId());</span><br><span class="line">    <span class="keyword">if</span>(CollectionUtils.isNotEmpty(roles)) &#123;</span><br><span class="line">        user.setRoleName(roles.get(<span class="number">0</span>).getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化思想就是减少循环次数，最简单的办法是，把第二层循环的集合变成<strong><em>map</em></strong>，这样可以直接通过<strong><em>key</em></strong>，获取想要的<strong><em>value</em></strong>数据。</p>
<p>虽说map的key存在<strong><em>hash冲突</em></strong>的情况，但遍历存放数据的<strong><em>链表</em></strong>或者<strong><em>红黑树</em></strong>的<strong><em>时间复杂度</em></strong>，比遍历整个list集合要小很多。</p>
<h2 id="4-用完资源记得及时关闭"><a href="#4-用完资源记得及时关闭" class="headerlink" title="4.用完资源记得及时关闭"></a>4.用完资源记得及时关闭</h2><p>参考第二点尽量使用try-with-resources语句或者手动关闭资源</p>
<h2 id="5-使用池技术"><a href="#5-使用池技术" class="headerlink" title="5.使用池技术"></a>5.使用池技术</h2><p>数据库连接池、线程池</p>
<h2 id="6-消除if…else的锦囊妙计，反射时添加缓存"><a href="#6-消除if…else的锦囊妙计，反射时添加缓存" class="headerlink" title="6.消除if…else的锦囊妙计，反射时添加缓存"></a>6.消除if…else的锦囊妙计，反射时添加缓存</h2><p>我们都知道通过<strong><em>反射</em></strong>创建对象实例，比使用<strong><em>new</em></strong>关键字要慢很多。</p>
<p>由此，不太建议在用户请求过来时，每次都通过反射<strong><em>实时</em></strong>创建实例。</p>
<p>有时候，为了代码的灵活性，又不得不用反射创建实例，这时该怎么办呢？</p>
<p>答：加<strong><em>缓存</em></strong>。</p>
<p>先看以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">publicinterface IPay &#123;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">publicclass AliaPay <span class="keyword">implements</span> <span class="title class_">IPay</span> &#123;  </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;===发起支付宝支付===&quot;</span>);  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">publicclass WeixinPay <span class="keyword">implements</span> <span class="title class_">IPay</span> &#123;  </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;  </span><br><span class="line">         System.out.println(<span class="string">&quot;===发起微信支付===&quot;</span>);  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">publicclass JingDongPay <span class="keyword">implements</span> <span class="title class_">IPay</span> &#123;  </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;===发起京东支付===&quot;</span>);  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">publicclass PayService &#123;  </span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     <span class="keyword">private</span> AliaPay aliaPay;  </span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     <span class="keyword">private</span> WeixinPay weixinPay;  </span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     <span class="keyword">private</span> JingDongPay jingDongPay;  </span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toPay</span><span class="params">(String code)</span> &#123;  </span><br><span class="line">         <span class="keyword">if</span> (<span class="string">&quot;alia&quot;</span>.equals(code)) &#123;  </span><br><span class="line">             aliaPay.pay();  </span><br><span class="line">         &#125; elseif (<span class="string">&quot;weixin&quot;</span>.equals(code)) &#123;  </span><br><span class="line">              weixinPay.pay();  </span><br><span class="line">         &#125; elseif (<span class="string">&quot;jingdong&quot;</span>.equals(code)) &#123;  </span><br><span class="line">              jingDongPay.pay();  </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">              System.out.println(<span class="string">&quot;找不到支付方式&quot;</span>);  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里违法了设计模式六大原则的：<strong><em>开闭原则</em></strong> 和 <strong><em>单一职责原则</em></strong>。</p>
<p>开闭原则：对扩展开放，对修改关闭。就是说增加新功能要尽量少改动已有代码。</p>
<p>单一职责原则：顾名思义，要求逻辑尽量单一，不要太复杂，便于复用。</p>
<ol>
<li>先创建一个注解</li>
<li>在所有的支付类上都加上该注解</li>
<li>增加最关键的类PayService2</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Ywh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/7/25 14:50</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PayCode &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@PayCode(value = &quot;alia&quot;, name = &quot;支付宝支付&quot;)</span></span><br><span class="line"><span class="meta">@Component(&quot;alia&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliaPay</span> <span class="keyword">implements</span> <span class="title class_">IPay</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===发起支付宝支付===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PayCode(value = &quot;jingdong&quot;, name = &quot;京东支付&quot;)</span></span><br><span class="line"><span class="meta">@Component(&quot;jingdong&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JingDongPay</span> <span class="keyword">implements</span> <span class="title class_">IPay</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===发起京东支付===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PayCode(value = &quot;weixin&quot;, name = &quot;微信支付&quot;)</span></span><br><span class="line"><span class="meta">@Component(&quot;weixin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeixinPay</span> <span class="keyword">implements</span> <span class="title class_">IPay</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===发起微信支付===&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayService2</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, IPay&gt; payMap = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextRefreshedEvent contextRefreshedEvent)</span> &#123;</span><br><span class="line">        <span class="comment">//在初始化或刷新ApplicationContext时发布</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> contextRefreshedEvent.getApplicationContext();</span><br><span class="line">        <span class="comment">//获取所有拥有特定payCode注解的Bean（AliPay、WeiXinPay、JindDongPay）</span></span><br><span class="line">        Map&lt;String, Object&gt; beansWithAnnotation = applicationContext.getBeansWithAnnotation(PayCode.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (beansWithAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">            payMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            beansWithAnnotation.forEach((key, value) -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">bizType</span> <span class="operator">=</span> value.getClass().getAnnotation(PayCode.class).value();</span><br><span class="line">                payMap.put(bizType, (IPay) value);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(String code)</span> &#123;</span><br><span class="line">        payMap.get(code).pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/pay&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;测试支付&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(String code)</span>&#123;</span><br><span class="line">        payService2.pay(code);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>PayService2类实现了<strong><em>ApplicationListener</em></strong>接口，这样在<strong><em>onApplicationEvent</em></strong>方法中，就可以拿到<strong><em>ApplicationContext</em></strong>的实例。这一步，其实是在spring容器启动的时候，spring通过反射我们处理好了。</p>
<p>我们再获取打了PayCode注解的类，放到一个<strong><em>map</em></strong>中，map中的<strong><em>key</em></strong>就是PayCode注解中定义的value，跟code参数一致，<strong><em>value</em></strong>是支付类的实例。</p>
<p>这样，每次就可以每次直接通过code获取支付类实例，而不用if…else判断了。如果要加新的支付方法，只需在支付类上面打上PayCode注解定义一个新的code即可。</p>
<p>注意：这种方式的code可以没有业务含义，可以是纯数字，只要不重复就行。</p>
<h2 id="7-多线程处理"><a href="#7-多线程处理" class="headerlink" title="7.多线程处理"></a>7.多线程处理</h2><p>一句话把串行执行的接口变成并行执行；</p>
<p><img src="https://img-blog.csdnimg.cn/0f115e004f5b4a21b78f201d0792216c.png" alt=""></p>
<p>并行执行</p>
<p><img src="https://img-blog.csdnimg.cn/51849d4f6a7446f6bde89286dbfe347e.png" alt=""></p>
<p>在java8之前可以通过实现<strong><em>Callable</em></strong>接口，获取线程返回结果。</p>
<p>java8以后通过<strong><em>CompleteFuture</em></strong>类实现该功能。我们这里以CompleteFuture为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> UserInfo <span class="title function_">getUserInfo</span><span class="params">(Long id)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserInfo</span>();</span><br><span class="line">    <span class="type">CompletableFuture</span> <span class="variable">userFuture</span> <span class="operator">=</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        getRemoteUserAndFill(id, userInfo);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;, executor);</span><br><span class="line"></span><br><span class="line">    <span class="type">CompletableFuture</span> <span class="variable">bonusFuture</span> <span class="operator">=</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        getRemoteBonusAndFill(id, userInfo);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;, executor);</span><br><span class="line"></span><br><span class="line">    <span class="type">CompletableFuture</span> <span class="variable">growthFuture</span> <span class="operator">=</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        getRemoteGrowthAndFill(id, userInfo);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;, executor);</span><br><span class="line">    CompletableFuture.allOf(userFuture, bonusFuture, growthFuture).join();</span><br><span class="line"></span><br><span class="line">    userFuture.get();</span><br><span class="line">    bonusFuture.get();</span><br><span class="line">    growthFuture.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-懒加载"><a href="#8-懒加载" class="headerlink" title="8.懒加载"></a>8.懒加载</h2><p>有时候，创建对象是一个非常耗时的操作，特别是在该对象的创建过程中，还需要创建很多其他的对象时。</p>
<p>我们以单例模式为例。</p>
<p>在介绍单例模式的时候，必须要先介绍它的两种非常著名的实现方式：<strong><em>饿汉模式</em></strong> 和 <strong><em>懒汉模式</em></strong>。</p>
<h3 id="8-1-饿汉模式"><a href="#8-1-饿汉模式" class="headerlink" title="8.1 饿汉模式"></a>8.1 <strong><em>饿汉模式</em></strong></h3><p>实例在初始化的时候就已经建好了，不管你有没有用到，先建好了再说。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleSingleton</span> &#123;</span><br><span class="line">    <span class="comment">//持有自己类的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleSingleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleSingleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SimpleSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对外提供获取实例的静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SimpleSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用饿汉模式的好处是：<strong><em>没有线程安全的问题</em></strong>，但带来的坏处也很明显。</p>
<h3 id="8-2-懒汉模式"><a href="#8-2-懒汉模式" class="headerlink" title="8.2 懒汉模式"></a>8.2 <strong><em>懒汉模式</em></strong></h3><p>顾名思义就是实例在用到的时候才去创建，”比较懒”，用的时候才去检查有没有实例，如果有则返回，没有则新建。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleSingleton2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleSingleton2 INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SimpleSingleton2</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SimpleSingleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">SimpleSingleton2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例中的INSTANCE对象一开始是空的，在调用getInstance方法才会真正实例化。</p>
<p>懒汉模式相对于饿汉模式，没有提前实例化对象，在真正使用的时候再实例化，在实例化对象的阶段效率更高一些。</p>
<p><strong>除了单例模式之外，懒加载的思想，使用比较多的可能是：</strong></p>
<ol>
<li><p>spring的@Lazy注解。在spring容器启动的时候，不会调用其getBean方法初始化实例。</p>
</li>
<li><p>mybatis的懒加载。在mybatis做级联查询的时候，比如查用户的同时需要查角色信息。如果用了懒加载，先只查用户信息，真正使用到角色了，才取查角色信息。</p>
</li>
</ol>
<h2 id="9-初始化集合时指定大小"><a href="#9-初始化集合时指定大小" class="headerlink" title="9.初始化集合时指定大小"></a>9.初始化集合时指定大小</h2><p>在创建集合时指定了大小，比没有指定大小，添加10万个元素的效率提升了一倍。</p>
<p>如果你看过<strong><em>ArrayList</em></strong>源码，你就会发现它的默认大小是<strong><em>10</em></strong>，如果添加元素超过了一定的阀值，会按<strong><em>1.5</em></strong>倍的大小扩容。</p>
<p>你想想，如果装10万条数据，需要扩容多少次呀？而每次扩容都需要不停的复制元素，从老集合复制到新集合中，需要浪费多少时间呀。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//正例 </span></span><br><span class="line">List&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">100000</span>);</span><br></pre></td></tr></table></figure>
<h2 id="10-不要满屏try…catch异常"><a href="#10-不要满屏try…catch异常" class="headerlink" title="10.不要满屏try…catch异常"></a>10.不要满屏try…catch异常</h2><p>可以使用全局异常处理：<strong><em>RestControllerAdvice</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ArithmeticException) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;数据异常&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;服务器内部异常&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        retur nnull;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-位运算效率更高"><a href="#11-位运算效率更高" class="headerlink" title="11.位运算效率更高"></a>11.位运算效率更高</h2><h2 id="12-巧用第三方工具类"><a href="#12-巧用第三方工具类" class="headerlink" title="12.巧用第三方工具类"></a>12.巧用第三方工具类</h2><p>如果你引入<strong><em>com.google.guava</em></strong>的pom文件，会获得很多好用的小工具。这里推荐一款<strong><em>com.google.common.collect</em></strong>包下的集合工具：<strong><em>Lists</em></strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//guava提供的字符串工具类</span></span><br><span class="line">Strings.isNullOrEmpty(<span class="string">&quot;&quot;</span>);<span class="comment">//返回true</span></span><br><span class="line">Strings.nullToEmpty(<span class="literal">null</span>);<span class="comment">//&quot;&quot;</span></span><br><span class="line">Strings.nullToEmpty(<span class="string">&quot;chen&quot;</span>);<span class="comment">//返回&quot;chen&quot;</span></span><br><span class="line">Strings.emptyToNull(<span class="string">&quot;&quot;</span>);<span class="comment">//返回null</span></span><br><span class="line">Strings.emptyToNull(<span class="string">&quot;chen&quot;</span>);<span class="comment">//返回&quot;chen&quot;  </span></span><br><span class="line"> </span><br><span class="line">Strings.commonPrefix(<span class="string">&quot;aaab&quot;</span>, <span class="string">&quot;aac&quot;</span>);<span class="comment">//&quot;aa&quot;否则返回&quot;&quot;</span></span><br><span class="line">Strings.commonSuffix(<span class="string">&quot;aaac&quot;</span>, <span class="string">&quot;aac&quot;</span>);<span class="comment">//&quot;aac&quot;否则返回&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="13-用同步代码块代替同步方法"><a href="#13-用同步代码块代替同步方法" class="headerlink" title="13.用同步代码块代替同步方法"></a>13.用同步代码块代替同步方法</h2><p>在某些业务场景中，为了防止多个线程并发修改某个共享数据，造成数据异常。</p>
<p>为了解决并发场景下，多个线程同时修改数据，造成数据不一致的情况。通常情况下，我们会：<strong><em>加锁</em></strong>。</p>
<p>但如果锁加得不好，导致<strong><em>锁的粒度太粗</em></strong>，也会非常影响接口性能。</p>
<p>在java中提供了<strong><em>synchronized</em></strong>关键字给我们的代码加锁。</p>
<p>通常有两种写法：<strong><em>在方法上加锁</em></strong> 和 <strong><em>在代码块上加锁</em></strong>。</p>
<p>先看看如何在方法上加锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="title function_">doSave</span><span class="params">(String fileUrl)</span> &#123;</span><br><span class="line">    mkdir();</span><br><span class="line">    uploadFile(fileUrl);</span><br><span class="line">    sendMessage(fileUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里加锁的目的是为了防止并发的情况下，创建了相同的目录，第二次会创建失败，影响业务功能。</p>
<p>但这种直接在方法上加锁，锁的粒度有点粗。因为doSave方法中的上传文件和发消息方法，是不需要加锁的。只有创建目录方法，才需要加锁。</p>
<p>我们都知道文件上传操作是非常耗时的，如果将整个方法加锁，那么需要等到整个方法执行完之后才能释放锁。显然，这会导致该方法的性能很差，变得得不偿失。</p>
<p>这时，我们可以改成在代码块上加锁了，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSave</span><span class="params">(String path,String fileUrl)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!exists(path)) &#123;</span><br><span class="line">          mkdir(path);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    uploadFile(fileUrl);</span><br><span class="line">    sendMessage(fileUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样改造之后，锁的粒度一下子变小了，只有并发创建目录功能才加了锁。而创建目录是一个非常快的操作，即使加锁对接口的性能影响也不大。</p>
<p>最重要的是，其他的上传文件和发送消息功能，任然可以并发执行。</p>
<h2 id="14-不用的数据及时清理"><a href="#14-不用的数据及时清理" class="headerlink" title="14.不用的数据及时清理"></a>14.不用的数据及时清理</h2><p>在Java中保证线程安全的技术有很多，可以使用<strong><em>synchroized</em></strong>、<strong><em>Lock</em></strong>等关键字给代码块<code>加锁</code>。</p>
<p>但是它们有个共同的特点，就是加锁会对代码的性能有一定的损耗。</p>
<p>其实，在jdk中还提供了另外一种思想即：<code>用空间换时间</code>。</p>
<p>没错，使用<strong><em>ThreadLocal</em></strong>类就是对这种思想的一种具体体现。</p>
<p>ThreadLocal为每个使用变量的线程提供了一个独立的变量副本，这样每一个线程都能独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<p>ThreadLocal的用法大致是这样的：</p>
<ol>
<li><p>先创建一个CurrentUser类，其中包含了ThreadLocal的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CurrentUser</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserInfo&gt; THREA_LOCAL = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(UserInfo userInfo)</span> &#123;</span><br><span class="line">        THREA_LOCAL.set(userInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserInfo <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">       THREA_LOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">       THREA_LOCAL.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在业务代码中调用CurrentUser类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSamething</span><span class="params">(UserDto userDto)</span> &#123;</span><br><span class="line">   <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> convert(userDto);</span><br><span class="line">   CurrentUser.set(userInfo);</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   <span class="comment">//业务代码</span></span><br><span class="line">   <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> CurrentUser.get();</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在业务代码的第一行，将userInfo对象设置到CurrentUser，这样在业务代码中，就能通过CurrentUser.get()获取到刚刚设置的userInfo对象。特别是对业务代码调用层级比较深的情况，这种用法非常有用，可以减少很多不必要传参。</p>
<p>但在高并发的场景下，这段代码有问题，只往ThreadLocal存数据，数据用完之后并没有及时清理。</p>
<p>ThreadLocal即使使用了<strong><em>WeakReference</em></strong>（弱引用）也可能会存在<code>内存泄露</code>问题，因为 entry对象中只把key(即threadLocal对象)设置成了弱引用，但是value值没有。</p>
<p>那么，如何解决这个问题呢？</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSamething</span><span class="params">(UserDto userDto)</span> &#123;</span><br><span class="line">   <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> convert(userDto);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">     CurrentUser.set(userInfo);</span><br><span class="line">     ...</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//业务代码</span></span><br><span class="line">     <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> CurrentUser.get();</span><br><span class="line">     ...</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      CurrentUser.remove();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要在<strong><em>finally</em></strong>代码块中，调用<strong><em>remove</em></strong>方法清理没用的数据。</p>
<h2 id="15-用equals方法比较是否相等"><a href="#15-用equals方法比较是否相等" class="headerlink" title="15.用equals方法比较是否相等"></a>15.用equals方法比较是否相等</h2><h2 id="16-避免创建大集合"><a href="#16-避免创建大集合" class="headerlink" title="16.避免创建大集合"></a>16.避免创建大集合</h2><p>尽量分页处理</p>
<h2 id="17-状态用枚举"><a href="#17-状态用枚举" class="headerlink" title="17.状态用枚举"></a>17.状态用枚举</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OrderStatusEnum</span> &#123;  </span><br><span class="line">     CREATE(<span class="number">1</span>, <span class="string">&quot;下单&quot;</span>),  </span><br><span class="line">     PAY(<span class="number">2</span>, <span class="string">&quot;支付&quot;</span>),  </span><br><span class="line">     DONE(<span class="number">3</span>, <span class="string">&quot;完成&quot;</span>),  </span><br><span class="line">     CANCEL(<span class="number">4</span>, <span class="string">&quot;撤销&quot;</span>);  </span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> code;  </span><br><span class="line">     <span class="keyword">private</span> String message;  </span><br><span class="line"></span><br><span class="line">     OrderStatusEnum(<span class="type">int</span> code, String message) &#123;  </span><br><span class="line">         <span class="built_in">this</span>.code = code;  </span><br><span class="line">         <span class="built_in">this</span>.message = message;  </span><br><span class="line">     &#125;  </span><br><span class="line">   </span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.code;  </span><br><span class="line">     &#125;  </span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.message;  </span><br><span class="line">     &#125;  </span><br><span class="line">  </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> OrderStatusEnum <span class="title function_">getOrderStatusEnum</span><span class="params">(<span class="type">int</span> code)</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(OrderStatusEnum.values()).filter(x -&gt; x.code == code).findFirst().orElse(<span class="literal">null</span>);  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而且使用枚举的好处是：</p>
<ol>
<li><p>代码的可读性变强了，不同的状态，有不同的枚举进行统一管理和维护。</p>
</li>
<li><p>枚举是天然单例的，可以直接使用==号进行比较。</p>
</li>
<li><p>code和message可以成对出现，比较容易相关转换。</p>
</li>
<li><p>枚举可以消除if…else过多问题。</p>
</li>
</ol>
<h2 id="18-把固定值定义成静态常量"><a href="#18-把固定值定义成静态常量" class="headerlink" title="18.把固定值定义成静态常量"></a>18.把固定值定义成静态常量</h2><p>使用<strong><em>static final</em></strong>关键字修饰静态常量，<strong><em>static</em></strong>表示<code>静态</code>的意思，即类变量，而<strong><em>final</em></strong>表示<strong><em>不允许修改</em></strong>。</p>
<p>两个关键字加在一起，告诉Java虚拟机这种变量，在内存中只有一份，在全局上是唯一的，不能修改，也就是<strong><em>静态常量</em></strong>。</p>
<h2 id="19-避免大事务"><a href="#19-避免大事务" class="headerlink" title="19.避免大事务"></a>19.避免大事务</h2><p>很多小伙伴在使用spring框架开发项目时，为了方便，喜欢使用<strong><em>@Transactional</em></strong>注解提供事务功能。</p>
<p>没错，使用@Transactional注解这种声明式事务的方式提供事务功能，确实能少写很多代码，提升开发效率。</p>
<p>但也容易造成大事务，引发其他的问题。</p>
<p>下面用一张图看看大事务引发的问题。</p>
<p><img src="https://img-blog.csdnimg.cn/d313f62e4a01487790cbf8cf4c474787.png" alt=""></p>
<p>从图中能够看出，大事务问题可能会造成接口超时，对接口的性能有直接的影响。</p>
<p>我们该如何优化大事务呢？</p>
<ol>
<li><p>少用@Transactional注解</p>
</li>
<li><p>将查询(select)方法放到事务外</p>
</li>
<li><p>事务中避免远程调用</p>
</li>
<li><p>事务中避免一次性处理太多数据</p>
</li>
<li><p>有些功能可以非事务执行</p>
</li>
<li><p>有些功能可以异步处理</p>
</li>
</ol>
<p>大家可以参考关于大事务的这篇文章《<a href="https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;mid=2247490259&amp;idx=1&amp;sn=1dd11c5f49103ca303a61fc82ce406e0&amp;chksm=c0ebc23bf79c4b2db58b28ef752560bd91a1932ceb6713c9b19b821db0f29e1c58275d334076&amp;token=2041133408&amp;lang=zh_CN&amp;scene=21#wechat_redirect" title="让人头痛的大事务问题到底要如何解决？">让人头痛的大事务问题到底要如何解决？</a>》</p>
<h2 id="20-消除过长的if…else"><a href="#20-消除过长的if…else" class="headerlink" title="20.消除过长的if…else"></a>20.消除过长的if…else</h2><p>更详细的内容可以看看这篇文章《<a href="https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;mid=2247490272&amp;idx=1&amp;sn=c5db63c7b52e7518b7a42e48c70927fc&amp;scene=21#wechat_redirect" title="消除if...else是9条锦囊妙计">消除if…else是9条锦囊妙计</a>》</p>
<h2 id="21-防止死循环"><a href="#21-防止死循环" class="headerlink" title="21.防止死循环"></a>21.防止死循环</h2><h2 id="22-注意BigDecimal的坑"><a href="#22-注意BigDecimal的坑" class="headerlink" title="22.注意BigDecimal的坑"></a>22.注意BigDecimal的坑</h2><p>通常我们会把一些小数类型的字段（比如：金额），定义成<strong><em>BigDecimal</em></strong>，而不是<strong><em>Double</em></strong>，避免丢失精度问题。</p>
<p>常识告诉我们使用<strong><em>BigDecimal</em></strong>能避免丢失精度。</p>
<p>但是使用BigDecimal能避免丢失精度吗？</p>
<p>答案是否定的。</p>
<p>为什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">amount1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.02</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">amount2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.03</span>);</span><br><span class="line">System.out.println(amount2.subtract(amount1));</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<blockquote>
<p>0.0099999999999999984734433411404097569175064563751220703125</p>
</blockquote>
<p>不科学呀，为啥还是丢失精度了？</p>
<p>使用BigDecimal构造函数初始化对象，也会丢失精度。</p>
<p>那么，如何才能不丢失精度呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">amount1</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">0.02</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">amount2</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">0.03</span>);</span><br><span class="line">System.out.println(amount2.subtract(amount1));</span><br></pre></td></tr></table></figure>
<h2 id="23-尽可能复用代码"><a href="#23-尽可能复用代码" class="headerlink" title="23.尽可能复用代码"></a>23.尽可能复用代码</h2><h2 id="24-foreach循环中不remove元素"><a href="#24-foreach循环中不remove元素" class="headerlink" title="24.foreach循环中不remove元素"></a>24.foreach循环中不remove元素</h2><p>循环有很多种写法，比如：while、for、foreach等。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = Lists.newArrayList(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String temp : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;c&quot;</span>.equals(temp)) &#123;</span><br><span class="line">                list.remove(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果：</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.util.ConcurrentModificationException</span><br><span class="line"> at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">901</span>)</span><br><span class="line"> at java.util.ArrayList$Itr.next(ArrayList.java:<span class="number">851</span>)</span><br><span class="line"> at com.sue.jump.service.test1.Test2.main(Test2.java:<span class="number">24</span>)</span><br></pre></td></tr></table></figure>
<p>这种在<strong><em>foreach</em></strong>循环中调用<strong><em>remove</em></strong>方法删除元素，可能会报<strong><em>ConcurrentModificationException</em></strong>异常。</p>
<p>如果想在遍历集合时，删除其中的元素，可以用for循环，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">           <span class="keyword">if</span> (<span class="string">&quot;c&quot;</span>.equals(temp)) &#123;</span><br><span class="line">               list.remove(temp);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(list);</span><br></pre></td></tr></table></figure>
<h2 id="25-避免随意打印日志"><a href="#25-避免随意打印日志" class="headerlink" title="25.避免随意打印日志"></a>25.避免随意打印日志</h2><p>使用<strong><em>isDebugEnabled</em></strong>判断一下，如果当前的日志级别是<strong><em>debug</em></strong>才打印日志。生产环境默认日志级别是<strong><em>info</em></strong>，在有些紧急情况下，把某个接口或者方法的日志级别改成debug，打印完我们需要的日志后，又调整回去。</p>
<p>方便我们定位问题，又不会产生大量的垃圾日志，一举两得</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/query&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">query</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;request params:&#123;&#125;&quot;</span>, ids);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; userList = userService.query(ids);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;response:&#123;&#125;&quot;</span>, userList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="26-比较时把常量写前面"><a href="#26-比较时把常量写前面" class="headerlink" title="26.比较时把常量写前面"></a>26.比较时把常量写前面</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FOUND_NAME</span> <span class="operator">=</span> <span class="string">&quot;苏三&quot;</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">null</span> == user) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(FOUND_NAME.equals(user.getName())) &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;找到：&quot;</span>+user.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用<strong><em>equals</em></strong>做比较时，尽量将<strong><em>常量</em></strong>写在前面，即equals方法的左边。</p>
<p>这样即使user.getName()返回的数据为null，equals方法会直接返回false，而不再是报空指针异常。</p>
<h2 id="27-名称要见名知意"><a href="#27-名称要见名知意" class="headerlink" title="27.名称要见名知意"></a>27.名称要见名知意</h2><h2 id="28-SimpleDateFormat线程不安全"><a href="#28-SimpleDateFormat线程不安全" class="headerlink" title="28.SimpleDateFormat线程不安全"></a>28.SimpleDateFormat线程不安全</h2><p>使用java8的DateTimeFormatter类。  </p>
<h2 id="29-少用Executors创建线程池"><a href="#29-少用Executors创建线程池" class="headerlink" title="29.少用Executors创建线程池"></a>29.少用Executors创建线程池</h2><p>我们都知道<strong><em>JDK5</em></strong>之后，提供了<strong><em>ThreadPoolExecutor</em></strong>类，用它可以<strong><em>自定义线程池</em></strong>。</p>
<p>线程池的好处有很多，下面主要说说这3个方面。</p>
<ol>
<li><p><strong><em>降低资源消耗</em></strong>：避免了频繁的创建线程和销毁线程，可以直接复用已有线程。而我们都知道，创建线程是非常耗时的操作。</p>
</li>
<li><p><strong><em>提供速度</em></strong>：任务过来之后，因为线程已存在，可以拿来直接使用。</p>
</li>
<li><p><strong><em>提高线程的可管理性</em></strong>：线程是非常宝贵的资源，如果创建过多的线程，不仅会消耗系统资源，甚至会影响系统的稳定。使用线程池，可以非常方便的创建、管理和监控线程。</p>
</li>
</ol>
<p>当然JDK为了我们使用更便捷，专门提供了：<strong><em>Executors</em></strong>类，给我们快速创建<strong><em>线程池</em></strong>。</p>
<p>该类中包含了很多<strong><em>静态方法</em></strong>：</p>
<ul>
<li><p><strong><em>newCachedThreadPool</em></strong>：创建一个可缓冲的线程，如果线程池大小超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>
</li>
<li><p><strong><em>newFixedThreadPool</em></strong>：创建一个固定大小的线程池，如果任务数量超过线程池大小，则将多余的任务放到队列中。</p>
</li>
<li><p><strong><em>newScheduledThreadPool</em></strong>：创建一个固定大小，并且能执行定时周期任务的线程池。</p>
</li>
<li><p><strong><em>newSingleThreadExecutor</em></strong>：创建只有一个线程的线程池，保证所有的任务安装顺序执行。</p>
</li>
</ul>
<p>在高并发的场景下，如果大家使用这些静态方法创建线程池，会有一些问题。</p>
<p>那么，我们一起看看有哪些问题？</p>
<ul>
<li><p><strong><em>newFixedThreadPool</em></strong>：允许请求的队列长度是Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。</p>
</li>
<li><p><strong><em>newSingleThreadExecutor</em></strong>：允许请求的队列长度是Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。</p>
</li>
<li><p><strong><em>newCachedThreadPool</em></strong>：允许创建的线程数是Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。</p>
</li>
</ul>
<p>那我们该怎办呢？</p>
<p>优先推荐使用<strong><em>ThreadPoolExecutor</em></strong>类，我们自定义线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">8</span>, <span class="comment">//corePoolSize线程池中核心线程数</span></span><br><span class="line">    <span class="number">10</span>, <span class="comment">//maximumPoolSize 线程池中最大线程数</span></span><br><span class="line">    <span class="number">60</span>, <span class="comment">//线程池中线程的最大空闲时间，超过这个时间空闲线程将被回收</span></span><br><span class="line">    TimeUnit.SECONDS,<span class="comment">//时间单位</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">500</span>), <span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()); <span class="comment">//拒绝策略</span></span><br></pre></td></tr></table></figure>
<p>顺便说一下，如果是一些低并发场景，使用<strong><em>Executors</em></strong>类创建线程池也未尝不可，也不能完全一棍子打死。在这些低并发场景下，很难出现<strong><em>OOM</em></strong>问题，所以我们需要根据实际业务场景选择。</p>
<h2 id="30-Arrays-asList转换的集合别修改"><a href="#30-Arrays-asList转换的集合别修改" class="headerlink" title="30.Arrays.asList转换的集合别修改"></a>30.Arrays.asList转换的集合别修改</h2><p>在我们日常工作中，经常需要把<strong><em>数组</em></strong>转换成<strong><em>List</em></strong>集合。</p>
<p>因为数组的长度是固定的，不太好扩容，而List的长度是可变的，它的长度会根据元素的数量动态扩容。</p>
<p>在JDK的<strong><em>Arrays</em></strong>类中提供了<strong><em>asList</em></strong>方法，可以把<strong><em>数组</em></strong>转换成<strong><em>List</em></strong>。</p>
<p><strong><em>正例</em></strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String [] array = <span class="keyword">new</span> <span class="title class_">String</span> [] &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(array);</span><br><span class="line"><span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，使用Arrays.asList方法将array数组，直接转换成了list。然后在for循环中遍历list，打印出它里面的元素。</p>
<p>如果转换后的list，只是使用，没新增或修改元素，不会有问题。</p>
<p><strong><em>反例</em></strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] array = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(array);</span><br><span class="line">list.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.UnsupportedOperationException</span><br><span class="line">at java.util.AbstractList.add(AbstractList.java:<span class="number">148</span>)</span><br><span class="line">at java.util.AbstractList.add(AbstractList.java:<span class="number">108</span>)</span><br><span class="line">at com.sue.jump.service.test1.Test2.main(Test2.java:<span class="number">24</span>)</span><br></pre></td></tr></table></figure>
<p>会直接报<code>UnsupportedOperationException</code>异常。</p>
<p>为什么呢？</p>
<p>答：使用<strong><em>Arrays.asList</em></strong>方法转换后的<strong><em>ArrayList</em></strong>，是<strong><em>Arrays</em></strong>类的内部类，并非<strong><em>java.util</em></strong>包下我们常用的<strong><em>ArrayList</em></strong>。</p>
<p>Arrays类的内部ArrayList类，它没有实现父类的add和remove方法,用的是父类AbstractList的默认实现。</p>
<p>我们看看<strong><em>AbstractList</em></strong>是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该类的<strong><em>add</em></strong>和<strong><em>remove</em></strong>方法直接抛异常了，因此调用Arrays类的内部ArrayList类的add和remove方法，同样会抛异常。</p>
<p>说实话，Java代码优化是一个比较大的话题，它里面可以优化的点非常多，我没办法一一列举完。在这里只能抛砖引玉，介绍一下比较常见的知识点，更全面的内容，需要小伙伴们自己去思考和探索。</p>
<p>这篇文章写了很久，花了很多时间和心思，如果你看了文章有些收获，记得给我点赞鼓励一下喔。</p>
<p>bye</p>
<p><br /></p>
]]></content>
      <categories>
        <category>代码优化</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>java常用第三方工具库</title>
    <url>/2023/06/04/java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%BA%93/</url>
    <content><![CDATA[<p><br /></p>
<h1 id="1-java自带工具方法"><a href="#1-java自带工具方法" class="headerlink" title="1. java自带工具方法 "></a>1. java自带工具方法 </h1><p>jdk本身自带很多工具库，比如util包下，rt扩展下的，collectios带s的集合工具类，string自身的substring，isEmpty等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zrj.tool.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java自带utils</span></span><br><span class="line"><span class="comment"> * jdk自带util工具类有很多</span></span><br><span class="line"><span class="comment"> * Collections 集合工具类</span></span><br><span class="line"><span class="comment"> * String的substring等 *</span></span><br><span class="line"><span class="comment"> * Date类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zrj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> V1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * List集合测试工具</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * List集合转换成以指定字符拼接的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ListAppendUtils</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如何把list集合拼接成以逗号分隔的字符串 a,b,c</span></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList( <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一种方法，可以用stream流</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">join</span> <span class="operator">=</span> list.stream().collect( Collectors.joining( <span class="string">&quot;,&quot;</span> ) );</span><br><span class="line">        System.out.println( join ); <span class="comment">// 输出 a,b,c</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种方法，其实String也有join方法可以实现这个功能</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">join2</span> <span class="operator">=</span> String.join( <span class="string">&quot;,&quot;</span>, list );</span><br><span class="line">        System.out.println( join2 ); <span class="comment">// 输出 a,b,c</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个List集合取交集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ListIntersectionUtils</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list1.add( <span class="string">&quot;a&quot;</span> );</span><br><span class="line">        list1.add( <span class="string">&quot;b&quot;</span> );</span><br><span class="line">        list1.add( <span class="string">&quot;c&quot;</span> );</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list2.add( <span class="string">&quot;a&quot;</span> );</span><br><span class="line">        list2.add( <span class="string">&quot;b&quot;</span> );</span><br><span class="line">        list2.add( <span class="string">&quot;d&quot;</span> );</span><br><span class="line">        <span class="comment">// 取交集</span></span><br><span class="line">        list1.retainAll( list2 );</span><br><span class="line">        System.out.println( list1 ); <span class="comment">// 输出[a, b]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个List集合合并，会重复</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ListUnionUtils</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list1.add( <span class="string">&quot;a&quot;</span> );</span><br><span class="line">        list1.add( <span class="string">&quot;b&quot;</span> );</span><br><span class="line">        list1.add( <span class="string">&quot;c&quot;</span> );</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list2.add( <span class="string">&quot;a&quot;</span> );</span><br><span class="line">        list2.add( <span class="string">&quot;b&quot;</span> );</span><br><span class="line">        list2.add( <span class="string">&quot;d&quot;</span> );</span><br><span class="line">        <span class="comment">// 取交集</span></span><br><span class="line">        list1.addAll( list2 );</span><br><span class="line">        System.out.println( list1 ); <span class="comment">// 输出[a, b, c, a, b, d]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较两个字符串是否相等，忽略大小写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compareIgnoreCaseUtils</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">strA</span> <span class="operator">=</span> <span class="string">&quot;helloword&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">strB</span> <span class="operator">=</span> <span class="string">&quot;HELLOWORD&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (strA.equalsIgnoreCase( strB )) &#123;</span><br><span class="line">            System.out.println( <span class="string">&quot;strA相等strB&quot;</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较两个对象是否相等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compareObjectUtils</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">strA</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">strB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaUtils</span>();</span><br><span class="line">        <span class="comment">// 如果strA为null就会报空指针，NullPointerException</span></span><br><span class="line">        <span class="comment">//if (strA.equals( strB )) &#123;</span></span><br><span class="line">        <span class="comment">//    System.out.println( &quot;strA 等于 strB&quot; );</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这种方式可以避免空指针问题</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> Objects.equals( strA, strB );</span><br><span class="line">        System.out.println( result );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="2-apache-commons工具类库"><a href="#2-apache-commons工具类库" class="headerlink" title="2. apache commons工具类库"></a>2. apache commons工具类库</h1><p>apache commons是最强大的，也是使用最广泛的工具类库，里面的子库非常多，下面介绍几个最常用的。</p>
<h2 id="2-1-commons-lang，java-lang的增强版"><a href="#2-1-commons-lang，java-lang的增强版" class="headerlink" title="2.1 commons-lang，java.lang的增强版"></a>2.1 commons-lang，java.lang的增强版</h2><p>建议使用commons-lang3，优化了一些api，原来的commons-lang已停止更新。Maven依赖是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zrj.tool.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.DateFormatUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.DateUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.tuple.ImmutablePair;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.tuple.ImmutableTriple;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * apache commons工具类库</span></span><br><span class="line"><span class="comment"> * commons-lang，java.lang的增强版</span></span><br><span class="line"><span class="comment"> * 建议使用commons-lang3，优化了一些api，原来的commons-lang已停止更新</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zrj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> V1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsLangUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传参CharSequence类型是String、StringBuilder、StringBuffer的父类，都可以直接下面方法判空.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commonLang3Utils</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * commonStringUtils</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commonStringUtils</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//首字母转成大写</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;yyds&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">capitalize</span> <span class="operator">=</span> StringUtils.capitalize( str );</span><br><span class="line">        System.out.println( capitalize ); <span class="comment">// 输出 Yyds</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//重复拼接字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> StringUtils.repeat( <span class="string">&quot;ab&quot;</span>, <span class="number">6</span> );</span><br><span class="line">        System.out.println( str1 ); <span class="comment">// 输出abab</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 格式化日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DateFormatUtils</span><span class="params">()</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="comment">// Date类型转String类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> DateFormatUtils.format( <span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span> );</span><br><span class="line">        System.out.println( date ); <span class="comment">// 输出 2021-05-01 01:01:01</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// String类型转Date类型</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> DateUtils.parseDate( <span class="string">&quot;2021-05-01 01:01:01&quot;</span>, <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span> );</span><br><span class="line">        System.out.println( date1 );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算一个小时后的日期</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> DateUtils.addHours( <span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="number">1</span> );</span><br><span class="line">        System.out.println( date2 );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包装临时对象</span></span><br><span class="line"><span class="comment">     * 当一个方法需要返回两个及以上字段时，我们一般会封装成一个临时对象返回，现在有了Pair和Triple就不需要了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ObjectUtils</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回两个字段</span></span><br><span class="line">        ImmutablePair&lt;Integer, String&gt; pair = ImmutablePair.of( <span class="number">1</span>, <span class="string">&quot;jerry&quot;</span> );</span><br><span class="line">        System.out.println( pair.getLeft() + <span class="string">&quot;,&quot;</span> + pair.getRight() ); <span class="comment">// 输出 1,jerry</span></span><br><span class="line">        <span class="comment">// 返回三个字段</span></span><br><span class="line">        ImmutableTriple&lt;Integer, String, Date&gt; triple = ImmutableTriple.of( <span class="number">1</span>, <span class="string">&quot;jerry&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>() );</span><br><span class="line">        System.out.println( triple.getLeft() + <span class="string">&quot;,&quot;</span> + triple.getMiddle() + <span class="string">&quot;,&quot;</span> + triple.getRight() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-2-commons-collections-集合工具类"><a href="#2-2-commons-collections-集合工具类" class="headerlink" title="2.2 commons-collections 集合工具类"></a>2.2 commons-collections 集合工具类</h2><p>Maven依赖是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zrj.tool.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.CollectionUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.DateFormatUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.DateUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.tuple.ImmutablePair;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.tuple.ImmutableTriple;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * apache commons工具类库</span></span><br><span class="line"><span class="comment"> * commons-collections 集合工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zrj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> V1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsCollectionsUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集合判空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">(<span class="keyword">final</span> Collection&lt;?&gt; coll)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> coll == <span class="literal">null</span> || coll.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isNotEmpty</span><span class="params">(<span class="keyword">final</span> Collection&lt;?&gt; coll)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !isEmpty( coll );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;String&gt; listA;</span><br><span class="line">    <span class="keyword">private</span> Collection&lt;String&gt; listB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个集合取交集</span></span><br><span class="line">    Collection&lt;String&gt; collection1 = CollectionUtils.retainAll( listA, listB );</span><br><span class="line">    <span class="comment">// 两个集合取并集</span></span><br><span class="line">    Collection&lt;String&gt; collection2 = CollectionUtils.union( listA, listB );</span><br><span class="line">    <span class="comment">// 两个集合取差集</span></span><br><span class="line">    Collection&lt;String&gt; collection3 = CollectionUtils.subtract( listA, listB );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-3-common-beanutils-操作对象"><a href="#2-3-common-beanutils-操作对象" class="headerlink" title="2.3 common-beanutils 操作对象"></a>2.3 common-beanutils 操作对象</h2><p>Maven依赖是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zrj.tool.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zrj.tool.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.beanutils.BeanUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.CollectionUtils;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * apache commons工具类库</span></span><br><span class="line"><span class="comment"> * common-beanutils 操作对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zrj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> V1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonBeanUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置对象属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beanUtils</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        BeanUtils.setProperty( user, <span class="string">&quot;id&quot;</span>, <span class="number">1</span> );</span><br><span class="line">        BeanUtils.setProperty( user, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;jerry&quot;</span> );</span><br><span class="line">        System.out.println( BeanUtils.getProperty( user, <span class="string">&quot;name&quot;</span> ) ); <span class="comment">// 输出 jerry</span></span><br><span class="line">        System.out.println( user ); <span class="comment">// 输出 &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;jerry&quot;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对象和map互转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beanMapUtils</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        BeanUtils.setProperty( user, <span class="string">&quot;id&quot;</span>, <span class="number">1</span> );</span><br><span class="line">        BeanUtils.setProperty( user, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;jerry&quot;</span> );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对象转map</span></span><br><span class="line">        Map&lt;String, String&gt; map = BeanUtils.describe( user );</span><br><span class="line">        System.out.println( map ); <span class="comment">// 输出 &#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;jerry&quot;&#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// map转对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">newUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        BeanUtils.populate( newUser, map );</span><br><span class="line">        System.out.println( newUser ); <span class="comment">// 输出 &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;jerry&quot;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-4-commons-io-文件流处理"><a href="#2-4-commons-io-文件流处理" class="headerlink" title="2.4 commons-io 文件流处理"></a>2.4 commons-io 文件流处理</h2><p>Maven依赖是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zrj.tool.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.tomcat.util.http.fileupload.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * apache commons工具类库</span></span><br><span class="line"><span class="comment"> * commons-io 文件流处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zrj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> V1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonIOUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置对象属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">IOUtils</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//File file = new File( &quot;demo1.txt&quot; );</span></span><br><span class="line">         读取文件</span><br><span class="line">        <span class="comment">//List&lt;String&gt; lines = FileUtils.readLines( file, Charset.defaultCharset() );</span></span><br><span class="line">         写入文件</span><br><span class="line">        <span class="comment">//FileUtils.writeLines( new File( &quot;demo2.txt&quot; ), lines );</span></span><br><span class="line">         复制文件</span><br><span class="line">        <span class="comment">//FileUtils.copyFile( srcFile, destFile );</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="3-Google-guava工具类库"><a href="#3-Google-guava工具类库" class="headerlink" title="3. Google guava工具类库"></a>3. Google guava工具类库</h1><p>Maven依赖是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>30.1.1-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zrj.tool.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Google guava工具类库</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zrj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> V1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoogleGuavaUtils</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createCollectionsUtils</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; emptyList = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = Lists.newArrayList( <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> );</span><br><span class="line">        System.out.println( list );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反转list</span></span><br><span class="line">        List&lt;Integer&gt; reverse = Lists.reverse( list );</span><br><span class="line">        System.out.println( reverse ); <span class="comment">// 输出 [3, 2, 1]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// list集合元素太多，可以分成若干个集合，每个集合10个元素</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; partition = Lists.partition( list, <span class="number">10</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建map</span></span><br><span class="line">        Map&lt;String, String&gt; map = Maps.newHashMap();</span><br><span class="line">        Set&lt;String&gt; set = Sets.newHashSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 黑科技集合</span></span><br><span class="line"><span class="comment">     * Multimap 一个key可以映射多个value的HashMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multiMapUtils</span><span class="params">()</span> &#123;</span><br><span class="line">        Multimap&lt;String, Integer&gt; map = ArrayListMultimap.create();</span><br><span class="line">        map.put( <span class="string">&quot;key&quot;</span>, <span class="number">1</span> );</span><br><span class="line">        map.put( <span class="string">&quot;key&quot;</span>, <span class="number">2</span> );</span><br><span class="line">        System.out.println( map ); <span class="comment">// 输出 &#123;&quot;key&quot;:[1,2]&#125;</span></span><br><span class="line"></span><br><span class="line">        Collection&lt;Integer&gt; values = map.get( <span class="string">&quot;key&quot;</span> );</span><br><span class="line">        values.stream().forEach( integer -&gt; System.out.println( integer ) );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还能返回你以前使用的臃肿的Map</span></span><br><span class="line">        Map&lt;String, Collection&lt;Integer&gt;&gt; collectionMap = map.asMap();</span><br><span class="line">        System.out.println( collectionMap.toString() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 黑科技集合</span></span><br><span class="line"><span class="comment">     *  BiMap 一种连value也不能重复的HashMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BiMapUtils</span><span class="params">()</span> &#123;</span><br><span class="line">        BiMap&lt;String, String&gt; biMap = HashBiMap.create();</span><br><span class="line">        <span class="comment">// 如果value重复，put方法会抛异常，除非用forcePut方法</span></span><br><span class="line">        biMap.put( <span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span> );</span><br><span class="line">        System.out.println( biMap ); <span class="comment">// 输出 &#123;&quot;key&quot;:&quot;value&quot;&#125;</span></span><br><span class="line">        <span class="comment">// 既然value不能重复，何不实现个翻转key/value的方法，已经有了</span></span><br><span class="line">        BiMap&lt;String, String&gt; inverse = biMap.inverse();</span><br><span class="line">        System.out.println( inverse ); <span class="comment">// 输出 &#123;&quot;value&quot;:&quot;key&quot;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 黑科技集合</span></span><br><span class="line"><span class="comment">     *   Table 一种有两个key的HashMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tableMapUtils</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 一批用户，同时按年龄和性别分组</span></span><br><span class="line">        Table&lt;Integer, String, String&gt; table = HashBasedTable.create();</span><br><span class="line">        table.put( <span class="number">18</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;jerry&quot;</span> );</span><br><span class="line">        table.put( <span class="number">18</span>, <span class="string">&quot;女&quot;</span>, <span class="string">&quot;Lily&quot;</span> );</span><br><span class="line">        System.out.println( table.get( <span class="number">18</span>, <span class="string">&quot;男&quot;</span> ) ); <span class="comment">// 输出 jerry</span></span><br><span class="line">        <span class="comment">// 这其实是一个二维的Map，可以查看行数据</span></span><br><span class="line">        Map&lt;String, String&gt; row = table.row( <span class="number">18</span> );</span><br><span class="line">        System.out.println( row ); <span class="comment">// 输出 &#123;&quot;男&quot;:&quot;jerry&quot;,&quot;女&quot;:&quot;Lily&quot;&#125;</span></span><br><span class="line">        <span class="comment">// 查看列数据</span></span><br><span class="line">        Map&lt;Integer, String&gt; column = table.column( <span class="string">&quot;男&quot;</span> );</span><br><span class="line">        System.out.println( column ); <span class="comment">// 输出 &#123;18:&quot;jerry&quot;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 黑科技集合</span></span><br><span class="line"><span class="comment">     *   Multiset 一种用来计数的Set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCountUtils</span><span class="params">()</span> &#123;</span><br><span class="line">        Multiset&lt;String&gt; multiset = HashMultiset.create();</span><br><span class="line">        multiset.add( <span class="string">&quot;apple&quot;</span> );</span><br><span class="line">        multiset.add( <span class="string">&quot;apple&quot;</span> );</span><br><span class="line">        multiset.add( <span class="string">&quot;orange&quot;</span> );</span><br><span class="line">        System.out.println( multiset.count( <span class="string">&quot;apple&quot;</span> ) ); <span class="comment">// 输出 2</span></span><br><span class="line">        <span class="comment">// 查看去重的元素</span></span><br><span class="line">        Set&lt;String&gt; set = multiset.elementSet();</span><br><span class="line">        System.out.println( set ); <span class="comment">// 输出 [&quot;orange&quot;,&quot;apple&quot;]</span></span><br><span class="line">        <span class="comment">// 还能查看没有去重的元素</span></span><br><span class="line">        Iterator&lt;String&gt; iterator = multiset.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println( iterator.next() );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还能手动设置某个元素出现的次数</span></span><br><span class="line">        multiset.setCount( <span class="string">&quot;apple&quot;</span>, <span class="number">5</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="4-Hutool工具类库"><a href="#4-Hutool工具类库" class="headerlink" title="4. Hutool工具类库"></a>4. Hutool工具类库</h1><p>最喜欢的工具包，糊涂包，难得糊涂。<br>借作者的话来介绍下hutool。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hutool是一个小而全的Java工具类库，通过静态方法封装，降低相关API的学习成本，提高工作效率，使Java拥有函数式语言般的优雅，让Java语言也可以&quot;甜甜的&quot;。</span><br><span class="line"></span><br><span class="line">Hutool中的工具方法来自每个用户的精雕细琢，它涵盖了Java开发底层代码中的方方面面，它既是大型项目开发中解决小问题的利器，也是小型项目中的效率担当；</span><br><span class="line"></span><br><span class="line">Hutool是项目中&quot;util&quot;包友好的替代，它节省了开发人员对项目中公用类和公用工具方法的封装时间，使开发专注于业务，同时可以最大限度的避免封装不完善带来的bug。</span><br></pre></td></tr></table></figure>
<p>hutool官网地址：<a href="https://www.hutool.cn/">https://www.hutool.cn/</a></p>
<p>hutool文档地址：<a href="https://www.hutool.cn/docs/#/">https://www.hutool.cn/docs/#/</a></p>
<p>包含组件官网截个图，真的很好用，特干净，极少依赖。<br><img src="https://imge.ablog168.cn/blog_img/20210702001549976.png" alt="在这里插入图片描述"></p>
<h1 id="5-json处理工具"><a href="#5-json处理工具" class="headerlink" title="5. json处理工具"></a>5. json处理工具</h1><ol>
<li><p>org.json</p>
</li>
<li><p>net.sf.json</p>
</li>
<li><p>json-simple</p>
</li>
<li><p>gson：最强大，对象，集合嵌套对象，对象与json之间转换毫无压力。</p>
</li>
<li><p>jackson：功能最全，不是最快的，但是相对稳定，功能齐全。</p>
</li>
<li><p>fastjson：问题最多，反序列化，解析还会有很多问题，只一味追求快。git上看看就呵呵了，issue1.5K！还在用说明你心真大。<br><a href="https://github.com/alibaba/fastjson">https://github.com/alibaba/fastjson</a><br><img src="https://imge.ablog168.cn/blog_img/20210707124929236.png" alt="在这里插入图片描述"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>java工具类库</category>
      </categories>
      <tags>
        <tag>hutool</tag>
        <tag>apache common</tag>
        <tag>guava</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用命令</title>
    <url>/2023/06/04/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>Linux 系统目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">├── bin -&gt; usr/bin # 用于存放二进制命令</span><br><span class="line">├── boot # 内核及引导系统程序所在的目录</span><br><span class="line">├── dev # 所有设备文件的目录（如磁盘、光驱等）</span><br><span class="line">├── etc # 配置文件默认路径、服务启动命令存放目录</span><br><span class="line">├── home # 用户家目录，root用户为/root</span><br><span class="line">├── lib -&gt; usr/lib # 32位库文件存放目录</span><br><span class="line">├── lib64 -&gt; usr/lib64 # 64位库文件存放目录</span><br><span class="line">├── media # 媒体文件存放目录</span><br><span class="line">├── mnt # 临时挂载设备目录</span><br><span class="line">├── opt # 自定义软件安装存放目录</span><br><span class="line">├── proc # 进程及内核信息存放目录</span><br><span class="line">├── root # Root用户家目录</span><br><span class="line">├── run # 系统运行时产生临时文件，存放目录</span><br><span class="line">├── sbin -&gt; usr/sbin # 系统管理命令存放目录</span><br><span class="line">├── srv # 服务启动之后需要访问的数据目录</span><br><span class="line">├── sys # 系统使用目录</span><br><span class="line">├── tmp # 临时文件目录</span><br><span class="line">├── usr # 系统命令和帮助文件目录</span><br><span class="line">└── var # 存放内容易变的文件的目录</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="一、目录操作"><a href="#一、目录操作" class="headerlink" title="一、目录操作 "></a>一、目录操作 </h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pwd				查看当前工作目录</span><br><span class="line">clear 			清除屏幕</span><br><span class="line">cd ~			当前用户目录</span><br><span class="line">cd /			根目录</span><br><span class="line">cd -			上一次访问的目录</span><br><span class="line">cd ..			上一级目录</span><br></pre></td></tr></table></figure>
<p><strong>查看目录内信息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ll				查看当前目录下内容（LL的小写）</span><br></pre></td></tr></table></figure>
<p><strong>创建目录</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir aaa		在当前目录下创建aaa目录，相对路径；</span><br><span class="line">mkdir ./bbb		在当前目录下创建bbb目录，相对路径；</span><br><span class="line">mkdir /ccc		在根目录下创建ccc目录，绝对路径；</span><br></pre></td></tr></table></figure>
<p><strong>递归创建目录（会创建里面没有的目录文件夹）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p temp/nginx </span><br></pre></td></tr></table></figure>
<p><strong>搜索命令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -name &#x27;b&#x27;		查询根目录下（包括子目录），名以b的目录和文件；</span><br><span class="line">find / -name &#x27;b*&#x27;		查询根目录下（包括子目录），名以b开头的目录和文件； </span><br><span class="line">find . -name &#x27;b&#x27;		查询当前目录下（包括子目录），名以b的目录和文件；</span><br></pre></td></tr></table></figure>
<p><strong>重命名</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv 原先目录 文件的名称   mv tomcat001 tomcat </span><br></pre></td></tr></table></figure>
<p><strong>剪切命令(有目录剪切到制定目录下，没有的话剪切为指定目录）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv	/aaa /bbb		    将根目录下的aaa目录，移动到bbb目录下(假如没有bbb目录，则重命名为bbb)；</span><br><span class="line">mv	bbbb usr/bbb		将当前目录下的bbbb目录，移动到usr目录下，并且修改名称为bbb；</span><br><span class="line">mv	bbb usr/aaa			将当前目录下的bbbb目录，移动到usr目录下，并且修改名称为aaa；</span><br></pre></td></tr></table></figure>
<p><strong>复制目录</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -r /aaa /bbb			将/目录下的aaa目录复制到/bbb目录下，在/bbb目录下的名称为aaa</span><br><span class="line">cp -r /aaa /bbb/aaa		将/目录下的aa目录复制到/bbb目录下，且修改名为aaa;</span><br></pre></td></tr></table></figure>
<p><strong>强制式删除指定目录</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf /bbb			强制删除/目录下的bbb目录。如果bbb目录中还有子目录，也会被强制删除，不会提示；</span><br></pre></td></tr></table></figure>
<p><strong>删除目录</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -r /bbb			普通删除。会询问你是否删除每一个文件</span><br><span class="line">rmdir test01		目录的删除</span><br></pre></td></tr></table></figure>
<p>查看树状目录结构</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tree test01/</span><br></pre></td></tr></table></figure>
<p><img src="https://imge.ablog168.cn/blog_img/50cfc9a5d07a410d8a49cabe470b288f.png" alt="在这里插入图片描述"></p>
<h3 id="1、批量操作"><a href="#1、批量操作" class="headerlink" title="1、批量操作"></a>1、批量操作</h3><p>需要采用<code>&#123;&#125;</code>进行参数的传入了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir &#123;dirA,dirB&#125;  # 批量创建测试目录</span><br><span class="line">touch dirA/&#123;A1,A2,A3&#125;     # dirA创建三个文件dirA/A1,dirA/A2,dirA/A3</span><br></pre></td></tr></table></figure>
<h2 id="二、文件操作"><a href="#二、文件操作" class="headerlink" title="二、文件操作"></a>二、文件操作</h2><p><strong>删除</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -r a.java		删除当前目录下的a.java文件（每次回询问是否删除y：同意）</span><br></pre></td></tr></table></figure>
<p><strong>强制删除</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf a.java		强制删除当前目录下的a.java文件</span><br><span class="line">rm -rf ./a*			强制删除当前目录下以a开头的所有文件；</span><br><span class="line">rm -rf ./*			强制删除当前目录下所有文件（慎用）；</span><br></pre></td></tr></table></figure>
<p>创建文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch testFile</span><br></pre></td></tr></table></figure>
<p>递归删除.pyc格式的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -name &#x27;*.pyc&#x27; -exec rm -rf &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p>打印当前文件夹下指定大小的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -name &quot;*&quot; -size 145800c -print</span><br></pre></td></tr></table></figure>
<p>递归删除指定大小的文件(145800)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -name &quot;*&quot; -size 145800c -exec rm -rf &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p>递归删除指定大小的文件，并打印出来</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -name &quot;*&quot; -size 145800c -print -exec rm -rf &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&quot;.&quot;</code> 表示从当前目录开始递归查找</li>
<li><code>&quot; -name &#39;*.exe&#39; &quot;</code>根据名称来查找，要查找所有以.exe结尾的文件夹或者文件</li>
<li><code>&quot; -type f &quot;</code>查找的类型为文件</li>
<li><code>&quot;-print&quot;</code> 输出查找的文件目录名</li>
<li><code>-size 145800c</code> 指定文件的大小</li>
<li><code>-exec rm -rf &#123;&#125; \;</code> 递归删除（前面查询出来的结果）</li>
</ul>
<p>split拆分文件</p>
<p>split命令：可以将一个大文件分割成很多个小文件，有时需要将文件分割成更小的片段，比如为提高可读性，生成日志等。</p>
<blockquote>
<p>b：值为每一输出档案的大小，单位为 byte。<br>-C：每一输出档中，单行的最大 byte 数。<br>-d：使用数字作为后缀。<br>-l：值为每一输出档的行数大小。<br>-a：指定后缀长度(默认为2)。</p>
</blockquote>
<p>使用split命令将上面创建的date.file文件分割成大小为10KB的小文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost split]# split -b 10k date.file </span><br><span class="line">[root@localhost split]# ls</span><br><span class="line">date.file  xaa  xab  xac  xad  xae  xaf  xag  xah  xai  xaj</span><br></pre></td></tr></table></figure>
<p>文件被分割成多个带有字母的后缀文件，如果想用数字后缀可使用-d参数，同时可以使用-a length来指定后缀的长度：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost split]# split -b 10k date.file -d -a 3</span><br><span class="line">[root@localhost split]# ls</span><br><span class="line">date.file  x000  x001  x002  x003  x004  x005  x006  x007  x008  x009</span><br></pre></td></tr></table></figure>
<p>为分割后的文件指定文件名的前缀：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost split]# split -b 10k date.file -d -a 3 split_file</span><br><span class="line">[root@localhost split]# ls</span><br><span class="line">date.file  split_file000  split_file001  split_file002  split_file003  split_file004  split_file005  split_file006  split_file007  split_file008  split_file009</span><br></pre></td></tr></table></figure>
<p>使用-l选项根据文件的行数来分割文件，例如把文件分割成每个包含10行的小文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">split -l 10 date.file</span><br></pre></td></tr></table></figure>
<h2 id="三、文件内容操作（查看日志，更改配置文件）"><a href="#三、文件内容操作（查看日志，更改配置文件）" class="headerlink" title="三、文件内容操作（查看日志，更改配置文件）"></a>三、文件内容操作（查看日志，更改配置文件）</h2><p><strong>修改文件内容</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim a.java   	进入一般模式</span><br><span class="line">i(按键)   		进入插入模式(编辑模式)</span><br><span class="line">ESC(按键)  		退出</span><br><span class="line">:wq 			保存退出（shift+：调起输入框）</span><br><span class="line">:q！			不保存退出（shift+：调起输入框）（内容有更改）(强制退出，不保留更改内容)</span><br><span class="line">:q				不保存退出（shift+：调起输入框）（没有内容更改）</span><br></pre></td></tr></table></figure>
<p><strong>文件内容的查看</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat a.java		查看a.java文件的最后一页内容；</span><br><span class="line">more a.java		从第一页开始查看a.java文件内容，按回车键一行一行进行查看，</span><br><span class="line">                    按空格键一页一页进行查看，q退出；</span><br><span class="line">less a.java		从第一页开始查看a.java文件内容，按回车键一行一行的看，</span><br><span class="line">                    按空格键一页一页的看，支持使用PageDown和PageUp翻页，q退出；</span><br></pre></td></tr></table></figure>
<p><strong>总结下more 和 less的区别:</strong></p>
<ol>
<li>less可以按键盘上下方向键显示上下内容,more不能通过上下方向键控制显示</li>
<li>less不必读整个文件，加载速度会比more更快</li>
<li>less退出后shell不会留下刚显示的内容,而more退出后会在shell上留下刚显示的内容.</li>
<li>由于more不能后退.</li>
</ol>
<p><strong>实时查看文件后几行(实时查看日志)</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -f a.java			查看a.java文件的后10行内容；</span><br></pre></td></tr></table></figure>
<p><strong>前后几行查看</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">head a.java				查看a.java文件的前10行内容；</span><br><span class="line">tail -f a.java			查看a.java文件的后10行内容；</span><br><span class="line">head -n 7 a.java		查看a.java文件的前7行内容；</span><br><span class="line">tail -n 7 a.java		查看a.java文件的后7行内容；</span><br></pre></td></tr></table></figure>
<p><strong>文件内部搜索指定的内容</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep under 123.txt			在123.txt文件中搜索under字符串，大小写敏感，显示行；</span><br><span class="line">grep -n under 123.txt		在123.txt文件中搜索under字符串，大小写敏感，显示行及行号；</span><br><span class="line">grep -v under 123.txt		在123.txt文件中搜索under字符串，大小写敏感，显示没搜索到的行；</span><br><span class="line">grep -i under 123.txt		在123.txt文件中搜索under字符串，大小写敏感，显示行；</span><br><span class="line">grep -ni under 123.txt		在123.txt文件中搜索under字符串，大小写敏感，显示行及行号；</span><br></pre></td></tr></table></figure>
<p><strong>终止当前操作</strong></p>
<p><code>Ctrl+c</code>和<code>Ctrl+z</code>都是中断命令，但是作用却不一样。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ctrl+z</span><br><span class="line">ctrl+c</span><br></pre></td></tr></table></figure>
<p><strong>Ctrl+Z</strong> 就扮演了类似的角色，将任务中断，但是任务并没有结束，在进程中只是维持挂起的状态，用户可以使用fg/bg操作前台或后台的任务，fg命令重新启动前台被中断的任务，bg命令把被中断的任务放在后台执行。<br><strong>Ctrl+C</strong>也扮演类似的角色，强制中断程序的执行。</p>
<p><strong>重定向功能</strong><br>可以使用 > 或 \&lt; 将命令的输出的命令重定向到test.txt文件中（没有则创建一个）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;Hello World&#x27; &gt; /root/test.txt</span><br></pre></td></tr></table></figure>
<h3 id="1、grep-检索文件内容"><a href="#1、grep-检索文件内容" class="headerlink" title="1、grep(检索文件内容)"></a>1、grep(检索文件内容)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep [options] pattern file</span><br></pre></td></tr></table></figure>
<ul>
<li>全称：Global Regular Expression Print。</li>
<li>作用：查找文件里符合条件的字符串。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//	从test开头文件中，查找含有start的行</span><br><span class="line">grep &quot;start&quot; test*</span><br><span class="line">// 查看包含https的行，并展示前1行(-A)，后1行(-B)</span><br><span class="line">grep -A 1 -B 1 &quot;https&quot; wget-log</span><br></pre></td></tr></table></figure>
<h3 id="2、awk-数据统计"><a href="#2、awk-数据统计" class="headerlink" title="2、awk(数据统计)"></a>2、awk(数据统计)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk [options] &#x27;cmd&#x27; file</span><br></pre></td></tr></table></figure>
<ul>
<li>一次读取一行文本，按输入分隔符进行切片，切成多个组成部分。</li>
<li>将切片直接保存在内建的变量中，$1,$2…($0表示行的全部)。</li>
<li>支持对单个切片的判断，支持循环判断，默认分隔符为空格。</li>
<li>-F 指定分隔符(默认为空格)</li>
</ul>
<p><img src="https://imge.ablog168.cn/blog_img/8aa520d43c214eceb85dd9109d11985b.png" alt="在这里插入图片描述"></p>
<p><strong>1. 将<code>email.out</code>进行切分，打印出第1/3列内容</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;print $1,$3&#125;&#x27; email.out  </span><br></pre></td></tr></table></figure>
<p><strong>2. 将<code>email.out</code>进行切分，打印出第1/3列内容</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;print $1,$3&#125;&#x27; email.out </span><br></pre></td></tr></table></figure>
<p><strong>3. 将<code>email.out</code>进行切分，当第1列为tcp,第2列为1的列，全部打印</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;$1==&quot;tcp&quot; &amp;&amp; $2==1&#123;print $0&#125;&#x27; email.out</span><br></pre></td></tr></table></figure>
<p><strong>4. 在上面的基础上将表头进行打印(NR表头)</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;($1==&quot;tcp&quot; &amp;&amp; $2==1)|| NR==1 &#123;print $0&#125;&#x27; email.out</span><br></pre></td></tr></table></figure>
<p><strong>5. 以<code>,</code>为分隔符，切分数据，并打印第二列的内容</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk -F &quot;,&quot; &#x27;&#123;print $2&#125;&#x27; test.txt</span><br></pre></td></tr></table></figure>
<p><strong>6. 将日志中第1/3列进行打印，并对第1列的数据进行分类统计</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;print $1,$3&#125;&#x27; email.out | awk &#x27;&#123;count[$1]++&#125; END &#123;for(i in count) print i &quot;\t&quot; count[i]&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="https://imge.ablog168.cn/blog_img/15d767bbcf4f4a5db0a36142829e6169.png" alt="请添加图片描述"></p>
<p><img src="https://imge.ablog168.cn/blog_img/f6cf47f790d74ec6b902f11badc61d11.png" alt="请添加图片描述"></p>
<p><strong>7. 根据逗号<code>,</code>切分数据，并将第一列存在文件<code>test01.txt</code>中</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk -F &quot;,&quot; &#x27;&#123;print $1 &gt;&gt; &quot;test01.txt&quot;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、sed-替换文件内容"><a href="#3、sed-替换文件内容" class="headerlink" title="3、sed(替换文件内容)"></a>3、sed(替换文件内容)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed [option] &#x27;sed commond&#x27; filename</span><br></pre></td></tr></table></figure>
<ul>
<li>全名Stream Editor，流编辑器</li>
<li>适合用于对文本行内容进行处理</li>
<li>sed commond为正则表达式</li>
<li>sed commond中为三个/，分别为源内容，替换后的内容</li>
</ul>
<p><strong>sed替换标记</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g # 表示行内全面替换。  </span><br><span class="line">p # 表示打印行。  </span><br><span class="line">w # 表示把行写入一个文件。  </span><br><span class="line">x # 表示互换模板块中的文本和缓冲区中的文本。  </span><br><span class="line">y # 表示把一个字符翻译为另外的字符（但是不用于正则表达式）</span><br><span class="line">\1 # 子串匹配标记</span><br><span class="line">&amp; # 已匹配字符串标记</span><br></pre></td></tr></table></figure>
<p><strong>1. 替换解析</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/^Str/String/&#x27; replace.java </span><br></pre></td></tr></table></figure>
<p><img src="https://imge.ablog168.cn/blog_img/292866c8325a4b10b413de20cde5ccb4.png" alt="请添加图片描述"></p>
<p><strong>2. 将末尾的.替换为；(转义.)</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/\.$/\;/&#x27;</span><br></pre></td></tr></table></figure>
<p><strong>3. 全文将Jack替换为me(g是全部替换,不加只替换首个)</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/Jack/me/g/ replace.java</span><br></pre></td></tr></table></figure>
<p><strong>4. 删除replace.java中的空格(d是删除)</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;/^ *$/d&#x27; replace.java</span><br></pre></td></tr></table></figure>
<p><strong>5. 删除包含Interger的行(d是删除)</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;/Interger/d&#x27; replace.java</span><br></pre></td></tr></table></figure>
<p><strong>6.多命令一起执行</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &#x27;input&#x27; 123.txt | sed &#x27;s/\&quot;//g; s/,/\n/g&#x27;</span><br></pre></td></tr></table></figure>
<p><strong>7. 替换后将数据保存在文中</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep  123.txt | sed -n &#x27;s/\&quot;//gw test01.txt&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="4、管道操作符"><a href="#4、管道操作符" class="headerlink" title="4、管道操作符|"></a>4、管道操作符<code>|</code></h3><ul>
<li>可将指令连接起来，前一个指令的输出作为后一个指令的输入</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find ~ |grep &quot;test&quot;</span><br><span class="line">find ~                //查找当前用户所有文件</span><br><span class="line">grep &quot;test&quot;            //从文件中</span><br></pre></td></tr></table></figure>
<p>使用管道注意的要点</p>
<ul>
<li>只处理前一个命令正确输出，不处理错误输出。</li>
<li>右边命令必须能够接收标准输入流，否则传递过程中数据会被抛弃</li>
<li>sed，awk，grep，cut，head，top，less，more，c，join，sort，split等</li>
</ul>
<p><strong>1.从email.log文件中查询包含error的行</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &#x27;error&#x27; email.log</span><br></pre></td></tr></table></figure>
<p><strong>2.获取到error的行,并取[]含有数字的</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &#x27;error&#x27; email.log | grep -o &#x27;\[0-9\]&#x27;</span><br></pre></td></tr></table></figure>
<p><strong>3. 并过滤掉含有当前进程</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef|grep tomcat |grep -v </span><br></pre></td></tr></table></figure>
<p><strong>4. 替换后将数据保存在文中</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep  123.txt | sed -n &#x27;s/\&quot;//gw test01.txt&#x27;</span><br></pre></td></tr></table></figure>
<p><strong>5. 将文件<code>123.txt</code>，按<code>,</code>切分，去除<code>&quot;</code>，按<code>:</code>切分后，将第一列存到文件<code>test01.txt</code>中</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &#x27;input&#x27; 123.txt | awk -F &#x27;,&#x27; &#x27;&#123;print $2&#125;&#x27; | sed &#x27;s/\&quot;//g; s/,/\n/g&#x27; | awk -F &quot;:&quot; &#x27;&#123;print $1 &gt;&gt; &quot;test01.txt&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="5、cut-数据裁剪"><a href="#5、cut-数据裁剪" class="headerlink" title="5、cut(数据裁剪)"></a>5、cut(数据裁剪)</h3><ul>
<li>从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段输出。</li>
<li>也可采用管道输入。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项参数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>-f</td>
<td>列号，提取第几列</td>
</tr>
<tr>
<td>-d</td>
<td>分隔符，按照指定分隔符分割列，默认是制表符”\t”</td>
</tr>
</tbody>
</table>
</div>
<p>文件截取</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-0-9-centos shell]# cut -d &quot;：&quot; -f 1 cut.txt </span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>管道截取</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-0-9-centos shell]# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按:分割。截取第3列</span></span><br><span class="line">[root@VM-0-9-centos shell]# echo $PATH | cut -d &quot;:&quot; -f 3</span><br><span class="line">/usr/sbin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按:分割。截取第3列之后数据</span></span><br><span class="line">[root@VM-0-9-centos shell]# echo $PATH | cut -d &quot;:&quot; -f 3-</span><br><span class="line">/usr/sbin:/usr/bin:/root/bin</span><br><span class="line">[root@VM-0-9-centos shell]# </span><br></pre></td></tr></table></figure>
<h2 id="四、系统日志位置"><a href="#四、系统日志位置" class="headerlink" title="四、系统日志位置"></a>四、系统日志位置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/redhat-release		查看操作系统版本</span><br><span class="line">/var/log/message			系统启动后的信息和错误日志，是Red Hat Linux中最常用的日志之一</span><br><span class="line">/var/log/message			系统启动后的信息和错误日志，是Red Hat Linux中最常用的日志之一 </span><br><span class="line">/var/log/secure				与安全相关的日志信息 </span><br><span class="line">/var/log/maillog			与邮件相关的日志信息 </span><br><span class="line">/var/log/cron				与定时任务相关的日志信息 </span><br><span class="line">/var/log/spooler			与UUCP和news设备相关的日志信息 </span><br><span class="line">/var/log/boot.log			守护进程启动和停止相关的日志消息 </span><br></pre></td></tr></table></figure>
<p><strong>查看某文件下的用户操作日志</strong><br>到达操作的目录下，执行下面的程序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat .bash_history</span><br></pre></td></tr></table></figure>
<h2 id="五、创建与删除软连接"><a href="#五、创建与删除软连接" class="headerlink" title="五、创建与删除软连接"></a>五、创建与删除软连接</h2><p><strong>1、创建软连接</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /usr/local/app /data</span><br></pre></td></tr></table></figure>
<p>注意：创建软连接时，data目录后不加 / (加上后是查找其下一级目录)；</p>
<p><img src="https://imge.ablog168.cn/blog_img/20191104170912257.png" alt="在这里插入图片描述"><br><strong>2、删除软连接</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf /data</span><br></pre></td></tr></table></figure>
<p>注意：取消软连接最后没有/，rm -rf 软连接。加上/是删除文件夹；</p>
<p><img src="https://imge.ablog168.cn/blog_img/20191104172803658.png" alt="在这里插入图片描述"></p>
<h2 id="六、压缩和解压缩"><a href="#六、压缩和解压缩" class="headerlink" title="六、压缩和解压缩"></a>六、压缩和解压缩</h2><p><strong>tar</strong><br><img src="https://imge.ablog168.cn/blog_img/b9c15842223742d58e62b8912548a4d5.png" alt="在这里插入图片描述"></p>
<p>tar</p>
<p>压缩(-c)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -cvf start.tar a.java b.java		//将当前目录下a.java、b.java打包</span><br><span class="line">tar -cvf start.tar ./*					//将当前目录下的所欲文件打包压缩成haha.tar文件</span><br><span class="line"></span><br><span class="line">tar -zcvf start.tar.gz a.java b.java	//将当前目录下a.java、b.java打包</span><br><span class="line">tar -zcvf start.tar.gz ./*				//将当前目录下的所欲文件打包压缩成start.tar.gz文件</span><br></pre></td></tr></table></figure>
<p>解压缩(-x)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xvf start.tar						//解压start.tar压缩包，到当前文件夹下；</span><br><span class="line">tar -xvf start.tar -C usr/local 		//（C为大写，中间无空格）</span><br><span class="line">										//解压start.tar压缩包，到/usr/local目录下；</span><br><span class="line"></span><br><span class="line">tar -zxvf start.tar.gz					//解压start.tar.gz压缩包，到当前文件夹下；</span><br><span class="line">tar -zxvf start.tar.gz -C usr/local 	//（C为大写，中间无空格）</span><br><span class="line">										//解压start.tar.gz压缩包，到/usr/local目录下；</span><br></pre></td></tr></table></figure>
<p>解压缩<code>tar.xz</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar xf node-v12.18.1-linux-x64.tar.xz</span><br></pre></td></tr></table></figure>
<p>unzip/zip</p>
<p>压缩(zip)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zip lib.zip tomcat.jar							//将单个文件压缩(lib.zip)</span><br><span class="line">zip -r lib.zip lib/								//将目录进行压缩(lib.zip)</span><br><span class="line">zip -r lib.zip tomcat-embed.jar xml-aps.jar		//将多个文件压缩为zip文件(lib.zip)	</span><br></pre></td></tr></table></figure>
<p>解压缩(unzip)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip file1.zip  								//解压一个zip格式压缩包</span><br><span class="line">unzip -d /usr/app/com.lydms.english.zip			//将`english.zip`包，解压到指定目录下`/usr/app/`</span><br></pre></td></tr></table></figure>
<h2 id="七、Linux下文件的详细信息"><a href="#七、Linux下文件的详细信息" class="headerlink" title="七、Linux下文件的详细信息"></a>七、Linux下文件的详细信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> R:Read  w:write  x: execute执行</span><br><span class="line">-rw-r--r-- 1 root root  34942 Jan 19  2018 bootstrap.jar</span><br><span class="line">前三位代表当前用户对文件权限：可以读/可以写/不能执行</span><br><span class="line">中间三位代表当前组的其他用户对当前文件的操作权限：可以读/不能写/不能执行</span><br><span class="line">后三位其他用户对当前文件权限：可以读/不能写/不能执行</span><br></pre></td></tr></table></figure>
<p><img src="https://imge.ablog168.cn/blog_img/20190925153418897.png" alt="文件"></p>
<p><strong>更改文件的权限</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod u+x web.xml （---x------）		为文件拥有者（user）添加执行权限；</span><br><span class="line">chmod g+x web.xml （------x---）		为文件拥有者所在组（group）添加执行权限；</span><br><span class="line">chmod 111 web.xml  （---x--x--x）	为所有用户分类，添加可执行权限；</span><br><span class="line">chmod 222 web.xml （--w--w--w-）		为所有用户分类，添加可写入权限；	</span><br><span class="line">chmod 444 web.xml （-r--r--r--）		为所有用户分类，添加可读取权限；</span><br></pre></td></tr></table></figure>
<p><img src="https://imge.ablog168.cn/blog_img/5cebd0bd95c6497d97cb18bcab4c8d2e.png" alt="在这里插入图片描述"></p>
<h2 id="八、常用的docker容器的命令："><a href="#八、常用的docker容器的命令：" class="headerlink" title="八、常用的docker容器的命令："></a>八、常用的docker容器的命令：</h2><p><strong>1、下载镜像</strong><br>Linux服务器下载安装包镜像命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.huaweicloud.com/elasticsearch/7.8.0/elasticsearch-7.8.0-windows-x86_64.zip</span><br></pre></td></tr></table></figure>
<p><a href="https://mirrors.huaweicloud.com/">华为开源镜像站</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://mirrors.huaweicloud.com/</span><br></pre></td></tr></table></figure>
<p><strong>2、常用命令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1、查看docker中下载好的镜像：</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">2、查询需要的容器名称：</span></span><br><span class="line">docker search mysql</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3、将需要的docker容器下载运行到本地(名称、端口号、msyql密码、ID)：</span></span><br><span class="line">docker run -di --name=first -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root 26d26dsfsd31a</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4、查看运行的docker容器：</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5、查看所有的docker容器（包括未运行的）：</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">6、停止当前运行的docker容器：</span></span><br><span class="line">docker stop first</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">7、启动docker容器：</span></span><br><span class="line">docker start first</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">8、重启docker容器：</span></span><br><span class="line">docker restart first</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">9、删除docker容器：</span></span><br><span class="line">docker rm first</span><br></pre></td></tr></table></figure>
<h2 id="九、运维常用命令"><a href="#九、运维常用命令" class="headerlink" title="九、运维常用命令"></a>九、运维常用命令</h2><h3 id="1、查看服务器端口号是否可用"><a href="#1、查看服务器端口号是否可用" class="headerlink" title="1、查看服务器端口号是否可用"></a>1、查看服务器端口号是否可用</h3><p><strong>查看服务器是否可用</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping 49.32.587.164</span><br></pre></td></tr></table></figure>
<p><strong>查看服务器指定端口是否可用</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">telnet 49.32.587.164 8093</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/lydms/article/details/113698856">Telnet安装</a></p>
<p>这是我写过的一个Linux安装Telnet的文章。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://blog.csdn.net/lydms/article/details/113698856</span><br></pre></td></tr></table></figure>
<p><strong>1、shutdown(关闭计算机)</strong></p>
<p>shutdown是最常用也是最安全的关机和重启命令，它会在关机之前调用fsck检查磁盘，其中-h和-r是最常用的参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-h：停止系统服务并关机  </span><br><span class="line">-r： 停止系统服务后重启  </span><br></pre></td></tr></table></figure>
<p>案例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shutdown -h now  --立即关机  </span><br><span class="line">shutdown -h 10:53  --到10:53关机，如果该时间小于当前时间，则到隔天  </span><br><span class="line">shutdown -h +10  --10分钟后自动关机  </span><br><span class="line">shutdown -r now  --立即重启  </span><br><span class="line">shutdown -r +30 &#x27;The System Will Reboot in 30 Mins&#x27;   --30分钟后重启并并发送通知给其它在线用户  </span><br></pre></td></tr></table></figure>
<p>强制重启</p>
<figure class="highlight plaintext"><figcaption><span>language-shell</span></figcaption><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>
<p><strong>2、查看处于各种连接状态数量(ESTABLISHED、CLOSE_WAIT、TIME_WAIT)</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -n | awk &#x27;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="https://imge.ablog168.cn/blog_img/20200710160201853.png" alt="在这里插入图片描述"><br>查看处于<code>ESTABLISHED</code>状态连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -nt | awk &#x27;&#123;if($NF==&quot;ESTABLISHED&quot;)&#123;wait[$5]++&#125;&#125;END&#123;for(i in wait) print i,wait[i]&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>查看处于<code>CLOSE_WAIT</code>状态连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -nt | awk &#x27;&#123;if($NF==&quot;CLOSE_WAIT&quot;)&#123;wait[$5]++&#125;&#125;END&#123;for(i in wait) print i,wait[i]&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>查看处于<code>TIME_WAIT</code>状态连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -nt | awk &#x27;&#123;if($NF==&quot;TIME_WAIT&quot;)&#123;wait[$5]++&#125;&#125;END&#123;for(i in wait) print i,wait[i]&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p><strong>3、ping命令</strong><br>对 www.lydms.com 发送 4 个 ping 包, 检查与其是否联通</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping -c 4 www.lydms.com</span><br></pre></td></tr></table></figure>
<p><strong>4、netstat 命令</strong><br><code>netstat 命令用于显示各种网络相关信息，如网络连接, 路由表, 接口状态等等;</code><br>列出所有处于监听状态的tcp端口:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -lt</span><br></pre></td></tr></table></figure>
<p>查看所有的端口信息, 包括 PID 和进程名称</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -tulpn</span><br></pre></td></tr></table></figure>
<p><strong>5、查看当前端口号占用情况</strong><br>1.用于查看某一端口的占用情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsof -i:8080</span><br></pre></td></tr></table></figure>
<p>2.显示tcp，udp的端口和进程等相关情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -tunlp</span><br></pre></td></tr></table></figure>
<p>3.指定端口号的进程情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -tunlp|grep 8080</span><br></pre></td></tr></table></figure>
<p><strong>4.查看PID进程信息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -aux |grep 28990</span><br></pre></td></tr></table></figure>
<p>根据PID，查看JVM中各线程信息(‘0x9eb’为nid值)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstack 2246|grep &#x27;0x9eb&#x27; -A 50</span><br></pre></td></tr></table></figure>
<p><strong>6、ps 命令</strong><br>过滤得到当前系统中的 ssh 进程信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps aux | grep &#x27;ssh&#x27;</span><br></pre></td></tr></table></figure>
<p><strong>7、管道命令</strong><br><code>简单来说, Linux 中管道的作用是将上一个命令的输出作为下一个命令的输入, 像 pipe 一样将各个命令串联起来执行, 管道的操作符是 |</code><br>管道命令查看当前运行的程序中，名称为java的程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef|grep java</span><br></pre></td></tr></table></figure>
<p>查看/etc/passwd文件中的root内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd | grep &#x27;root&#x27;</span><br></pre></td></tr></table></figure>
<p>查看当前系统的ip连接（Windows和Linux通用）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -an</span><br></pre></td></tr></table></figure>
<p>将sh test.sh任务放到后台，并将打印的日志输出到<code>nohup.out</code>文件中，<strong>终端不再能够接收任何输入（标准输入）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup sh test.sh  &amp;</span><br></pre></td></tr></table></figure>
<p>将sh test.sh任务放到后台，并将打印的日志输出到<code>test.out</code>文件中，<strong>终端不再能够接收任何输入（标准输入）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup sh test.sh &gt;&gt; test.out  &amp;</span><br></pre></td></tr></table></figure>
<p>将sh test.sh任务放到后台，并将打印的日志输出到nohup.out文件中，<strong>终端能够接收任何输入</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup sh test.sh  &amp;</span><br></pre></td></tr></table></figure>
<p>8、添加Host地址<br>打开配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure>
<p>在打开的文件中添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">49.235.32.164 www.lydms.com</span><br></pre></td></tr></table></figure>
<p>保存文件后，重启网络</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init.d/network restart</span><br></pre></td></tr></table></figure>
<p>重新加载成功：<br><img src="https://imge.ablog168.cn/blog_img/20200921141541487.jpg" alt="在这里插入图片描述"></p>
<h2 id="十、yum常用命令"><a href="#十、yum常用命令" class="headerlink" title="十、yum常用命令"></a>十、yum常用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install iptables-services		下载并安装iptables</span><br><span class="line">yum list					列出当前系统中安装的所有包</span><br><span class="line">yum search package_name		在rpm仓库中搜寻软件包</span><br><span class="line">yum update package_name.rpm		更新当前系统中所有安装的rpm包</span><br><span class="line">yum update package_name		更新一个rpm包</span><br><span class="line">yum remove package_name		删除一个rpm包</span><br><span class="line">yum clean all				删除所有缓存的包和头文件</span><br></pre></td></tr></table></figure>
<h2 id="十一、其他命令"><a href="#十一、其他命令" class="headerlink" title="十一、其他命令"></a>十一、其他命令</h2><h3 id="1、xargs"><a href="#1、xargs" class="headerlink" title="1、xargs"></a>1、xargs</h3><p>给其他命令传递参数的一个过滤器</p>
<p><strong>补充说明</strong></p>
<p><strong>xargs 命令</strong> 是给其他命令传递参数的一个过滤器，也是组合多个命令的一个工具。它擅长将标准输入数据转换成命令行参数，xargs 能够处理管道或者 stdin 并将其转换成特定命令的命令参数。xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。xargs 的默认命令是 echo，空格是默认定界符。这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。xargs 是构建单行命令的重要组件之一。</p>
<p><strong>xargs 命令用法</strong></p>
<p>xargs 用作替换工具，读取输入数据重新格式化后输出。</p>
<p><code>-n</code>：指定每行输出数量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat test.txt | xargs -n3</span><br><span class="line">a b c</span><br><span class="line">d e f</span><br><span class="line">g h i</span><br><span class="line">j k l</span><br><span class="line">m n o</span><br></pre></td></tr></table></figure>
<p><code>-d</code>：按指定内容分隔文本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-0-9-centos ~] echo &quot;nameXnameXnameXname&quot; | xargs -dX</span><br><span class="line">name name name name</span><br></pre></td></tr></table></figure>
<p><code>-l</code>：文本命令替换</p>
<p>xargs 的一个 选项 -I ，使用 -I 指定一个替换字符串{}，这个字符串在 xargs 扩展时会被替换掉，当 -I 与 xargs 结合使用，每一个参数命令都会被执行一次：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls *.jpg | xargs -n1 -I cp &#123;&#125; /data/images</span><br></pre></td></tr></table></figure>
<p><code>-t</code>：将执行的命令，打印出来</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-t echo&#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls * |xargs -t -n1 -I &#123;&#125; cp -r &#123;&#125; /root/ddd/ echo&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>结合使用—-指定X切分，并每行2个</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-0-9-centos ~] echo &quot;nameXnameXnameXname&quot; | xargs -dX -n2</span><br><span class="line">name name</span><br><span class="line">name name</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>查看历史使用命令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">history</span><br></pre></td></tr></table></figure>
<p>过滤与<code>es</code>相关命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">history | grep es</span><br></pre></td></tr></table></figure>
<p><strong>查看占用资源</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -au		占用的资源是从进程启动开始，计算的平均占用资源，比如cpu等</span><br><span class="line">top			实时占用的资源；</span><br></pre></td></tr></table></figure>
<p><strong>查看当前目录所占存储</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">du -lh			查看当前文件下各文件夹占用存储空间</span><br><span class="line">du -sh			查看当前文件夹所占存储空间</span><br><span class="line">du --max-depth=&lt;目录层数&gt; 	超过指定层数的目录后，予以忽略。</span><br><span class="line">du --max-depth=1 			只查看当前目录下文件占用的存储空间</span><br></pre></td></tr></table></figure>
<p><strong>管道命令：</strong><br>根据项目查看进程，更加PID查看项目，以及项目路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef 						查看所有的进程</span><br><span class="line">ps -ef | grep mysql			查看mysql相关的进程</span><br></pre></td></tr></table></figure>
<p>通过进程PID查看所占用的端口号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -nap |grep 进程ID(PID)</span><br></pre></td></tr></table></figure>
<p><strong>查看Linux下系统存储使用率</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h			查看系统硬盘使用情况</span><br></pre></td></tr></table></figure>
<p><strong>杀死进程(根据PID)</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill -9 2630		进程pid</span><br></pre></td></tr></table></figure>
<p><strong>关闭防火墙</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service iptables stop      临时关闭防火墙</span><br><span class="line">chkconfig iptables off     防火墙开启不启动</span><br><span class="line">service iptables status    查看防火墙状态</span><br></pre></td></tr></table></figure>
<p><strong>开机启动选项</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msconfig					查看开机启动选项</span><br><span class="line">chkconfig					查看开机启动服务列表</span><br></pre></td></tr></table></figure>
<p><strong>查看MySQL服务的程序的状态</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service mysql start        开启MySQL    </span><br><span class="line">service mysql status       查看MySQL的状态    </span><br><span class="line">service mysql stop         关闭MySQL    </span><br></pre></td></tr></table></figure>
<p><strong>查看系统变量</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $USER   输出某个变量</span><br><span class="line">set	         输出所有变量</span><br></pre></td></tr></table></figure>
<h3 id="2、curl语法"><a href="#2、curl语法" class="headerlink" title="2、curl语法"></a>2、curl语法</h3><p><strong>GET请求</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl &quot;http://www.wangchujiang.com&quot;</span><br></pre></td></tr></table></figure>
<p><strong>POST请求</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 普通文本</span></span><br><span class="line">curl -d&#x27;login=emma＆password=123&#x27; -X POST https://wangchujiang.com/login</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> Json格式</span></span><br><span class="line">curl -l -H &quot;Content-type: application/json&quot; -X POST -d &#x27;&#123;&quot;phone&quot;:&quot;13521389587&quot;,&quot;password&quot;:&quot;test&quot;&#125;&#x27; http://wangchujiang.com/apis/users.json</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>详细可以看我写的另一篇：<a href="https://blog.csdn.net/lydms/article/details/127655845">curl语法整理</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://blog.csdn.net/lydms/article/details/127655845</span><br></pre></td></tr></table></figure>
<h3 id="3、查询支持解析器"><a href="#3、查询支持解析器" class="headerlink" title="3、查询支持解析器"></a>3、查询支持解析器</h3><p>Centos默认的解析器是<code>bash</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure>
<p>列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Centos默认的解析器是bash</span></span><br><span class="line">/bin/bash</span><br><span class="line">/sbin/nologin</span><br><span class="line">/usr/bin/sh</span><br><span class="line">/usr/bin/bash</span><br><span class="line">/usr/sbin/nologin</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/csh</span><br></pre></td></tr></table></figure>
<p><img src="https://imge.ablog168.cn/blog_img/3624493cd41a411e9a4724402bf1e5c3.png" alt="在这里插入图片描述"><br>指定解析器执行<br>脚本以<code>#!/bin/bash</code>开头（指定解析器)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;helloworld&quot;</span><br></pre></td></tr></table></figure>
<h2 id="十二、Linux内核优化"><a href="#十二、Linux内核优化" class="headerlink" title="十二、Linux内核优化"></a>十二、Linux内核优化</h2><p>打开配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br></pre></td></tr></table></figure>
<p>加载新的配置(需开启防火墙iptables，否则会报错)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/lldsn/p/10489593.html">收藏的详情地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://www.cnblogs.com/lldsn/p/10489593.html</span><br></pre></td></tr></table></figure>
<h2 id="十三、用户权限操作"><a href="#十三、用户权限操作" class="headerlink" title="十三、用户权限操作"></a>十三、用户权限操作</h2><h3 id="1、用户操作"><a href="#1、用户操作" class="headerlink" title="1、用户操作"></a>1、用户操作</h3><p>添加用户<code>sum</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd --d /usr/sum -m sum</span><br></pre></td></tr></table></figure>
<p>关于useradd的某些参数：</p>
<p><strong>-u：</strong> 指定 UID，这个 UID 必须是大于等于500，并没有其他用户占用的 UID</p>
<p><strong>-g：</strong> 指定默认组，可以是 GID 或者 GROUPNAME，同样也必须真实存在</p>
<p><strong>-G：</strong> 指定额外组</p>
<p><strong>-c：</strong> 指定用户的注释信息</p>
<p><strong>-d：</strong> 指定用户的家目录</p>
<p>已创建的用户<code>sum</code>设置密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">passwd sum</span><br></pre></td></tr></table></figure>
<p>用户添加<code>root</code>权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">visudo</span><br></pre></td></tr></table></figure>
<p>找到<code>root</code>用户权限位置<br>添加与<code>root</code>用户相同权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Allow root to run any commands anywhere</span></span></span><br><span class="line">root    ALL=(ALL)       ALL</span><br><span class="line">eses    ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure>
<p><img src="https://imge.ablog168.cn/blog_img/5e5c085c3e4649dda55ce82d405d23f9.png" alt="在这里插入图片描述"></p>
<p>新建的用户在面显示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200827143920513.png#pic_center" alt="反反复复"></p>
<p>切换下刚才添加的用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su sum</span><br></pre></td></tr></table></figure>
<p>sum: x:1000:1000:: /usr/sum :/bin/bash<br>sum: x:0:1000:: /usr/sum :/bin/bash</p>
<p>回到root用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>
<p><strong>修改已有用户信息<code>usermod</code></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">usermod 选项 用户名</span><br></pre></td></tr></table></figure>
<p><img src="https://imge.ablog168.cn/blog_img/6750ee77e3354cfaa983de3683019ad0.png" alt="请添加图片描述"></p>
<p>删除用户文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf /usr/sum</span><br></pre></td></tr></table></figure>
<p>删除用户<code>sum</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">userdel sum</span><br></pre></td></tr></table></figure>
<p><img src="https://imge.ablog168.cn/blog_img/e57effd8b85b49fd8b87b9e1c16b5f58.png" alt="请添加图片描述"></p>
<h3 id="2、添加组"><a href="#2、添加组" class="headerlink" title="2、添加组"></a>2、添加组</h3><p><strong>添加用户组</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd groupname</span><br></pre></td></tr></table></figure>
<p><img src="https://imge.ablog168.cn/blog_img/5fe1a6b1a99d406dbe90115777933fb4.png" alt="请添加图片描述"><br><strong>修改用户组</strong><br>使用者权限：管理员用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupmod 选项 用户组</span><br><span class="line">groupmod  -n new-usergroup  usergroup</span><br></pre></td></tr></table></figure>
<p>常用的选项有：</p>
<ul>
<li>-g GID 为用户组指定新的组标识号。</li>
<li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li>
<li>-n新用户组 将用户组的名字改为新名字<br><img src="https://imge.ablog168.cn/blog_img/6147e2f2c09c4bd6ad4e17decbe9a870.png" alt="在这里插入图片描述"></li>
</ul>
<p><strong>删除用户组</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupdel groupname</span><br></pre></td></tr></table></figure>
<p>可以看到自己的分组和分组id</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/group</span><br></pre></td></tr></table></figure>
<h3 id="3、sudo用户权限操作"><a href="#3、sudo用户权限操作" class="headerlink" title="3、sudo用户权限操作"></a>3、sudo用户权限操作</h3><blockquote>
<p>比如我们使用普通用户操作用户或者操作用户组、以及修改网卡配置文件的时候，需要切换到root用户才操作，此时我们可以使用sudo命令提高普通用户的操作权限，以达到操作目的</p>
</blockquote>
<p><code>sudo</code>：控制用户对系统命令的使用权限,root允许的操作。<br>通过sudo可以提高普通用户的操作权限。<br><strong>使用者权限</strong>：普通用户</p>
<p>使用root用户权限执行命令，操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo -s</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo   vi /etc/sysconfig/network-scripts/ifcfg-ens33 </span><br></pre></td></tr></table></figure>
<p><img src="https://imge.ablog168.cn/blog_img/ea77820e3298431681dc420a6263455d.png" alt="在这里插入图片描述"></p>
<h3 id="4、更换文件所有者"><a href="#4、更换文件所有者" class="headerlink" title="4、更换文件所有者"></a>4、更换文件所有者</h3><p>格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown [-R] 所有者 		文件或目录</span><br><span class="line">chown [-R] 所有者:所属组 	文件或目录</span><br></pre></td></tr></table></figure>
<p>将<code>kibana-8.3.3-linux-x86_64.tar.gz</code>所有者改为用户<code>sum</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown -R sum /usr/sum/kibana-8.3.3-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure>
<p>将<code>kibana-8.3.3-linux-x86_64.tar.gz</code>所有者改为用户<code>sum</code>、所有组改为<code>sum</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown -R sum:sum /usr/sum/kibana-8.3.3-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure>
<h2 id="十四、TOP"><a href="#十四、TOP" class="headerlink" title="十四、TOP"></a>十四、TOP</h2><p>实时占用的资源:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>
<p><img src="https://imge.ablog168.cn/blog_img/16d9a61fc63848b888ebc3ea1136db18.jpeg" alt="在这里插入图片描述"></p>
<p>top命令执行结果分为两个区域：<strong>统计信息区</strong> 和<strong>进程信息区</strong></p>
<h3 id="1、统计信息区"><a href="#1、统计信息区" class="headerlink" title="1、统计信息区"></a>1、统计信息区</h3><p><strong>TOP：任务队列信息，与uptime命令执行结果相同.</strong></p>
<ul>
<li><code>15:33:39</code>：系统时间</li>
<li><code>up 5:40</code>：主机已运行时间</li>
<li><code>2 users</code>：用户连接数（不是用户数，who命令）</li>
<li><code>load average: 1.09, 1.04, 0.98</code>：系统平均负载，统计最近1，5，15分钟的系统平均负载</li>
</ul>
<p><strong>Tasks：进程信息</strong></p>
<ul>
<li><code>123 total</code>：进程总数</li>
<li><code>3 running</code>：正在运行的进程数</li>
<li><code>120 sleeping</code>：睡眠的进程数</li>
<li><code>0 stopped</code>：停止的进程数</li>
<li><code>0 zombie</code>：僵尸进程数</li>
</ul>
<p><strong>%CPU(s)：CPU信息（当有多个CPU时，这些内容可能会超过两行）</strong></p>
<ul>
<li><code>42.1 us</code>：用户空间所占CPU百分比</li>
<li><code>2.0 sy</code>：内核空间占用CPU百分比</li>
<li><code>0.0 ni</code>：用户进程空间内改变过优先级的进程占用CPU百分比</li>
<li><code>49.2 id</code>：空闲CPU百分比</li>
<li><code>0.0 wa</code>：等待输入输出的CPU时间百分比</li>
<li><code>6.0 hi</code>：硬件CPU终端占用百分比</li>
<li><code>0.7 si</code>：软中断占用百分比</li>
<li><code>0.0 st</code>：虚拟机占用百分比</li>
</ul>
<p><strong>KiB Mem：内存信息（与第五行的信息类似与free命令类似）</strong></p>
<ul>
<li><code>3780.9 total</code>：物理内存总量</li>
<li><code>727.4 free</code>：已使用的内存总量</li>
<li><code>668.8 used</code>：空闲的内存总量（free + userd = total）</li>
<li><code>2384.7 buff/cache</code>：用作内核缓存的内存量</li>
</ul>
<p><strong>KiB：swap信息</strong></p>
<ul>
<li><code>2048.0 total</code>：交换分区总量</li>
<li><code>2.0 used</code>：已使用的交换分区总量</li>
<li><code>2046.0 free</code>：空闲交换分区总量</li>
<li><code>859.6 avail</code>：缓冲的交换区总量，内存中的内容被换出到交换区，然后又被换入到内存，但是使用过的交换区没有被覆盖，交换区的这些内容已存在于内存中的交换区的大小，相应的内存再次被换出时可不必再对交换区写入。</li>
</ul>
<h3 id="2、进程信息区"><a href="#2、进程信息区" class="headerlink" title="2、进程信息区"></a>2、进程信息区</h3><ul>
<li><p>PID:进程id</p>
</li>
<li><p>USER:进程所有者的用户名</p>
</li>
<li><p>PR:优先级</p>
</li>
<li><p>NI:nice值。负值表示高优先级，正值表示低优先级</p>
</li>
<li><p>RES:进程使用的、未被换出的物理内存的大小</p>
</li>
<li><p>%CPU:上次更新到现在的CPU时间占用百分比</p>
</li>
<li><p>%MEM:进程使用的物理内存百分比</p>
</li>
<li><p>TIME+：进程所使用的CPU时间总计，单位1/100秒</p>
</li>
<li><p>COMMAND:命令名/行</p>
</li>
<li><p>PPID:父进程id</p>
</li>
<li><p>RUSER:Real user name（看了好多，都是这样写，也不知道和user有什么区别，欢迎补充此处）</p>
</li>
<li><p>UID:进程所有者的id</p>
</li>
<li><p>VIRT:进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</p>
</li>
<li><p>GROUP:进程所有者的组名</p>
</li>
<li><p>TTY:启动进程的终端名。不是从终端启动的进程则显示为?</p>
</li>
<li><p>NI:nice值。负值表示高优先级，正值表示低优先级</p>
</li>
<li><p>P:最后使用的CPU，仅在多CPU环境下有意义</p>
</li>
<li><p>TIME:进程使用的CPU时间总计，单位秒</p>
</li>
<li><p>SWAP:进程使用的虚拟内存中被被换出的大小</p>
</li>
<li><p>CODE:可执行代码占用的物理内存大小</p>
</li>
<li><p>DATA:可执行代码以外的部分（数据段+栈）占用的物理内存大小</p>
</li>
<li><p>SHR:共享内存大小</p>
</li>
<li><p>nFLT:页面错误次数</p>
</li>
<li><p>nDRT:最后一次写入到现在，被修改过的页面数</p>
</li>
<li><p>S:进程状态（D=不可中断的睡眠状态，R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程）</p>
</li>
<li><p>WCHAN:若该进程在睡眠，则显示睡眠中的系统函数名</p>
</li>
<li><p>Flags:任务标志</p>
</li>
</ul>
<h2 id="十五、文件安装"><a href="#十五、文件安装" class="headerlink" title="十五、文件安装"></a>十五、文件安装</h2><h3 id="1、文件下载-lrzsz"><a href="#1、文件下载-lrzsz" class="headerlink" title="1、文件下载(lrzsz)"></a>1、文件下载(lrzsz)</h3><p>下载文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y lrzsz</span><br></pre></td></tr></table></figure>
<p>上传文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rz</span><br></pre></td></tr></table></figure>
<p>保存文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sz</span><br></pre></td></tr></table></figure>
<h2 id="十六、文章PDF版本"><a href="#十六、文章PDF版本" class="headerlink" title="十六、文章PDF版本"></a>十六、文章PDF版本</h2><p><a href="https://download.csdn.net/download/weixin_44624117/79721103">1、2022-02-08</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://download.csdn.net/download/weixin_44624117/79721103</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>接口性能优化</title>
    <url>/2023/06/04/%E6%8E%A5%E5%8F%A3%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言 "></a>前言 </h2><p><strong>接口性能优化</strong>对于从事后端开发的同学来说，肯定再熟悉不过了，因为它是一个跟开发语言无关的公共问题。</p>
<p>该问题说简单也简单，说复杂也复杂。</p>
<p>有时候，只需加个索引就能解决问题。</p>
<p>有时候，需要做代码重构。</p>
<p>有时候，需要增加缓存。</p>
<p>有时候，需要引入一些中间件，比如mq。</p>
<p>有时候，需要需要分库分表。</p>
<p>有时候，需要拆分服务。</p>
<p>等等。。。</p>
<p>导致接口性能问题的原因千奇百怪，不同的项目不同的接口，原因可能也不一样。</p>
<p>本文我总结了一些行之有效的，优化接口性能的办法，给有需要的朋友一个参考。</p>
<h2 id="1-索引"><a href="#1-索引" class="headerlink" title="1.索引"></a>1.索引</h2><p>接口性能优化大家第一个想到的可能是：<code>优化索引</code>。</p>
<p>没错，优化索引的成本是最小的。</p>
<p>你通过查看线上日志或者监控报告，查到某个接口用到的某条sql语句耗时比较长。</p>
<p>这时你可能会有下面这些疑问：</p>
<ol>
<li><p>该sql语句加索引了没？</p>
</li>
<li><p>加的索引生效了没？</p>
</li>
<li><p>mysql选错索引了没？</p>
</li>
</ol>
<h3 id="1-1-没加索引"><a href="#1-1-没加索引" class="headerlink" title="1.1 没加索引"></a>1.1 没加索引</h3><p>sql语句中<code>where</code>条件的关键字段，或者<code>order by</code>后面的排序字段，忘了加索引，这个问题在项目中很常见。</p>
<p>项目刚开始的时候，由于表中的数据量小，加不加索引sql查询性能差别不大。</p>
<p>后来，随着业务的发展，表中数据量越来越多，就不得不加索引了。</p>
<p>可以通过命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> `<span class="keyword">order</span>`;</span><br></pre></td></tr></table></figure>
<p>能单独查看某张表的索引情况。</p>
<p>也可以通过命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> `<span class="keyword">order</span>`;</span><br></pre></td></tr></table></figure>
<p>查看整张表的建表语句，里面同样会显示索引情况。</p>
<p>通过<code>ALTER TABLE</code>命令可以添加索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `<span class="keyword">order</span>` <span class="keyword">ADD</span> INDEX idx_name (name);</span><br></pre></td></tr></table></figure>
<p>也可以通过<code>CREATE INDEX</code>命令添加索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> `<span class="keyword">order</span>` (name);</span><br></pre></td></tr></table></figure>
<p>不过这里有一个需要注意的地方是：想通过命令修改索引，是不行的。</p>
<p>目前在mysql中如果想要修改索引，只能先删除索引，再重新添加新的。</p>
<p>删除索引可以用<code>DROP INDEX</code>命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `<span class="keyword">order</span>` <span class="keyword">DROP</span> INDEX idx_name;</span><br></pre></td></tr></table></figure>
<p>用<code>DROP INDEX</code>命令也行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX idx_name <span class="keyword">ON</span> `<span class="keyword">order</span>`;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-索引没生效"><a href="#1-2-索引没生效" class="headerlink" title="1.2 索引没生效"></a>1.2 索引没生效</h3><p>通过上面的命令我们已经能够确认索引是有的，但它生效了没？此时你内心或许会冒出这样一个疑问。</p>
<p>那么，如何查看索引有没有生效呢？</p>
<p>答：可以使用<code>explain</code>命令，查看mysql的执行计划，它会显示索引的使用情况。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">order</span>` <span class="keyword">where</span> code<span class="operator">=</span><span class="string">&#x27;002&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="https://imge.ablog168.cn/blog_img/dca7c2a74d7a63aac31c6838cf9d47e9.png" alt=""></p>
<p>通过这几列可以判断索引使用情况，执行计划包含列的含义如下图所示</p>
<p>说实话，sql语句没有走索引，排除没有建索引之外，最大的可能性是索引失效了。</p>
<p>下面说说索引失效的常见原因：</p>
<p><img src="https://imge.ablog168.cn/blog_img/f9b73835c95c4f0670a907feb03ec2dd.png" alt=""></p>
<p>如果不是上面的这些原因，则需要再进一步排查一下其他原因。</p>
<h3 id="1-3-选错索引"><a href="#1-3-选错索引" class="headerlink" title="1.3 选错索引"></a>1.3 选错索引</h3><p>此外，你有没有遇到过这样一种情况：明明是同一条sql，只有入参不同而已。有的时候走的索引a，有的时候却走的索引b？</p>
<p>没错，有时候mysql会选错索引。</p>
<p>必要时可以使用<code>force index</code>来强制查询sql走某个索引。</p>
<p>至于为什么mysql会选错索引，后面有专门的文章介绍的，这里先留点悬念。</p>
<h2 id="2-sql优化"><a href="#2-sql优化" class="headerlink" title="2. sql优化"></a>2. sql优化</h2><p>如果优化了索引之后，也没啥效果。</p>
<p>接下来试着优化一下sql语句，因为它的改造成本相对于java代码来说也要小得多。</p>
<p>下面给大家列举了sql优化的15个小技巧：</p>
<p><img src="https://imge.ablog168.cn/blog_img/925e0cfa786393b8a0f6e2e0cea9e2a6.png" alt=""></p>
<p>正在上传…重新上传取消由于这些技巧在我之前的文章中已经详细介绍过了，在这里我就不深入了。</p>
<h2 id="3-远程调用"><a href="#3-远程调用" class="headerlink" title="3. 远程调用"></a>3. 远程调用</h2><p>很多时候，我们需要在某个接口中，调用其他服务的接口。</p>
<p>比如有这样的业务场景：</p>
<p>在用户信息查询接口中需要返回：用户名称、性别、等级、头像、积分、成长值等信息。</p>
<p>而用户名称、性别、等级、头像在用户服务中，积分在积分服务中，成长值在成长值服务中。为了汇总这些数据统一返回，需要另外提供一个对外接口服务。</p>
<p>于是，用户信息查询接口需要调用用户查询接口、积分查询接口 和 成长值查询接口，然后汇总数据统一返回。</p>
<p>调用过程如下图所示：</p>
<p><img src="https://imge.ablog168.cn/blog_img/f34dcacc97a49f1518a7017e5d1441e4.png" alt=""></p>
<p>正在上传…重新上传取消调用远程接口总耗时 530ms = 200ms + 150ms + 180ms</p>
<p>显然这种串行调用远程接口性能是非常不好的，调用远程接口总的耗时为所有的远程接口耗时之和。</p>
<p>那么如何优化远程接口性能呢？</p>
<h3 id="3-1-并行调用"><a href="#3-1-并行调用" class="headerlink" title="3.1 并行调用"></a>3.1 并行调用</h3><p>上面说到，既然串行调用多个远程接口性能很差，为什么不改成并行呢？</p>
<p>如下图所示：</p>
<p><img src="https://imge.ablog168.cn/blog_img/0211bb6c97cd98fc61d34a021d825126.png" alt=""></p>
<p>调用远程接口总耗时 200ms = 200ms（即耗时最长的那次远程接口调用）</p>
<p>在java8之前可以通过实现<code>Callable</code>接口，获取线程返回结果。</p>
<p>java8以后通过<code>CompleteFuture</code>类实现该功能。我们这里以CompleteFuture为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> UserInfo <span class="title function_">getUserInfo</span><span class="params">(Long id)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserInfo</span>();</span><br><span class="line">    <span class="type">CompletableFuture</span> <span class="variable">userFuture</span> <span class="operator">=</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        getRemoteUserAndFill(id, userInfo);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;, executor);</span><br><span class="line"></span><br><span class="line">    <span class="type">CompletableFuture</span> <span class="variable">bonusFuture</span> <span class="operator">=</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        getRemoteBonusAndFill(id, userInfo);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;, executor);</span><br><span class="line"></span><br><span class="line">    <span class="type">CompletableFuture</span> <span class="variable">growthFuture</span> <span class="operator">=</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        getRemoteGrowthAndFill(id, userInfo);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;, executor);</span><br><span class="line">    CompletableFuture.allOf(userFuture, bonusFuture, growthFuture).join();</span><br><span class="line"></span><br><span class="line">    userFuture.get();</span><br><span class="line">    bonusFuture.get();</span><br><span class="line">    growthFuture.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>温馨提醒一下，这两种方式别忘了使用线程池。示例中我用到了executor，表示自定义的线程池，为了防止高并发场景下，出现线程过多的问题。</p>
</blockquote>
<h3 id="3-2-数据异构"><a href="#3-2-数据异构" class="headerlink" title="3.2 数据异构"></a>3.2 数据异构</h3><p>上面说到的用户信息查询接口需要调用用户查询接口、积分查询接口 和 成长值查询接口，然后汇总数据统一返回。</p>
<p>那么，我们能不能把数据冗余一下，把用户信息、积分和成长值的数据统一存储到一个地方，比如：redis，存的数据结构就是用户信息查询接口所需要的内容。然后通过用户id，直接从redis中查询数据出来，不就OK了？</p>
<p>如果在高并发的场景下，为了提升接口性能，远程接口调用大概率会被去掉，而改成保存冗余数据的数据异构方案。</p>
<p><img src="https://imge.ablog168.cn/blog_img/2f9b0fec8899dbf758baa796728a056f.png" alt=""></p>
<p>但需要注意的是，如果使用了数据异构方案，就可能会出现数据一致性问题。</p>
<p>用户信息、积分和成长值有更新的话，大部分情况下，会先更新到数据库，然后同步到redis。但这种跨库的操作，可能会导致两边数据不一致的情况产生。</p>
<h2 id="4-重复调用"><a href="#4-重复调用" class="headerlink" title="4. 重复调用"></a>4. 重复调用</h2><p><code>重复调用</code>在我们的日常工作代码中可以说随处可见，但如果没有控制好，会非常影响接口的性能。</p>
<p>不信，我们一起看看。</p>
<h3 id="4-1-循环查数据库"><a href="#4-1-循环查数据库" class="headerlink" title="4.1 循环查数据库"></a>4.1 循环查数据库</h3><p>有时候，我们需要从指定的用户集合中，查询出有哪些是在数据库中已经存在的。</p>
<p>实现代码可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">queryUser</span><span class="params">(List&lt;User&gt; searchList)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(searchList)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; result = Lists.newArrayList();</span><br><span class="line">    searchList.forEach(user -&gt; result.add(userMapper.getUserById(user.getId())));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里如果有50个用户，则需要循环50次，去查询数据库。我们都知道，每查询一次数据库，就是一次远程调用。</p>
<p>如果查询50次数据库，就有50次远程调用，这是非常耗时的操作。</p>
<p>那么，我们如何优化呢？</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">queryUser</span><span class="params">(List&lt;User&gt; searchList)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(searchList)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Long&gt; ids = searchList.stream().map(User::getId).collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> userMapper.getUserByIds(ids);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提供一个根据用户id集合批量查询用户的接口，只远程调用一次，就能查询出所有的数据。</p>
<blockquote>
<p>这里有个需要注意的地方是：id集合的大小要做限制，最好一次不要请求太多的数据。要根据实际情况而定，建议控制每次请求的记录条数在500以内。</p>
</blockquote>
<h3 id="4-2-死循环"><a href="#4-2-死循环" class="headerlink" title="4.2 死循环"></a>4.2 死循环</h3><p>有些小伙伴看到这个标题，可能会感到有点意外，死循环也算？</p>
<p>代码中不是应该避免死循环吗？为啥还是会产生死循环？</p>
<p>有时候死循环是我们自己写的，例如下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(condition) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;do samething&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用了while(true)的循环调用，这种写法在<code>CAS自旋锁</code>中使用比较多。</p>
<p>当满足condition等于true的时候，则自动退出该循环。</p>
<p>如果condition条件非常复杂，一旦出现判断不正确，或者少写了一些逻辑判断，就可能在某些场景下出现死循环的问题。</p>
<p>出现死循环，大概率是开发人员人为的bug导致的，不过这种情况很容易被测出来。</p>
<blockquote>
<p>还有一种隐藏的比较深的死循环，是由于代码写的不太严谨导致的。如果用正常数据，可能测不出问题，但一旦出现异常数据，就会立即出现死循环。</p>
</blockquote>
<h3 id="4-3-无限递归"><a href="#4-3-无限递归" class="headerlink" title="4.3 无限递归"></a>4.3 无限递归</h3><p>如果想要打印某个分类的所有父分类，可以用类似这样的递归方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printCategory</span><span class="params">(Category category)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(category == <span class="literal">null</span> </span><br><span class="line">      || category.getParentId() == <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  System.out.println(<span class="string">&quot;父分类名称：&quot;</span>+ category.getName());</span><br><span class="line">  <span class="type">Category</span> <span class="variable">parent</span> <span class="operator">=</span> categoryMapper.getCategoryById(category.getParentId());</span><br><span class="line">  printCategory(parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常情况下，这段代码是没有问题的。</p>
<p>但如果某次有人误操作，把某个分类的parentId指向了它自己，这样就会出现无限递归的情况。导致接口一直不能返回数据，最终会发生堆栈溢出。</p>
<blockquote>
<p>建议写递归方法时，设定一个递归的深度，比如：分类最大等级有4级，则深度可以设置为4。然后在递归方法中做判断，如果深度大于4时，则自动返回，这样就能避免无限循环的情况。</p>
</blockquote>
<h2 id="5-异步处理"><a href="#5-异步处理" class="headerlink" title="5. 异步处理"></a>5. 异步处理</h2><p>有时候，我们接口性能优化，需要重新梳理一下业务逻辑，看看是否有设计上不太合理的地方。</p>
<p>比如有个用户请求接口中，需要做业务操作，发站内通知，和记录操作日志。为了实现起来比较方便，通常我们会将这些逻辑放在接口中同步执行，势必会对接口性能造成一定的影响。</p>
<p>接口内部流程图如下：</p>
<p><img src="https://imge.ablog168.cn/blog_img/7164115a301cb1af923e6ba6c0effbda.png" alt=""></p>
<p>这个接口表面上看起来没有问题，但如果你仔细梳理一下业务逻辑，会发现只有业务操作才是<code>核心逻辑</code>，其他的功能都是<code>非核心逻辑</code>。</p>
<blockquote>
<p>在这里有个原则就是：核心逻辑可以同步执行，同步写库。非核心逻辑，可以异步执行，异步写库。</p>
</blockquote>
<p>上面这个例子中，发站内通知和用户操作日志功能，对实时性要求不高，即使晚点写库，用户无非是晚点收到站内通知，或者运营晚点看到用户操作日志，对业务影响不大，所以完全可以异步处理。</p>
<p>通常异步主要有两种：<code>多线程</code> 和 <code>mq</code>。</p>
<h3 id="5-1-线程池"><a href="#5-1-线程池" class="headerlink" title="5.1 线程池"></a>5.1 线程池</h3><p>使用<code>线程池</code>改造之后，接口逻辑如下：</p>
<p><img src="https://imge.ablog168.cn/blog_img/30a7ba3e0cccbcb04568627b2acff36a.png" alt=""></p>
<p>发站内通知和用户操作日志功能，被提交到了两个单独的线程池中。</p>
<p>这样接口中重点关注的是业务操作，把其他的逻辑交给线程异步执行，这样改造之后，让接口性能瞬间提升了。</p>
<p>但使用线程池有个小问题就是：如果服务器重启了，或者是需要被执行的功能出现异常了，无法重试，会丢数据。</p>
<p>那么这个问题该怎么办呢？</p>
<h3 id="5-2-mq"><a href="#5-2-mq" class="headerlink" title="5.2 mq"></a>5.2 mq</h3><p>使用<code>mq</code>改造之后，接口逻辑如下：</p>
<p><img src="https://imge.ablog168.cn/blog_img/96a4a17659a85ffa055fb208add25e5f.png" alt=""></p>
<p>对于发站内通知和用户操作日志功能，在接口中并没真正实现，它只发送了mq消息到mq服务器。然后由mq消费者消费消息时，才真正的执行这两个功能。</p>
<p>这样改造之后，接口性能同样提升了，因为发送mq消息速度是很快的，我们只需关注业务操作的代码即可。</p>
<h2 id="6-避免大事务"><a href="#6-避免大事务" class="headerlink" title="6. 避免大事务"></a>6. 避免大事务</h2><p>很多小伙伴在使用spring框架开发项目时，为了方便，喜欢使用<code>@Transactional</code>注解提供事务功能。</p>
<p>没错，使用@Transactional注解这种声明式事务的方式提供事务功能，确实能少写很多代码，提升开发效率。</p>
<p>但也容易造成大事务，引发其他的问题。</p>
<p>下面用一张图看看大事务引发的问题。</p>
<p><img src="https://imge.ablog168.cn/blog_img/dd1ce4bd02f512191c2e613ffac33973.png" alt=""></p>
<p>从图中能够看出，大事务问题可能会造成接口超时，对接口的性能有直接的影响。</p>
<p>我们该如何优化大事务呢？</p>
<ol>
<li><p>少用@Transactional注解</p>
</li>
<li><p>将查询(select)方法放到事务外</p>
</li>
<li><p>事务中避免远程调用</p>
</li>
<li><p>事务中避免一次性处理太多数据</p>
</li>
<li><p>有些功能可以非事务执行</p>
</li>
<li><p>有些功能可以异步处理</p>
</li>
<li><p>锁粒度</p>
</li>
</ol>
<hr>
<p>在某些业务场景中，为了防止多个线程并发修改某个共享数据，造成数据异常。</p>
<p>为了解决并发场景下，多个线程同时修改数据，造成数据不一致的情况。通常情况下，我们会：<code>加锁</code>。</p>
<p>但如果锁加得不好，导致锁的粒度太粗，也会非常影响接口性能。</p>
<h3 id="7-1-synchronized"><a href="#7-1-synchronized" class="headerlink" title="7.1 synchronized"></a>7.1 synchronized</h3><p>在java中提供了<code>synchronized</code>关键字给我们的代码加锁。</p>
<p>通常有两种写法：<code>在方法上加锁</code> 和 <code>在代码块上加锁</code>。</p>
<p>先看看如何在方法上加锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="title function_">doSave</span><span class="params">(String fileUrl)</span> &#123;</span><br><span class="line">    mkdir();</span><br><span class="line">    uploadFile(fileUrl);</span><br><span class="line">    sendMessage(fileUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里加锁的目的是为了防止并发的情况下，创建了相同的目录，第二次会创建失败，影响业务功能。</p>
<p>但这种直接在方法上加锁，锁的粒度有点粗。因为doSave方法中的上传文件和发消息方法，是不需要加锁的。只有创建目录方法，才需要加锁。</p>
<p>我们都知道文件上传操作是非常耗时的，如果将整个方法加锁，那么需要等到整个方法执行完之后才能释放锁。显然，这会导致该方法的性能很差，变得得不偿失。</p>
<p>这时，我们可以改成在代码块上加锁了，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSave</span><span class="params">(String path,String fileUrl)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!exists(path)) &#123;</span><br><span class="line">          mkdir(path);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    uploadFile(fileUrl);</span><br><span class="line">    sendMessage(fileUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样改造之后，锁的粒度一下子变小了，只有并发创建目录功能才加了锁。而创建目录是一个非常快的操作，即使加锁对接口的性能影响也不大。</p>
<p>最重要的是，其他的上传文件和发送消息功能，任然可以并发执行。</p>
<p>当然，这种做在单机版的服务中，是没有问题的。但现在部署的生产环境，为了保证服务的稳定性，一般情况下，同一个服务会被部署在多个节点中。如果哪天挂了一个节点，其他的节点服务任然可用。</p>
<p>多节点部署避免了因为某个节点挂了，导致服务不可用的情况。同时也能分摊整个系统的流量，避免系统压力过大。</p>
<p>同时它也带来了新的问题：synchronized只能保证一个节点加锁是有效的，但如果有多个节点如何加锁呢?</p>
<p>答：这就需要使用：<code>分布式锁</code>了。目前主流的分布式锁包括：redis分布式锁、zookeeper分布式锁 和 数据库分布式锁。</p>
<p>由于zookeeper分布式锁的性能不太好，真实业务场景用的不多，这里先不讲。</p>
<p>下面聊一下redis分布式锁。</p>
<h3 id="7-2-redis分布式锁"><a href="#7-2-redis分布式锁" class="headerlink" title="7.2 redis分布式锁"></a>7.2 redis分布式锁</h3><p>在分布式系统中，由于redis分布式锁相对于更简单和高效，成为了分布式锁的首先，被我们用到了很多实际业务场景当中。</p>
<p>使用redis分布式锁的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSave</span><span class="params">(String path,String fileUrl)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(result)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!exists(path)) &#123;</span><br><span class="line">         mkdir(path);</span><br><span class="line">         uploadFile(fileUrl);</span><br><span class="line">         sendMessage(fileUrl);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">      unlock(lockKey,requestId);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟之前使用<code>synchronized</code>关键字加锁时一样，这里锁的范围也太大了，换句话说就是锁的粒度太粗，这样会导致整个方法的执行效率很低。</p>
<p>其实只有创建目录的时候，才需要加分布式锁，其余代码根本不用加锁。</p>
<p>于是，我们需要优化一下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSave</span><span class="params">(String path,String fileUrl)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">this</span>.tryLock()) &#123;</span><br><span class="line">      mkdir(path);</span><br><span class="line">   &#125;</span><br><span class="line">   uploadFile(fileUrl);</span><br><span class="line">   sendMessage(fileUrl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(result)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">      unlock(lockKey,requestId);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码将加锁的范围缩小了，只有创建目录时才加了锁。这样看似简单的优化之后，接口性能能提升很多。说不定，会有意外的惊喜喔。哈哈哈。</p>
<p>redis分布式锁虽说好用，但它在使用时，有很多注意的细节，隐藏了很多坑，如果稍不注意很容易踩中。</p>
<h3 id="7-3-数据库分布式锁"><a href="#7-3-数据库分布式锁" class="headerlink" title="7.3 数据库分布式锁"></a>7.3 数据库分布式锁</h3><p>mysql数据库中主要有三种锁：</p>
<ul>
<li><p>表锁：加锁快，不会出现死锁。但锁定粒度大，发生锁冲突的概率最高，并发度最低。</p>
</li>
<li><p>行锁：加锁慢，会出现死锁。但锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
</li>
<li><p>间隙锁：开销和加锁时间界于表锁和行锁之间。它会出现死锁，锁定粒度界于表锁和行锁之间，并发度一般。</p>
</li>
</ul>
<p>并发度越高，意味着接口性能越好。</p>
<p>所以数据库锁的优化方向是：</p>
<p>优先使用<code>行锁</code>，其次使用<code>间隙锁</code>，再其次使用<code>表锁</code>。</p>
<p>赶紧看看，你用对了没？</p>
<h2 id="8-分页处理"><a href="#8-分页处理" class="headerlink" title="8.分页处理"></a>8.分页处理</h2><p>有时候我会调用某个接口批量查询数据，比如：通过用户id批量查询出用户信息，然后给这些用户送积分。</p>
<p>但如果你一次性查询的用户数量太多了，比如一次查询2000个用户的数据。参数中传入了2000个用户的id，远程调用接口，会发现该用户查询接口经常超时。</p>
<p>调用代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; users = remoteCallUser(ids);</span><br></pre></td></tr></table></figure>
<p>众所周知，调用接口从数据库获取数据，是需要经过网络传输的。如果数据量太大，无论是获取数据的速度，还是网络传输受限于带宽，都会导致耗时时间比较长。</p>
<p>那么，这种情况要如何优化呢？</p>
<p>答：<code>分页处理</code>。</p>
<p>将一次获取所有的数据的请求，改成分多次获取，每次只获取一部分用户的数据，最后进行合并和汇总。</p>
<p>其实，处理这个问题，要分为两种场景：<code>同步调用</code> 和 <code>异步调用</code>。</p>
<h3 id="8-1-同步调用"><a href="#8-1-同步调用" class="headerlink" title="8.1 同步调用"></a>8.1 同步调用</h3><p>如果在<code>job</code>中需要获取2000个用户的信息，它要求只要能正确获取到数据就好，对获取数据的总耗时要求不太高。</p>
<p>但对每一次远程接口调用的耗时有要求，不能大于500ms，不然会有邮件预警。</p>
<p>这时，我们可以同步分页调用批量查询用户信息接口。</p>
<p>具体示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Long&gt;&gt; allIds = Lists.partition(ids,<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(List&lt;Long&gt; batchIds:allIds) &#123;</span><br><span class="line">   List&lt;User&gt; users = remoteCallUser(batchIds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中我用的<code>google</code>的<code>guava</code>工具中的<code>Lists.partition</code>方法，用它来做分页简直太好用了，不然要巴拉巴拉写一大堆分页的代码。</p>
<h3 id="8-2-异步调用"><a href="#8-2-异步调用" class="headerlink" title="8.2 异步调用"></a>8.2 异步调用</h3><p>如果是在<code>某个接口</code>中需要获取2000个用户的信息，它考虑的就需要更多一些。</p>
<p>除了需要考虑远程调用接口的耗时之外，还需要考虑该接口本身的总耗时，也不能超时500ms。</p>
<p>这时候用上面的同步分页请求远程接口，肯定是行不通的。</p>
<p>那么，只能使用<code>异步调用</code>了。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Long&gt;&gt; allIds = Lists.partition(ids,<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> List&lt;User&gt; result = Lists.newArrayList();</span><br><span class="line">allIds.stream().forEach((batchIds) -&gt; &#123;</span><br><span class="line">   CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        result.addAll(remoteCallUser(batchIds));</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">    &#125;, executor);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>使用CompletableFuture类，多个线程异步调用远程接口，最后汇总结果统一返回。</p>
<h2 id="9-加缓存"><a href="#9-加缓存" class="headerlink" title="9.加缓存"></a>9.加缓存</h2><p>解决接口性能问题，<code>加缓存</code>是一个非常高效的方法。</p>
<p>但不能为了缓存而缓存，还是要看具体的业务场景。毕竟加了缓存，会导致接口的复杂度增加，它会带来数据不一致问题。</p>
<p>在有些并发量比较低的场景中，比如用户下单，可以不用加缓存。</p>
<p>还有些场景，比如在商城首页显示商品分类的地方，假设这里的分类是调用接口获取到的数据，但页面暂时没有做静态化。</p>
<p>如果查询分类树的接口没有使用缓存，而直接从数据库查询数据，性能会非常差。</p>
<p>那么如何使用缓存呢？</p>
<h3 id="9-1-redis缓存"><a href="#9-1-redis缓存" class="headerlink" title="9.1 redis缓存"></a>9.1 redis缓存</h3><p>通常情况下，我们使用最多的缓存可能是：<code>redis</code>和<code>memcached</code>。</p>
<p>但对于java应用来说，绝大多数都是使用的redis，所以接下来我们以redis为例。</p>
<p>由于在关系型数据库，比如：mysql中，菜单是有上下级关系的。某个四级分类是某个**分类的子分类，这个**分类，又是某个二级分类的子分类，而这个二级分类，又是某个一级分类的子分类。</p>
<p>这种存储结构决定了，想一次性查出这个分类树，并非是一件非常容易的事情。这就需要使用程序递归查询了，如果分类多的话，这个递归是比较耗时的。</p>
<p>所以，如果每次都直接从数据库中查询分类树的数据，是一个非常耗时的操作。</p>
<p>这时我们可以使用缓存，大部分情况，接口都直接从缓存中获取数据。操作redis可以使用成熟的框架，比如：jedis和redisson等。</p>
<p>用jedis伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> jedis.get(key);</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isNotEmpty(json)) &#123;</span><br><span class="line">   <span class="type">CategoryTree</span> <span class="variable">categoryTree</span> <span class="operator">=</span> JsonUtil.toObject(json);</span><br><span class="line">   <span class="keyword">return</span> categoryTree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> queryCategoryTreeFromDb();</span><br></pre></td></tr></table></figure>
<p>先从redis中根据某个key查询是否有菜单数据，如果有则转换成对象，直接返回。如果redis中没有查到菜单数据，则再从数据库中查询菜单数据，有则返回。</p>
<p>此外，我们还需要有个job每隔一段时间，从数据库中查询菜单数据，更新到redis当中，这样以后每次都能直接从redis中获取菜单的数据，而无需访问数据库了。</p>
<p><img src="https://imge.ablog168.cn/blog_img/e4f042eaeb8bea02f0401462f357d1e6.png" alt=""></p>
<p>这样改造之后，能快速的提升性能。</p>
<p>但这样做性能提升不是最佳的，还有其他的方案，我们一起看看下面的内容。</p>
<h3 id="9-2-二级缓存"><a href="#9-2-二级缓存" class="headerlink" title="9.2 二级缓存"></a>9.2 二级缓存</h3><p>上面的方案是基于redis缓存的，虽说redis访问速度很快。但毕竟是一个远程调用，而且菜单树的数据很多，在网络传输的过程中，是有些耗时的。</p>
<p>有没有办法，不经过请求远程，就能直接获取到数据呢？</p>
<p>答：使用<code>二级缓存</code>，即基于内存的缓存。</p>
<p>除了自己手写的内存缓存之后，目前使用比较多的内存缓存框架有：guava、Ehcache、caffine等。</p>
<p>我们在这里以<code>caffeine</code>为例，它是spring官方推荐的。</p>
<p>第一步，引入caffeine的相关jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第二步，配置CacheManager，开启EnableCaching</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">CaffeineCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CaffeineCacheManager</span>();</span><br><span class="line">        <span class="comment">//Caffeine配置</span></span><br><span class="line">        Caffeine&lt;Object, Object&gt; caffeine = Caffeine.newBuilder()</span><br><span class="line">                <span class="comment">//最后一次写入后经过固定时间过期</span></span><br><span class="line">                .expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">                <span class="comment">//缓存的最大条数</span></span><br><span class="line">                .maximumSize(<span class="number">1000</span>);</span><br><span class="line">        cacheManager.setCaffeine(caffeine);</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步，使用Cacheable注解获取数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryService</span> &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Cacheable(value = &quot;category&quot;, key = &quot;#categoryKey&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> CategoryModel <span class="title function_">getCategory</span><span class="params">(String categoryKey)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> jedis.get(categoryKey);</span><br><span class="line">      <span class="keyword">if</span>(StringUtils.isNotEmpty(json)) &#123;</span><br><span class="line">         <span class="type">CategoryTree</span> <span class="variable">categoryTree</span> <span class="operator">=</span> JsonUtil.toObject(json);</span><br><span class="line">         <span class="keyword">return</span> categoryTree;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> queryCategoryTreeFromDb();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用categoryService.getCategory()方法时，先从caffine缓存中获取数据，如果能够获取到数据，则直接返回该数据，不进入方法体。</p>
<p>如果不能获取到数据，则再从redis中查一次数据。如果查询到了，则返回数据，并且放入caffine中。</p>
<p>如果还是没有查到数据，则直接从数据库中获取到数据，然后放到caffine缓存中。</p>
<p>具体流程图如下：</p>
<p><img src="https://imge.ablog168.cn/blog_img/0147e47190e73e4a6403f911d4522286.png" alt=""></p>
<p>该方案的性能更好，但有个缺点就是，如果数据更新了，不能及时刷新缓存。此外，如果有多台服务器节点，可能存在各个节点上数据不一样的情况。</p>
<p>由此可见，二级缓存给我们带来性能提升的同时，也带来了数据不一致的问题。使用二级缓存一定要结合实际的业务场景，并非所有的业务场景都适用。</p>
<p>但上面我列举的分类场景，是适合使用二级缓存的。因为它属于用户不敏感数据，即使出现了稍微有点数据不一致也没有关系，用户有可能都没有察觉出来。</p>
<h2 id="10-分库分表"><a href="#10-分库分表" class="headerlink" title="10. 分库分表"></a>10. 分库分表</h2><p>有时候，接口性能受限的不是别的，而是数据库。</p>
<p>当系统发展到一定的阶段，用户并发量大，会有大量的数据库请求，需要占用大量的数据库连接，同时会带来磁盘IO的性能瓶颈问题。</p>
<p>此外，随着用户数量越来越多，产生的数据也越来越多，一张表有可能存不下。由于数据量太大，sql语句查询数据时，即使走了索引也会非常耗时。</p>
<p>这时该怎么办呢？</p>
<p>答：需要做<code>分库分表</code>。</p>
<p>如下图所示：</p>
<p><img src="https://imge.ablog168.cn/blog_img/fa9cadf0e5251be5291b2fede52b1415.png" alt=""></p>
<p>图中将用户库拆分成了三个库，每个库都包含了四张用户表。</p>
<p>如果有用户请求过来的时候，先根据用户id路由到其中一个用户库，然后再定位到某张表。</p>
<p>路由的算法挺多的：</p>
<ul>
<li><p><code>根据id取模</code>，比如：id=7，有4张表，则7%4=3，模为3，路由到用户表3。</p>
</li>
<li><p><code>给id指定一个区间范围</code>，比如：id的值是0-10万，则数据存在用户表0，id的值是10-20万，则数据存在用户表1。</p>
</li>
<li><p><code>一致性hash算法</code></p>
</li>
</ul>
<p>分库分表主要有两个方向：<code>垂直</code>和<code>水平</code>。</p>
<p>说实话垂直方向（即业务方向）更简单。</p>
<p>在水平方向（即数据方向）上，分库和分表的作用，其实是有区别的，不能混为一谈。</p>
<ul>
<li><p><code>分库</code>：是为了解决数据库连接资源不足问题，和磁盘IO的性能瓶颈问题。</p>
</li>
<li><p><code>分表</code>：是为了解决单表数据量太大，sql语句查询数据时，即使走了索引也非常耗时问题。此外还可以解决消耗cpu资源问题。</p>
</li>
<li><p><code>分库分表</code>：可以解决 数据库连接资源不足、磁盘IO的性能瓶颈、检索数据耗时 和 消耗cpu资源等问题。</p>
</li>
</ul>
<p>如果在有些业务场景中，用户并发量很大，但是需要保存的数据量很少，这时可以只分库，不分表。</p>
<p>如果在有些业务场景中，用户并发量不大，但是需要保存的数量很多，这时可以只分表，不分库。</p>
<p>如果在有些业务场景中，用户并发量大，并且需要保存的数量也很多时，可以分库分表。</p>
<h2 id="11-辅助功能"><a href="#11-辅助功能" class="headerlink" title="11. 辅助功能"></a>11. 辅助功能</h2><p>优化接口性能问题，除了上面提到的这些常用方法之外，还需要配合使用一些辅助功能，因为它们真的可以帮我们提升查找问题的效率。</p>
<h3 id="11-1-开启慢查询日志"><a href="#11-1-开启慢查询日志" class="headerlink" title="11.1 开启慢查询日志"></a>11.1 开启慢查询日志</h3><p>通常情况下，为了定位sql的性能瓶颈，我们需要开启mysql的慢查询日志。把超过指定时间的sql语句，单独记录下来，方面以后分析和定位问题。</p>
<p>开启慢查询日志需要重点关注三个参数：</p>
<ul>
<li><p><code>slow_query_log</code> 慢查询开关</p>
</li>
<li><p><code>slow_query_log_file</code> 慢查询日志存放的路径</p>
</li>
<li><p><code>long_query_time</code> 超过多少秒才会记录日志</p>
</li>
</ul>
<p>通过mysql的<code>set</code>命令可以设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">set global slow_query_log=<span class="string">&#x27;ON&#x27;</span>; </span><br><span class="line">set global slow_query_log_file=<span class="string">&#x27;/usr/local/mysql/data/slow.log&#x27;</span>;</span><br><span class="line">set global long_query_time=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>设置完之后，如果某条sql的执行时间超过了2秒，会被自动记录到slow.log文件中。</p>
<p>当然也可以直接修改配置文件<code>my.cnf</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log = <span class="type">ON</span></span><br><span class="line"><span class="variable">slow_query_log_file</span> <span class="operator">=</span> /usr/local/mysql/data/slow.<span class="type">log</span></span><br><span class="line"><span class="variable">long_query_time</span> <span class="operator">=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>但这种方式需要重启mysql服务。</p>
<p>很多公司每天早上都会发一封慢查询日志的邮件，开发人员根据这些信息优化sql。</p>
<h3 id="11-2-加监控"><a href="#11-2-加监控" class="headerlink" title="11.2 加监控"></a>11.2 加监控</h3><p>为了出现sql问题时，能够让我们及时发现，我们需要对系统做<code>监控</code>。</p>
<p>目前业界使用比较多的开源监控系统是：<code>Prometheus</code>。</p>
<p>它提供了 <code>监控</code> 和 <code>预警</code> 的功能。</p>
<p>架构图如下：</p>
<p><img src="https://imge.ablog168.cn/blog_img/18836a07c93d821fdb69353e19bf8033.png" alt=""></p>
<p>我们可以用它监控如下信息：</p>
<ul>
<li><p>接口响应时间</p>
</li>
<li><p>调用第三方服务耗时</p>
</li>
<li><p>慢查询sql耗时</p>
</li>
<li><p>cpu使用情况</p>
</li>
<li><p>内存使用情况</p>
</li>
<li><p>磁盘使用情况</p>
</li>
<li><p>数据库使用情况</p>
</li>
</ul>
<p>等等。。。</p>
<p>它的界面大概长这样子：</p>
<p><img src="https://imge.ablog168.cn/blog_img/59165498e69eb7099a903a140b5f2b09.png" alt=""></p>
<p>可以看到mysql当前qps，活跃线程数，连接数，缓存池的大小等信息。</p>
<p>如果发现数据量连接池占用太多，对接口的性能肯定会有影响。</p>
<p>这时可能是代码中开启了连接忘了关，或者并发量太大了导致的，需要做进一步排查和系统优化。</p>
<p>截图中只是它一小部分功能，如果你想了解更多功能，可以访问Prometheus的官网：<a href="https://prometheus.io/">https://prometheus.io/</a></p>
<h3 id="11-3-链路跟踪"><a href="#11-3-链路跟踪" class="headerlink" title="11.3 链路跟踪"></a>11.3 链路跟踪</h3><p>有时候某个接口涉及的逻辑很多，比如：查数据库、查redis、远程调用接口，发mq消息，执行业务代码等等。</p>
<p>该接口一次请求的链路很长，如果逐一排查，需要花费大量的时间，这时候，我们已经没法用传统的办法定位问题了。</p>
<p>有没有办法解决这问题呢？</p>
<p>用分布式链路跟踪系统：<code>skywalking</code>。</p>
<p>架构图如下：</p>
<p><img src="https://imge.ablog168.cn/blog_img/0ff94382e2424701b10a1cb400272ecb.png" alt=""></p>
<p>正在上传…重新上传取消通过skywalking定位性能问题：在skywalking中可以通过<code>traceId</code>（全局唯一的id），串联一个接口请求的完整链路。可以看到整个接口的耗时，调用的远程服务的耗时，访问数据库或者redis的耗时等等，功能非常强大。</p>
<p>之前没有这个功能的时候，为了定位线上接口性能问题，我们还需要在代码中加日志，手动打印出链路中各个环节的耗时情况，然后再逐一排查。</p>
<blockquote>
<p>小伙伴们有兴趣想了解内容和更多相关学习资料的请点赞收藏+评论转发+关注我，后面会有很多干货。我有一些面试题、架构、设计类资料可以说是程序员面试必备！所有资料都整理到网盘了，需要的话欢迎下载！私信我回复【999】即可免费获取  </p>
</blockquote>
<p>如果你用过skywalking排查接口性能问题，不自觉的会爱上它的。如果你想了解更多功能，可以访问skywalking的官网：<a href="https://skywalking.apache.org/">https://skywalking.apache.org/</a></p>
]]></content>
      <categories>
        <category>代码优化</category>
      </categories>
      <tags>
        <tag>接口优化</tag>
        <tag>sql优化</tag>
      </tags>
  </entry>
  <entry>
    <title>开发小笔记(持续更新)</title>
    <url>/2023/06/05/%E5%BC%80%E5%8F%91%E5%B0%8F%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="集合操作-排序、分组、分页"><a href="#集合操作-排序、分组、分页" class="headerlink" title="集合操作(排序、分组、分页)"></a>集合操作(排序、分组、分页)</h3><details class="folding-tag" cyan><summary> 点击查看 </summary>
              <div class='content'>
              <ol><li><p>stream分组：<code>groupingBy(Function)</code>、<code>groupingBy(Function,Collector)</code>、<code>groupingBy(Function,Supplier,Collector)</code></p><ul><li><p>一个参数：一个分组器，使用提供的字段对集合元素进行分组，返回一个<code>Map&lt;字段，相同字段值的元素集&gt;</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, List&lt;Employee&gt;&gt; map = emps.stream().collect(Collectors.groupingBy(Employee::getCity));</span><br></pre></td></tr></table></figure></li><li><p>两个参数：一个是分组器，按提供的字段进行分组。一个收集器，下面举例了3种用途</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先按city分组,再对组里面的成员，统计总销售额</span></span><br><span class="line">Map&lt;String, Integer&gt; map = emps.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Employee::getCity, Collectors.summingInt(Employee::getSales)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先按城市分组，再对每个组里面的员工姓名放入Set，得到每个城市的姓氏集</span></span><br><span class="line">Map&lt;String, Set&lt;String&gt;&gt; map = emps.stream()</span><br><span class="line">    .collect(Collectors.groupingBy(Employee::getCity, Collectors.mapping(Employee::getName, Collectors.toSet())));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先按城市分组，在求分组里面销售额最大的员工</span></span><br><span class="line">Map&lt;String, Employee&gt; map = emps.stream()</span><br><span class="line">    .collect(Collectors.groupingBy(Employee::getCity,</span><br><span class="line">Collectors.collectingAndThen(Collectors.maxBy(Comparator.comparingInt(Employee::getSales)), Optional::get)));</span><br></pre></td></tr></table></figure></li><li><p>三个参数：一个分组器，一个最终类型的生产者，一个收集器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要求：要计算每个城市中人的姓氏集，并对城市名称进行排序</span></span><br><span class="line">TreeMap&lt;String, Set&lt;String&gt;&gt; map = emps.stream()</span><br><span class="line">    .collect(Collectors.groupingBy(Employee::getCity, TreeMap::<span class="keyword">new</span>, Collectors.mapping(Employee::getName, Collectors.toSet())));</span><br></pre></td></tr></table></figure></li></ul></li><li><p>stream排序：需要倒叙的话后面调用<code>reversed()</code>方法</p><ul><li><p>降序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream().sorted(Comparator.comparing(实体::get属性).reversed()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p><code>只对属性进行排序（此属性是封装类）该属性有为 null 的情况会报错,此时需要 在Comparator.comparing（）入参多加一个nullsLast()的方法</code></p></li><li><p>单个排序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">personnelList.stream()</span><br><span class="line">                .sorted(Comparator.comparing(Personnel::getId, Comparator.nullsLast(Integer::compareTo)))</span><br><span class="line">                .collect(Collectors.toList());</span><br></pre></td></tr></table></figure></li><li><p>多个排序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">personnels.stream().sorted(Comparator.comparing(Personnel::getName, Comparator.nullsLast(String::compareTo))</span><br><span class="line"> .thenComparing(Personnel::getEmail,Comparator.nullsLast(String::compareTo)))</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure></li></ul></li><li><p>stream分页</p><ul><li><p>计算总页数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">totalPage</span> <span class="operator">=</span> msgList.size()/pageSize + (msgList.size()%pageSize == <span class="number">0</span> ? <span class="number">0</span>:<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>分页</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// num：当前页，skipnum：起始数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">skipnum</span> <span class="operator">=</span> pageSize * (num - <span class="number">1</span>);</span><br><span class="line">List list= msgList.stream().skip(skipnum).limit(pageSize).collect(Collectors.toList());</span><br></pre></td></tr></table></figure></li></ul></li></ol>
              </div>
            </details>
<p><br></p>
<h3 id="LocalDate-Time-常用用法"><a href="#LocalDate-Time-常用用法" class="headerlink" title="LocalDate(Time)常用用法"></a>LocalDate(Time)常用用法</h3><details class="folding-tag" cyan><summary> 点击查看 </summary>
              <div class='content'>
              <ul><li>周第一天最后一天、月第一天最后一天</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取本月第一天</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMonthStart</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">    cal.add(Calendar.MONTH, <span class="number">0</span>);</span><br><span class="line">    cal.set(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> cal.getTime();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>).format(time) + <span class="string">&quot; 00:00:00&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取本月最后一天</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMonthEnd</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">    cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));</span><br><span class="line">    <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> cal.getTime();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>).format(time) + <span class="string">&quot; 23:59:59&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取本周的第一天</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getWeekStart</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">    cal.add(Calendar.WEEK_OF_MONTH, <span class="number">0</span>);</span><br><span class="line">    cal.set(Calendar.DAY_OF_WEEK, <span class="number">2</span>);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> cal.getTime();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>).format(time) + <span class="string">&quot; 00:00:00&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取本周的最后一天</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getWeekEnd</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">    cal.set(Calendar.DAY_OF_WEEK, cal.getActualMaximum(Calendar.DAY_OF_WEEK));</span><br><span class="line">    cal.add(Calendar.DAY_OF_WEEK, <span class="number">1</span>);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> cal.getTime();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>).format(time) + <span class="string">&quot; 23:59:59&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>申明定义</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">formatDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">2020</span>, <span class="number">2</span>, <span class="number">5</span>); <span class="comment">// 自定义</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now(); <span class="comment">// 获取当前日期</span></span><br><span class="line"></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now1</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">30</span>, <span class="number">14</span>, <span class="number">0</span> ,<span class="number">0</span>); <span class="comment">// 自定义</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now2</span> <span class="operator">=</span> LocalDateTime.now(); <span class="comment">// 获取当前时间</span></span><br></pre></td></tr></table></figure><ul><li>获取年月日</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(formatDate.getMonth()); <span class="comment">// 结果：FEBRUARY。 获取所在月份（英文）</span></span><br><span class="line">System.out.println(formatDate.getMonthValue()); <span class="comment">// 结果：2。 获取所在月份（数字）</span></span><br><span class="line">System.out.println(formatDate.getDayOfMonth()); <span class="comment">// 结果：5。 获取所在天</span></span><br></pre></td></tr></table></figure><ul><li>增减年月日：<code>plusX()</code>、<code>minusX()</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">nextDay</span> <span class="operator">=</span> formatDate.plusDays(<span class="number">1</span>);</span><br><span class="line">System.out.println(nextDay); <span class="comment">// 2020-02-06 明天</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">nextWeek</span> <span class="operator">=</span> formatDate.plusWeeks(<span class="number">1</span>);</span><br><span class="line">System.out.println(nextWeek); <span class="comment">// 2020-02-12 下周当天</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">lastMonth</span> <span class="operator">=</span> formatDate.minusMonths(<span class="number">1</span>);</span><br><span class="line">System.out.println(lastMonth); <span class="comment">// 2020-01-05 上月当天</span></span><br></pre></td></tr></table></figure><ul><li>比较先后：<code>compareTo</code>、<code>isAfter</code>、<code>isBefore</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now1</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now2</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(now1.isAfter(now2)); <span class="comment">// false now1不晚于now2</span></span><br><span class="line">System.out.println(now1.isBefore(now2)); <span class="comment">// true now1早于now2</span></span><br><span class="line">System.out.println(now1.compareTo(now2)); <span class="comment">// -1 now1早于now2</span></span><br><span class="line">System.out.println(now2.compareTo(now1)); <span class="comment">// 1 now2晚于now1</span></span><br><span class="line">System.out.println(now1.compareTo(now1)); <span class="comment">// 0 相等</span></span><br></pre></td></tr></table></figure><ul><li>本周第一天、本月第一天…</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">firstWeekDay</span> <span class="operator">=</span> formatDate.with(TemporalAdjusters.previous(DayOfWeek.MONDAY));</span><br><span class="line">System.out.println(firstWeekDay); <span class="comment">// 2020-02-03 本周第一天</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">firstMonthDay</span> <span class="operator">=</span> formatDate.with(TemporalAdjusters.firstDayOfMonth());</span><br><span class="line">System.out.println(firstMonthDay); <span class="comment">// 2020-02-01 本月第一天</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">firstYearDay</span> <span class="operator">=</span> formatDate.with(TemporalAdjusters.firstDayOfYear());</span><br><span class="line">System.out.println(firstYearDay); <span class="comment">// 2020-01-01 本年第一天</span></span><br><span class="line"><span class="comment">//获取当月第一天</span></span><br><span class="line">System.out.println(<span class="string">&quot;当月第一天：&quot;</span>+now.with(TemporalAdjusters.firstDayOfMonth()));</span><br><span class="line"><span class="comment">//获取下月第一天</span></span><br><span class="line">System.out.println(<span class="string">&quot;下月第一天：&quot;</span>+now.with(TemporalAdjusters.firstDayOfNextMonth()));</span><br><span class="line"><span class="comment">//获取明年第一天</span></span><br><span class="line">System.out.println(<span class="string">&quot;明年第一天：&quot;</span>+now.with(TemporalAdjusters.firstDayOfNextYear()));</span><br><span class="line"><span class="comment">//获取本年第一天</span></span><br><span class="line">System.out.println(<span class="string">&quot;本年第一天：&quot;</span>+now.with(TemporalAdjusters.firstDayOfYear()));</span><br><span class="line"><span class="comment">//获取当月最后一天</span></span><br><span class="line">System.out.println(<span class="string">&quot;当月最后一天：&quot;</span>+now.with(TemporalAdjusters.lastDayOfMonth()));</span><br><span class="line"><span class="comment">//获取本年最后一天</span></span><br><span class="line">System.out.println(<span class="string">&quot;本年最后一天：&quot;</span>+now.with(TemporalAdjusters.lastDayOfYear()));</span><br><span class="line"><span class="comment">//获取当月第三周星期五</span></span><br><span class="line">System.out.println(<span class="string">&quot;当月第三周星期五：&quot;</span>+now.with(TemporalAdjusters.dayOfWeekInMonth(<span class="number">3</span>, DayOfWeek.FRIDAY)));</span><br><span class="line"><span class="comment">//获取上周一</span></span><br><span class="line">System.out.println(<span class="string">&quot;上周一：&quot;</span>+now.with(TemporalAdjusters.previous(DayOfWeek.MONDAY)));</span><br><span class="line"><span class="comment">//获取下周日</span></span><br><span class="line">System.out.println(<span class="string">&quot;下周日：&quot;</span>+now.with(TemporalAdjusters.next(DayOfWeek.SUNDAY)));</span><br></pre></td></tr></table></figure><ul><li>计算两个日期的间隔天数</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">start</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2019-12-01&quot;</span>);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">end</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2020-02-05&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">days</span> <span class="operator">=</span> start.until(end, ChronoUnit.DAYS);</span><br></pre></td></tr></table></figure><ul><li>localdatatime相差时间数</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(“计算两个时间的差：”);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">end</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(now,end);</span><br><span class="line"><span class="type">long</span> <span class="variable">days</span> <span class="operator">=</span> duration.toDays(); <span class="comment">//相差的天数</span></span><br><span class="line"><span class="type">long</span> <span class="variable">hours</span> <span class="operator">=</span> duration.toHours();<span class="comment">//相差的小时数</span></span><br><span class="line"><span class="type">long</span> <span class="variable">minutes</span> <span class="operator">=</span> duration.toMinutes();<span class="comment">//相差的分钟数</span></span><br><span class="line"><span class="type">long</span> <span class="variable">millis</span> <span class="operator">=</span> duration.toMillis();<span class="comment">//相差毫秒数</span></span><br></pre></td></tr></table></figure><ul><li>时间转string</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">df</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">formatDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> formatDate.format(df);</span><br><span class="line">System.out.println(<span class="string">&quot;LocalDate =&gt; String: &quot;</span> + dateStr); <span class="comment">// 2023-01-15</span></span><br><span class="line"></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">df2</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">formatDateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">30</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">dateTimeStr</span> <span class="operator">=</span> formatDateTime.format(df2);</span><br><span class="line">System.out.println(<span class="string">&quot;String =&gt; LocalDateTime: &quot;</span> + dateTimeStr); <span class="comment">// 2023-01-30 14:00:00</span></span><br></pre></td></tr></table></figure><ul><li>string转时间</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">df</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">dateParam</span> <span class="operator">=</span> LocalDate.parse(dateStr, df);</span><br><span class="line">System.out.println(<span class="string">&quot;String =&gt; LocalDate: &quot;</span> + dateParam); <span class="comment">// 2023-01-15</span></span><br><span class="line"></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">df2</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">dateTimeParam</span> <span class="operator">=</span> LocalDateTime.parse(dateTimeStr, df2);</span><br><span class="line">System.out.println(<span class="string">&quot;String =&gt; LocalDateTime: &quot;</span> + dateTimeParam); <span class="comment">// 2023-01-30T14:00</span></span><br></pre></td></tr></table></figure><ul><li>LocalDateTime转TimeStamp</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">aa</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">Timestamp</span> <span class="variable">bb</span> <span class="operator">=</span> Timestamp.valueOf(aa);</span><br><span class="line"><span class="type">Timestamp</span> <span class="variable">cc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timestamp</span>(System.currentTimeMillis());</span><br><span class="line">System.out.println(<span class="string">&quot;LocalDateTime =&gt; Timestamp: &quot;</span> + bb); <span class="comment">// 2023-01-30 14:31:21.244</span></span><br><span class="line">System.out.println(<span class="string">&quot;获取时间戳: &quot;</span> + bb.getTime()); <span class="comment">// 1675060281244</span></span><br><span class="line">System.out.println(<span class="string">&quot;new Timestamp(): &quot;</span> + cc); <span class="comment">// 2023-01-30 14:33:41.414  </span></span><br></pre></td></tr></table></figure><ul><li>String与TimeStamp</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">dd</span> <span class="operator">=</span> <span class="string">&quot;2023-01-30 15:00:00&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;String =&gt; Timestamp: &quot;</span> + Timestamp.valueOf(dd)); <span class="comment">// 2023-01-30 15:00:00.0</span></span><br><span class="line"></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">df3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Timestamp =&gt; String: &quot;</span> + df3.format(cc)); <span class="comment">// 2023-01-30 14:40:51</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br></p>
<h3 id="时间操作工具类-直接使用"><a href="#时间操作工具类-直接使用" class="headerlink" title="时间操作工具类(直接使用)"></a>时间操作工具类(直接使用)</h3><details class="folding-tag" cyan><summary> 点击查看 </summary>
              <div class='content'>
              <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.DayOfWeek;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.ChronoUnit;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.TemporalAccessor;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.TemporalAdjusters;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示年月日时分秒，例如 2015-08-11 09:51:53.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DATETIME_PATTERN</span> <span class="operator">=</span> <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅显示年月日，例如 2015-08-11.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DATE_PATTERN</span> <span class="operator">=</span> <span class="string">&quot;yyyy-MM-dd&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅显示时分秒，例如 09:51:53.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TIME_PATTERN</span> <span class="operator">=</span> <span class="string">&quot;HH:mm:ss&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示年月日时分秒(无符号)，例如 20150811095153.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UNSIGNED_DATETIME_PATTERN</span> <span class="operator">=</span> <span class="string">&quot;yyyyMMddHHmmss&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅显示年月日(无符号)，例如 20150811.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UNSIGNED_DATE_PATTERN</span> <span class="operator">=</span> <span class="string">&quot;yyyyMMdd&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 春天;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 夏天;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 秋天;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 冬天;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 星期日;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SUNDAY</span> <span class="operator">=</span> <span class="string">&quot;星期日&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 星期一;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MONDAY</span> <span class="operator">=</span> <span class="string">&quot;星期一&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 星期二;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TUESDAY</span> <span class="operator">=</span> <span class="string">&quot;星期二&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 星期三;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WEDNESDAY</span> <span class="operator">=</span> <span class="string">&quot;星期三&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 星期四;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">THURSDAY</span> <span class="operator">=</span> <span class="string">&quot;星期四&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 星期五;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FRIDAY</span> <span class="operator">=</span> <span class="string">&quot;星期五&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 星期六;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SATURDAY</span> <span class="operator">=</span> <span class="string">&quot;星期六&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 年</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">YEAR</span> <span class="operator">=</span> <span class="string">&quot;year&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 月</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MONTH</span> <span class="operator">=</span> <span class="string">&quot;month&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 周</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WEEK</span> <span class="operator">=</span> <span class="string">&quot;week&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DAY</span> <span class="operator">=</span> <span class="string">&quot;day&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOUR</span> <span class="operator">=</span> <span class="string">&quot;hour&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MINUTE</span> <span class="operator">=</span> <span class="string">&quot;minute&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SECOND</span> <span class="operator">=</span> <span class="string">&quot;second&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前日期和时间字符串.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 日期时间字符串，例如 2015-08-11 09:51:53</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getLocalDateTimeStr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> format(LocalDateTime.now(), DATETIME_PATTERN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前日期字符串.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 日期字符串，例如2015-08-11</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getLocalDateStr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> format(LocalDate.now(), DATE_PATTERN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前时间字符串.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 时间字符串，例如 09:51:53</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getLocalTimeStr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> format(LocalTime.now(), TIME_PATTERN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前星期字符串.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 当前星期字符串，例如 星期二</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getDayOfWeekStr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> format(LocalDate.now(), <span class="string">&quot;E&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定日期是星期几</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localDate 日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 星期几</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getDayOfWeekStr</span><span class="params">(LocalDate localDate)</span> &#123;</span><br><span class="line">        String[] weekOfDays = &#123;MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> localDate.getDayOfWeek().getValue() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> weekOfDays[dayOfWeek];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取日期时间字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temporal 需要转化的日期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern  时间格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 日期时间字符串，例如 2015-08-11 09:51:53</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">format</span><span class="params">(TemporalAccessor temporal, String pattern)</span> &#123;</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(pattern);</span><br><span class="line">        <span class="keyword">return</span> dateTimeFormatter.format(temporal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日期时间字符串转换为日期时间(java.time.LocalDateTime)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localDateTimeStr 日期时间字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern          日期时间格式 例如DATETIME_PATTERN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> LocalDateTime 日期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title function_">parseLocalDateTime</span><span class="params">(String localDateTimeStr, String pattern)</span> &#123;</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(pattern);</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.parse(localDateTimeStr, dateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日期字符串转换为日期(java.time.LocalDate)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localDateStr 日期字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern      日期格式 例如DATE_PATTERN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> LocalDate 日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title function_">parseLocalDate</span><span class="params">(String localDateStr, String pattern)</span> &#123;</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(pattern);</span><br><span class="line">        <span class="keyword">return</span> LocalDate.parse(localDateStr, dateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定日期时间加上指定数量日期时间单位之后的日期时间.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localDateTime 日期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num           数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chronoUnit    日期时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> LocalDateTime 新的日期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title function_">plus</span><span class="params">(LocalDateTime localDateTime, <span class="type">int</span> num, ChronoUnit chronoUnit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> localDateTime.plus(num, chronoUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定日期时间减去指定数量日期时间单位之后的日期时间.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localDateTime 日期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num           数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chronoUnit    日期时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> LocalDateTime 新的日期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title function_">minus</span><span class="params">(LocalDateTime localDateTime, <span class="type">int</span> num, ChronoUnit chronoUnit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> localDateTime.minus(num, chronoUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ChronoUnit计算两个日期时间之间相隔日期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start      开始日期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end        结束日期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chronoUnit 日期时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> long 相隔日期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getChronoUnitBetween</span><span class="params">(LocalDateTime start, LocalDateTime end, ChronoUnit chronoUnit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(start.until(end, chronoUnit));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ChronoUnit计算两个日期之间相隔年数或月数或天数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start      开始日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end        结束日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chronoUnit 日期时间单位,(ChronoUnit.YEARS,ChronoUnit.MONTHS,ChronoUnit.WEEKS,ChronoUnit.DAYS)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> long 相隔年数或月数或天数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getChronoUnitBetween</span><span class="params">(LocalDate start, LocalDate end, ChronoUnit chronoUnit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(start.until(end, chronoUnit));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取本年第一天的日期字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 格式：yyyy-MM-dd 00:00:00</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getFirstDayOfYearStr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getFirstDayOfYearStr(LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取本年最后一天的日期字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 格式：yyyy-MM-dd 23:59:59</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getLastDayOfYearStr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getLastDayOfYearStr(LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定日期当年第一天的日期字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localDateTime 指定日期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 格式：yyyy-MM-dd 00:00:00</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getFirstDayOfYearStr</span><span class="params">(LocalDateTime localDateTime)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getFirstDayOfYearStr(localDateTime, DATETIME_PATTERN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定日期当年最后一天的日期字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localDateTime 指定日期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 格式：yyyy-MM-dd 23:59:59</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getLastDayOfYearStr</span><span class="params">(LocalDateTime localDateTime)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getLastDayOfYearStr(localDateTime, DATETIME_PATTERN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定日期当年第一天的日期字符串,带日期格式化参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localDateTime 指定日期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern       日期时间格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 格式：yyyy-MM-dd 00:00:00</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getFirstDayOfYearStr</span><span class="params">(LocalDateTime localDateTime, String pattern)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> format(localDateTime.withDayOfYear(<span class="number">1</span>).withHour(<span class="number">0</span>).withMinute(<span class="number">0</span>).withSecond(<span class="number">0</span>), pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定日期当年最后一天的日期字符串,带日期格式化参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localDateTime 指定日期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern       日期时间格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 格式：yyyy-MM-dd 23:59:59</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getLastDayOfYearStr</span><span class="params">(LocalDateTime localDateTime, String pattern)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> format(localDateTime.with(TemporalAdjusters.lastDayOfYear()).withHour(<span class="number">23</span>).withMinute(<span class="number">59</span>).withSecond(<span class="number">59</span>), pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取本月第一天的日期字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 格式：yyyy-MM-dd 00:00:00</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getFirstDayOfMonthStr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getFirstDayOfMonthStr(LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取本月最后一天的日期字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 格式：yyyy-MM-dd 23:59:59</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getLastDayOfMonthStr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getLastDayOfMonthStr(LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定日期当月第一天的日期字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localDateTime 指定日期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 格式：yyyy-MM-dd 23:59:59</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getFirstDayOfMonthStr</span><span class="params">(LocalDateTime localDateTime)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getFirstDayOfMonthStr(localDateTime, DATETIME_PATTERN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定日期当月最后一天的日期字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localDateTime 指定日期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 格式：yyyy-MM-dd 23:59:59</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getLastDayOfMonthStr</span><span class="params">(LocalDateTime localDateTime)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getLastDayOfMonthStr(localDateTime, DATETIME_PATTERN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定日期当月第一天的日期字符串,带日期格式化参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localDateTime 指定日期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 格式：yyyy-MM-dd 00:00:00</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getFirstDayOfMonthStr</span><span class="params">(LocalDateTime localDateTime, String pattern)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> format(localDateTime.withDayOfMonth(<span class="number">1</span>).withHour(<span class="number">0</span>).withMinute(<span class="number">0</span>).withSecond(<span class="number">0</span>), pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定日期当月最后一天的日期字符串,带日期格式化参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localDateTime 指定日期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern       日期时间格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 格式：yyyy-MM-dd 23:59:59</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getLastDayOfMonthStr</span><span class="params">(LocalDateTime localDateTime, String pattern)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> format(localDateTime.with(TemporalAdjusters.lastDayOfMonth()).withHour(<span class="number">23</span>).withMinute(<span class="number">59</span>).withSecond(<span class="number">59</span>), pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取本周第一天的日期字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 格式：yyyy-MM-dd 00:00:00</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getFirstDayOfWeekStr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getFirstDayOfWeekStr(LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取本周最后一天的日期字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 格式：yyyy-MM-dd 23:59:59</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getLastDayOfWeekStr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getLastDayOfWeekStr(LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定日期当周第一天的日期字符串,这里第一天为周一</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localDateTime 指定日期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 格式：yyyy-MM-dd 00:00:00</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getFirstDayOfWeekStr</span><span class="params">(LocalDateTime localDateTime)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getFirstDayOfWeekStr(localDateTime, DATETIME_PATTERN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定日期当周最后一天的日期字符串,这里最后一天为周日</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localDateTime 指定日期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 格式：yyyy-MM-dd 23:59:59</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getLastDayOfWeekStr</span><span class="params">(LocalDateTime localDateTime)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getLastDayOfWeekStr(localDateTime, DATETIME_PATTERN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定日期当周第一天的日期字符串,这里第一天为周一,带日期格式化参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localDateTime 指定日期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern       日期时间格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 格式：yyyy-MM-dd 00:00:00</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getFirstDayOfWeekStr</span><span class="params">(LocalDateTime localDateTime, String pattern)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> format(localDateTime.with(DayOfWeek.MONDAY).withHour(<span class="number">0</span>).withMinute(<span class="number">0</span>).withSecond(<span class="number">0</span>), pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定日期当周最后一天的日期字符串,这里最后一天为周日,带日期格式化参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localDateTime 指定日期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern       日期时间格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 格式：yyyy-MM-dd 23:59:59</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getLastDayOfWeekStr</span><span class="params">(LocalDateTime localDateTime, String pattern)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> format(localDateTime.with(DayOfWeek.SUNDAY).withHour(<span class="number">23</span>).withMinute(<span class="number">59</span>).withSecond(<span class="number">59</span>), pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取今天开始时间的日期字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 格式：yyyy-MM-dd 00:00:00</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getStartTimeOfDayStr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getStartTimeOfDayStr(LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取今天结束时间的日期字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 格式：yyyy-MM-dd 23:59:59</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getEndTimeOfDayStr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getEndTimeOfDayStr(LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定日期开始时间的日期字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localDateTime 指定日期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 格式：yyyy-MM-dd 00:00:00</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getStartTimeOfDayStr</span><span class="params">(LocalDateTime localDateTime)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getStartTimeOfDayStr(localDateTime, DATETIME_PATTERN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定日期结束时间的日期字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localDateTime 指定日期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 格式：yyyy-MM-dd 23:59:59</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getEndTimeOfDayStr</span><span class="params">(LocalDateTime localDateTime)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getEndTimeOfDayStr(localDateTime, DATETIME_PATTERN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定日期开始时间的日期字符串,带日期格式化参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localDateTime 指定日期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern       日期时间格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 格式：yyyy-MM-dd HH:mm:ss</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getStartTimeOfDayStr</span><span class="params">(LocalDateTime localDateTime, String pattern)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> format(localDateTime.withHour(<span class="number">0</span>).withMinute(<span class="number">0</span>).withSecond(<span class="number">0</span>), pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定日期结束时间的日期字符串,带日期格式化参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> localDateTime 指定日期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern       日期时间格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 格式：yyyy-MM-dd 23:59:59</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getEndTimeOfDayStr</span><span class="params">(LocalDateTime localDateTime, String pattern)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> format(localDateTime.withHour(<span class="number">23</span>).withMinute(<span class="number">59</span>).withSecond(<span class="number">59</span>), pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切割日期。按照周期切割成小段日期段。例如： &lt;br&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startDate 开始日期（yyyy-MM-dd）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endDate   结束日期（yyyy-MM-dd）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> period    周期（天，周，月，年）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 切割之后的日期集合</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;startDate=&quot;2019-02-28&quot;,endDate=&quot;2019-03-05&quot;,period=&quot;day&quot;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;结果为：[2019-02-28, 2019-03-01, 2019-03-02, 2019-03-03, 2019-03-04, 2019-03-05]&lt;/li&gt;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;startDate=&quot;2019-02-28&quot;,endDate=&quot;2019-03-25&quot;,period=&quot;week&quot;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;结果为：[2019-02-28,2019-03-06, 2019-03-07,2019-03-13, 2019-03-14,2019-03-20,</span></span><br><span class="line"><span class="comment">     * 2019-03-21,2019-03-25]&lt;/li&gt;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;startDate=&quot;2019-02-28&quot;,endDate=&quot;2019-05-25&quot;,period=&quot;month&quot;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;结果为：[2019-02-28,2019-02-28, 2019-03-01,2019-03-31, 2019-04-01,2019-04-30,</span></span><br><span class="line"><span class="comment">     * 2019-05-01,2019-05-25]&lt;/li&gt;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;startDate=&quot;2019-02-28&quot;,endDate=&quot;2020-05-25&quot;,period=&quot;year&quot;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;结果为：[2019-02-28,2019-12-31, 2020-01-01,2020-05-25]&lt;/li&gt;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">listDateStrs</span><span class="params">(String startDate, String endDate, String period)</span> &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(DATE_PATTERN);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">end</span> <span class="operator">=</span> LocalDate.parse(endDate, dateTimeFormatter);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">start</span> <span class="operator">=</span> LocalDate.parse(startDate, dateTimeFormatter);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">tmp</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="keyword">switch</span> (period) &#123;</span><br><span class="line">            <span class="keyword">case</span> DAY:</span><br><span class="line">                <span class="keyword">while</span> (start.isBefore(end) || start.isEqual(end)) &#123;</span><br><span class="line">                    result.add(start.toString());</span><br><span class="line">                    start = start.plusDays(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WEEK:</span><br><span class="line">                <span class="keyword">while</span> (tmp.isBefore(end) || tmp.isEqual(end)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tmp.plusDays(<span class="number">6</span>).isAfter(end)) &#123;</span><br><span class="line">                        result.add(tmp.toString() + <span class="string">&quot;,&quot;</span> + end);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.add(tmp.toString() + <span class="string">&quot;,&quot;</span> + tmp.plusDays(<span class="number">6</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    tmp = tmp.plusDays(<span class="number">7</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MONTH:</span><br><span class="line">                <span class="keyword">while</span> (tmp.isBefore(end) || tmp.isEqual(end)) &#123;</span><br><span class="line">                    <span class="type">LocalDate</span> <span class="variable">lastDayOfMonth</span> <span class="operator">=</span> tmp.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">                    <span class="keyword">if</span> (lastDayOfMonth.isAfter(end)) &#123;</span><br><span class="line">                        result.add(tmp.toString() + <span class="string">&quot;,&quot;</span> + end);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.add(tmp.toString() + <span class="string">&quot;,&quot;</span> + lastDayOfMonth);</span><br><span class="line">                    &#125;</span><br><span class="line">                    tmp = lastDayOfMonth.plusDays(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YEAR:</span><br><span class="line">                <span class="keyword">while</span> (tmp.isBefore(end) || tmp.isEqual(end)) &#123;</span><br><span class="line">                    <span class="type">LocalDate</span> <span class="variable">lastDayOfYear</span> <span class="operator">=</span> tmp.with(TemporalAdjusters.lastDayOfYear());</span><br><span class="line">                    <span class="keyword">if</span> (lastDayOfYear.isAfter(end)) &#123;</span><br><span class="line">                        result.add(tmp.toString() + <span class="string">&quot;,&quot;</span> + end);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.add(tmp.toString() + <span class="string">&quot;,&quot;</span> + lastDayOfYear);</span><br><span class="line">                    &#125;</span><br><span class="line">                    tmp = lastDayOfYear.plusDays(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br></p>
<h3 id="java连接sqlserve"><a href="#java连接sqlserve" class="headerlink" title="java连接sqlserve"></a>java连接sqlserve</h3><details class="folding-tag" cyan><summary> 点击查看 </summary>
              <div class='content'>
              <ol><li><p>maven依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sourceforge.jtds<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jtds<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>获取连接，取得结果 <code>import java.sql.*;</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java连接sqlserver</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql 要执行的sql语句</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 执行结果对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ResultSet <span class="title function_">getConnection</span><span class="params">(String sql)</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;net.sourceforge.jtds.jdbc.Driver&quot;</span>);</span><br><span class="line">        con = DriverManager.getConnection(<span class="string">&quot;jdbc:jtds:sqlserver://121.49.0.161:1433;DatabaseName=jpzjk&quot;</span>, <span class="string">&quot;sa&quot;</span>, <span class="string">&quot;123.com&quot;</span>);</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> con.createStatement();</span><br><span class="line">        rs = st.executeQuery(sql);<span class="comment">// 返回结果</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (con != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> rs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用（处理结果）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT t2.CARDNO barcode,t2.USERNAME name,t1.CREATETIME time FROM CirculateLog t1 &quot;</span> +</span><br><span class="line">            <span class="string">&quot;INNER JOIN Reader t2 ON t1.READERBARCODE=t2.BARCODE &quot;</span> +</span><br><span class="line">            <span class="string">&quot;WHERE t1.CONTROLTYPE=&#x27;J&#x27; AND t1.CREATETIME&gt;=&#x27;&quot;</span> + <span class="string">&quot;2023-05-01 00:00:00&quot;</span> + <span class="string">&quot;&#x27; &quot;</span> +</span><br><span class="line">            <span class="string">&quot;and t1.CREATETIME&lt;=&#x27;&quot;</span> + <span class="string">&quot;2023-05-01 23:59:59&quot;</span> + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="built_in">this</span>.getConnection(sql);</span><br><span class="line">   </span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">df</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    List&lt;CirculateInfoDto&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">// 结果集</span></span><br><span class="line">    <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">        <span class="type">CirculateInfoDto</span> <span class="variable">dto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CirculateInfoDto</span>();<span class="comment">// 封装为自定义对象</span></span><br><span class="line">        dto.setBarcode(rs.getString(<span class="number">1</span>));</span><br><span class="line">        dto.setName(rs.getString(<span class="number">2</span>));</span><br><span class="line">        dto.setTime(LocalDateTime.parse(rs.getString(<span class="number">3</span>).substring(<span class="number">0</span>, <span class="number">19</span>), df));</span><br><span class="line">        results.add(dto);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    System.out.println(<span class="string">&quot;封装后的接口集合：&quot;</span>+results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br></p>
<h3 id="java调用第三方接口"><a href="#java调用第三方接口" class="headerlink" title="java调用第三方接口"></a>java调用第三方接口</h3><details class="folding-tag" cyan><summary> 点击查看 </summary>
              <div class='content'>
              <p><code>利用 HttpClientBuilder创建连接对象</code></p><ol><li><p>post方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">postMethod</span><span class="params">(String url, JSONObject json)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">CloseableHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line">        <span class="type">HttpPost</span> <span class="variable">post</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(url);</span><br><span class="line">        post.addHeader(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.81 Safari/537.36&quot;</span>);</span><br><span class="line">        <span class="type">StringEntity</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringEntity</span>(json.toString());</span><br><span class="line">        s.setContentEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">//发送json数据需要设置contentType</span></span><br><span class="line">        s.setContentType(<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">        post.setEntity(s); <span class="comment">//设置请求参数</span></span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> httpClient.execute(post);</span><br><span class="line">        <span class="type">int</span> <span class="variable">statusCode</span> <span class="operator">=</span> response.getStatusLine().getStatusCode();</span><br><span class="line">        <span class="keyword">if</span> (HttpStatus.SC_OK == statusCode)&#123;</span><br><span class="line">            <span class="comment">//返回String</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> EntityUtils.toString(response.getEntity());</span><br><span class="line">            System.out.println(res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>get方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMethod</span><span class="params">(String url)</span>&#123;</span><br><span class="line">    <span class="type">CloseableHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> HttpClientBuilder.create().build();</span><br><span class="line">    <span class="type">HttpGet</span> <span class="variable">get</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(url);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//这里可以设置请求参数，token等</span></span><br><span class="line">        get.addHeader(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.81 Safari/537.36&quot;</span>);</span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> httpClient.execute(get);<span class="comment">//执行获取响应</span></span><br><span class="line">        <span class="keyword">if</span> (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK)&#123;<span class="comment">//根据状态码处理</span></span><br><span class="line">            <span class="comment">//返回字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> EntityUtils.toString(response.getEntity());</span><br><span class="line">            System.out.println(res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br></p>
<h3 id="计算地图上两坐标点距离"><a href="#计算地图上两坐标点距离" class="headerlink" title="计算地图上两坐标点距离"></a>计算地图上两坐标点距离</h3><details class="folding-tag" cyan><summary> 点击查看 </summary>
              <div class='content'>
              <ol><li><p>计算方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">EARTH_RADIUS</span> <span class="operator">=</span> <span class="number">6378.137</span>;<span class="comment">// 地球半径,单位千米</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">rad</span><span class="params">(<span class="type">double</span> d)</span> &#123;</span><br><span class="line">    <span class="comment">//角度转换成弧度</span></span><br><span class="line">    <span class="keyword">return</span> d * Math.PI / <span class="number">180.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算两个地点的距离</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lat1 第一个纬度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lng1 第一个经度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lat2 第二个纬度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lng2 第二个经度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 两个经纬度的距离</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getDistance</span><span class="params">(<span class="type">double</span> lat1, <span class="type">double</span> lng1, <span class="type">double</span> lat2, <span class="type">double</span> lng2)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">radLat1</span> <span class="operator">=</span> rad(lat1);<span class="comment">//纬度</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">radLat2</span> <span class="operator">=</span> rad(lat2);</span><br><span class="line">    <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> radLat1 - radLat2;<span class="comment">//两点纬度之差</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> rad(lng1) - rad(lng2);<span class="comment">//经度之差</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//计算两点之间距离的公式</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">2</span> * Math.asin(Math.sqrt(</span><br><span class="line">            Math.pow(Math.sin(a / <span class="number">2</span>), <span class="number">2</span>) + Math.cos(radLat1) * Math.cos(radLat2) * Math.pow(Math.sin(b / <span class="number">2</span>), <span class="number">2</span>)));</span><br><span class="line">    <span class="comment">//弧长乘地球半径（半径）</span></span><br><span class="line">    s = s * EARTH_RADIUS;</span><br><span class="line">    <span class="comment">//精确距离的数值（单位千米）</span></span><br><span class="line">    s = Math.round(s * <span class="number">10000</span>) / <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>演示使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;太原－上海：&quot;</span> + getDistance(<span class="number">37.87</span>, <span class="number">112.53</span>, <span class="number">31.22</span>, <span class="number">121.48</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;宁波－上海：&quot;</span> + getDistance(<span class="number">29.86</span>, <span class="number">121.56</span>, <span class="number">31.22</span>, <span class="number">121.48</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br></p>
<h3 id="easyexcel导入、导出"><a href="#easyexcel导入、导出" class="headerlink" title="easyexcel导入、导出"></a>easyexcel导入、导出</h3><details class="folding-tag" cyan><summary> 点击查看 </summary>
              <div class='content'>
              <ol><li><p>maven依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easyexcel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>导入、导出的操作对象</p><p><code>@ExcelProperty()就是用来设置表头的，也可以这样写：@ExcelProperty(value=&quot;名称&quot;,index=索引)，如果不需要某个字段，可以使用@ExcelIgnore注解忽略；此外@ExcelProperty()还有很多配置各种类型的表头，详情可以参考EasyExcel官方文档</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(value = &quot;user&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">//@ExcelProperty:配置表头</span></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;主键&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String yhxm;</span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;性别&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String yhxb;</span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;登陆账号&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String yhzh;</span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;登陆密码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String yhmm;</span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;出生年月&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date csrq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>导出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportRecord</span><span class="params">(SelectCardManageListParam param, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.设置response的基本数据</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="string">&quot;卡片信息&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName + <span class="string">&quot;.xlsx&quot;</span>);</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//2.查询数据</span></span><br><span class="line">        List&lt;SelectCardManageListDto&gt; data = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (param.getType() == <span class="literal">null</span> &amp;&amp; param.getIsSend() == <span class="literal">null</span> &amp;&amp; param.getStatus() == <span class="literal">null</span> &amp;&amp; (param.getKeyword() == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(param.getKeyword()))) &#123;</span><br><span class="line">            data = syncCardData;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            param.setPageSize(<span class="number">99999</span>);</span><br><span class="line">            BaseReturnDto&lt;com.example.java.tool.Page&lt;SelectCardManageListDto&gt;&gt; dto = <span class="keyword">new</span> <span class="title class_">BaseReturnDto</span>&lt;&gt;();</span><br><span class="line">            <span class="built_in">this</span>.list(param, dto);</span><br><span class="line">            data = dto.getData().getList();</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">        <span class="comment">//4，使用工具导出</span></span><br><span class="line">        EasyExcel.write(response.getOutputStream(), SelectCardManageListDto.class)</span><br><span class="line">                .sheet(<span class="string">&quot;卡片信息&quot;</span>)</span><br><span class="line">                .doWrite(data);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li>导入</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;ImportExcel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ImportExcel</span><span class="params">(MultipartFile multipartFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (multipartFile.isEmpty()) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭</span></span><br><span class="line">    <span class="comment">// 这里每次会读取3000条数据 然后返回过来 直接调用使用数据就行</span></span><br><span class="line">    EasyExcel.read(multipartFile.getInputStream(), User.class, <span class="keyword">new</span> <span class="title class_">PageReadListener</span>&lt;User&gt;(dataList -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (User user : dataList) &#123;</span><br><span class="line">            <span class="comment">//将导入的数据用mybatisPlus一个个添加进数据库</span></span><br><span class="line">            loginMapper.insert(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)).sheet().doRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>拦截器</u></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BatchJoinListener</span> <span class="keyword">extends</span> <span class="title class_">AnalysisEventListener</span>&lt;JoinTempDTO&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;JoinArmyDTO&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArmedServiceImpl armedService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BatchJoinListener</span><span class="params">(ArmedServiceImpl armedService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.armedService = armedService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(JoinTempDTO data, AnalysisContext context)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(CharSequenceUtil.isNotEmpty(data.getNumber())</span><br><span class="line">                &amp;&amp;CharSequenceUtil.isNotEmpty(data.getDay()))&#123;</span><br><span class="line">            <span class="type">JoinArmyDTO</span> <span class="variable">dto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JoinArmyDTO</span>();</span><br><span class="line"></span><br><span class="line">            String[] split = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;&#125;;</span><br><span class="line">            <span class="keyword">if</span>(data.getDay().contains(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">                split = data.getDay().split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data.getDay().contains(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                split = data.getDay().split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">m</span> <span class="operator">=</span> split[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (m.length() == <span class="number">1</span>) &#123;</span><br><span class="line">                m = <span class="string">&quot;0&quot;</span> + m;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> split[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (d.length() == <span class="number">1</span>) &#123;</span><br><span class="line">                d = <span class="string">&quot;0&quot;</span> + d;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dto.setDay(split[<span class="number">0</span>] + <span class="string">&quot;-&quot;</span> + m + <span class="string">&quot;-&quot;</span> + d);</span><br><span class="line">            dto.setNumber(data.getNumber());</span><br><span class="line">            list.add(dto);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!list.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">for</span>(JoinArmyDTO dto:list)&#123;</span><br><span class="line">                armedService.joinArmy(dto,<span class="keyword">new</span> <span class="title class_">BaseReturnDto</span>&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br></p>
<h3 id="Linux定时任务"><a href="#Linux定时任务" class="headerlink" title="Linux定时任务"></a>Linux定时任务</h3><details class="folding-tag" cyan><summary> 点击查看 </summary>
              <div class='content'>
              <ol><li><p>关于crontab</p><p>使用命令<code>rpm -qa | grep cron</code>查看系统是否已经安装有crontab软件，如显示如下图则证明已经安装crontab，若执行命令无返回值则证明尚未安装crontab。</p><p><img src="https://imge.ablog168.cn//blog_img/image-20230615143640848.png" alt="image-20230615143640848"></p><p>安装、启动、开机自启</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y vixie-cron crontabs  <span class="comment">#安装</span></span><br><span class="line"></span><br><span class="line">/sbin/service crond start <span class="comment">#启动服务</span></span><br><span class="line"> </span><br><span class="line">/sbin/service crond stop <span class="comment">#关闭服务</span></span><br><span class="line"> </span><br><span class="line">/sbin/service crond restart <span class="comment">#重启服务</span></span><br><span class="line"> </span><br><span class="line">/sbin/service crond reload <span class="comment">#重新载入配置</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>corn表达式实例</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">0 */2 * * * /sbin/service httpd restart  <span class="comment">#意思是每两个小时重启一次apache </span></span><br><span class="line"></span><br><span class="line">50 7 * * * /sbin/service sshd start  <span class="comment">#意思是每天7：50开启ssh服务 </span></span><br><span class="line"></span><br><span class="line">50 22 * * * /sbin/service sshd stop  <span class="comment">#意思是每天22：50关闭ssh服务 </span></span><br><span class="line"></span><br><span class="line">0 0 1,15 * * fsck /home  <span class="comment">#每月1号和15号检查/home 磁盘 </span></span><br><span class="line"></span><br><span class="line">1 * * * * /home/bruce/backup  <span class="comment">#每小时的第一分执行 /home/bruce/backup这个文件 </span></span><br><span class="line"></span><br><span class="line">00 03 * * 1-5 find /home <span class="string">&quot;*.xxx&quot;</span> -mtime +4 -<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;  <span class="comment">#每周一至周五3点钟，在目录/home中，查找文件名为*.xxx的文件，并删除4天前的文件。</span></span><br><span class="line"></span><br><span class="line">30 6 */10 * * <span class="built_in">ls</span>  <span class="comment">#意思是每月的1、11、21、31日是的6：30执行一次ls命令</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>每天定时重启java服务</p><p>编写sh脚本文件，如：restart-blog.sh</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment">#jdk路径，根据你自己的jdk安装位置修改</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/java/jdk1.8.0_162/bin/</span><br><span class="line"><span class="comment">#要执行的jar包路径</span></span><br><span class="line"><span class="built_in">cd</span> /home/application/govern/</span><br><span class="line"><span class="comment">#要执行的jar包名称</span></span><br><span class="line">APP_NAME=data-govern-1.0.0.jar</span><br><span class="line"><span class="comment">#找到服务的pid</span></span><br><span class="line">pid=`ps -ef | grep <span class="variable">$APP_NAME</span> | grep -v grep | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> `</span><br><span class="line"><span class="comment">#停止服务</span></span><br><span class="line"><span class="built_in">kill</span> -9 <span class="variable">$pid</span></span><br><span class="line"><span class="comment">#启动服务</span></span><br><span class="line"><span class="built_in">nohup</span> java -jar <span class="variable">$APP_NAME</span> --spring.profiles.active=dev --javax.security.auth.useSubjectCredsOnly=<span class="literal">false</span> --java.security.krb5.debug=<span class="literal">true</span> --server.port=8888 &gt; govern.log 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="built_in">echo</span> $(<span class="built_in">date</span> +%F)<span class="string">&quot;：restart end *************&quot;</span> &gt;&gt; /opt/shFile/equipment/restartLog <span class="comment">#重启完成后打印日志</span></span><br></pre></td></tr></table></figure><p>给脚本文件赋予777权限</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 restart-blog.sh</span><br></pre></td></tr></table></figure><p>查看jdk安装路径（前提是需要配置环境变量）,得到的路径需要去确认，会变，如下图</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$JAVA_HOME</span></span><br></pre></td></tr></table></figure><p><img src="https://imge.ablog168.cn//blog_img/image-20230615145151364.png" alt="image-20230615145151364"></p><p><img src="https://imge.ablog168.cn//blog_img/image-20230615145322222.png" alt="image-20230615145322222"></p><p>也可以使用命令<code>vi /etc/profile</code></p><p><img src="https://imge.ablog168.cn//blog_img/image-20230615153444999.png" alt="image-20230615153444999"></p></li></ol><p>   添加crontab定时规则:<code>50 23 * * * /workspace/restart-blog.sh</code></p>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab -e #按下键盘i进行编辑，q!不保存退出，wq保存退出</span><br></pre></td></tr></table></figure><p>   <img src="https://imge.ablog168.cn//blog_img/image-20230615145736351.png" alt="image-20230615145736351"></p><p>   然后重启crontab</p>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/sbin/service crond restart</span><br></pre></td></tr></table></figure><p>   参考文章：<a href="https://blog.csdn.net/sun_luming/article/details/120421150">https://blog.csdn.net/sun_luming/article/details/120421150</a></p>
              </div>
            </details>
<p><br></p>
<h3 id="poi操作word文档"><a href="#poi操作word文档" class="headerlink" title="poi操作word文档"></a>poi操作word文档</h3><details class="folding-tag" cyan><summary> 点击查看 </summary>
              <div class='content'>
              <ol><li><p>maven依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-scratchpad<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>可能会报错：<code>UnsupportedFileFormatException</code>，是因为jar包的原因，可能版本太低(4.0.0)，三个版本要一致，我报错的原因是，我在公共模块服务引入的此依赖，但是在我使用模块就用不了，干脆就直接在那使用，就在那个模块引入</p></li><li><p>工具类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.poi.hwpf.HWPFDocument;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.hwpf.usermodel.Range;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ooxml.POIXMLDocument;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xwpf.usermodel.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.xmlbeans.XmlCursor;</span><br><span class="line"><span class="keyword">import</span> org.openxmlformats.schemas.wordprocessingml.x2006.main.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：李明光</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>：2023-6-14 14:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonTool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//        String filePath = &quot;C:\\Users\\Administrator\\Desktop\\1.docx&quot;;</span></span><br><span class="line"><span class="comment">//        String formart = &quot;DOCX&quot;;</span></span><br><span class="line"><span class="comment">//        Map&lt;String, String&gt; textMap = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        textMap.put(&quot;$&#123;标题&#125;&quot;, &quot;隐患整改通知书**&quot;);</span></span><br><span class="line"><span class="comment">//        textMap.put(&quot;$&#123;内容&#125;&quot;, &quot;统计报告。文档形式 配置项：报告模板、统计周期等设置。报告列表(1月季度隐患报告)，可下载。按年月日\n&quot; +</span></span><br><span class="line"><span class="comment">//                &quot;\t通报：生成--需要设置模板，不需要设置周期，它是根据统计报告的数据生成的，他的生成周期与统计报告一致。发布--是否自动发布(定时、条件-年月日)、发布范围（具体那些部门）。通报列表--可以发布、下载\n&quot; +</span></span><br><span class="line"><span class="comment">//                &quot;\n&quot; +</span></span><br><span class="line"><span class="comment">//                &quot;\t自动分派  手动分派&quot;);</span></span><br><span class="line"><span class="comment">//        textMap.put(&quot;$&#123;姓名&#125;&quot;, &quot;安全管理处&quot;);</span></span><br><span class="line"><span class="comment">//        textMap.put(&quot;$&#123;时间&#125;&quot;, &quot;2023-06-01&quot;);</span></span><br><span class="line"><span class="comment">//        textMap.put(&quot;$&#123;aaa&#125;&quot;, &quot;2023-06-0100&quot;);</span></span><br><span class="line"><span class="comment">//        wordTextSubstitution(filePath, formart, textMap, &quot;隐患整改通知书&quot;);</span></span><br><span class="line">        <span class="comment">//替换的内容，根据key为关键字指定替换成value的值</span></span><br><span class="line">        HashMap&lt;String, String&gt; textMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        textMap.put(<span class="string">&quot;$&#123;标题&#125;&quot;</span>, <span class="string">&quot;隐患整改通知书**&quot;</span>);</span><br><span class="line">        textMap.put(<span class="string">&quot;$&#123;内容&#125;&quot;</span>, <span class="string">&quot;统计报告。文档形式 配置项：报告模板、统计周期等设置。报告列表(1月季度隐患报告)，可下载。按年月日\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;\t通报：生成--需要设置模板，不需要设置周期，它是根据统计报告的数据生成的，他的生成周期与统计报告一致。发布--是否自动发布(定时、条件-年月日)、发布范围（具体那些部门）。通报列表--可以发布、下载\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;\t自动分派  手动分派&quot;</span>);</span><br><span class="line">        textMap.put(<span class="string">&quot;$&#123;姓名&#125;&quot;</span>, <span class="string">&quot;安全管理处&quot;</span>);</span><br><span class="line">        textMap.put(<span class="string">&quot;$&#123;时间&#125;&quot;</span>, <span class="string">&quot;2023-06-01&quot;</span>);</span><br><span class="line">        textMap.put(<span class="string">&quot;$&#123;aaa&#125;&quot;</span>, <span class="string">&quot;2023-06-0100&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">srcPath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\Administrator\\Desktop\\3.docx&quot;</span>;   <span class="comment">//模板文件的地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">destPath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\Administrator\\Desktop\\2.docx&quot;</span>; <span class="comment">//替换后保存的地址</span></span><br><span class="line"><span class="comment">//        searchAndReplace(srcPath, destPath, textMap);</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; headList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        headList.add(<span class="string">&quot;责任单位&quot;</span>);</span><br><span class="line">        headList.add(<span class="string">&quot;单位负责人&quot;</span>);</span><br><span class="line">        headList.add(<span class="string">&quot;统计时间段&quot;</span>);</span><br><span class="line">        headList.add(<span class="string">&quot;完成率&quot;</span>);</span><br><span class="line">        headList.add(<span class="string">&quot;及时率&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String[]&gt; bodyList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        String[] arr1 = &#123;<span class="string">&quot;保安部&quot;</span>, <span class="string">&quot;张三&quot;</span>,<span class="string">&quot;2023-06-01——2023-06-07&quot;</span>,<span class="string">&quot;50%&quot;</span>,<span class="string">&quot;80%&quot;</span>&#125;;</span><br><span class="line">        String[] arr2 = &#123;<span class="string">&quot;保安部&quot;</span>, <span class="string">&quot;李四&quot;</span>,<span class="string">&quot;2023-06-01——2023-06-07&quot;</span>,<span class="string">&quot;50%&quot;</span>,<span class="string">&quot;80%&quot;</span>&#125;;</span><br><span class="line">        String[] arr3 = &#123;<span class="string">&quot;保安部&quot;</span>, <span class="string">&quot;王五&quot;</span>,<span class="string">&quot;2023-06-01——2023-06-07&quot;</span>,<span class="string">&quot;50%&quot;</span>,<span class="string">&quot;80%&quot;</span>&#125;;</span><br><span class="line">        bodyList.add(arr1);</span><br><span class="line">        bodyList.add(arr2);</span><br><span class="line">        bodyList.add(arr3);</span><br><span class="line"></span><br><span class="line">        wordTextSubstitution(srcPath, <span class="string">&quot;DOCX&quot;</span>, textMap,<span class="string">&quot;aaa&quot;</span>,headList,bodyList);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只能替换文档内容</span></span><br><span class="line"><span class="comment">     * 可在 $&#123;table&#125; 关键字出替换为生成的表格</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath 替换文件所在路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> formart  替换文件扩展名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map      替换数据集合（关键字-实际值）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newName  新生成的文件名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headList 标题集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bodyList 每一行每一列的数据集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">wordTextSubstitution</span><span class="params">(String filePath, String formart, Map&lt;String, String&gt; map, String newName,List&lt;String&gt; headList,List&lt;String[]&gt; bodyList)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">textPath</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> file.getName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;DOCX&quot;</span>.equals(formart)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(fileName)) &#123;</span><br><span class="line">                    textPath = filePath.replaceAll(fileName, newName + <span class="string">&quot;_&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;.docx&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">XWPFDocument</span> <span class="variable">document</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XWPFDocument</span>(POIXMLDocument.openPackage(filePath));</span><br><span class="line">                <span class="comment">// 替换段落中的指定文字</span></span><br><span class="line">                Iterator&lt;XWPFParagraph&gt; itPara = document.getParagraphsIterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (itPara.hasNext()) &#123;</span><br><span class="line">                    <span class="type">XWPFParagraph</span> <span class="variable">paragraph</span> <span class="operator">=</span> itPara.next();</span><br><span class="line">                    List&lt;XWPFRun&gt; runs = paragraph.getRuns();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; runs.size(); i++) &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">oneparaString</span> <span class="operator">=</span> runs.get(i).getText(runs.get(i).getTextPosition());</span><br><span class="line">                        <span class="keyword">if</span> (oneparaString != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(oneparaString.equals(<span class="string">&quot;$&#123;table&#125;&quot;</span>))&#123; <span class="comment">// 判断该关键字是否为table，是则将数据转为表格插入</span></span><br><span class="line">                                oneparaString = oneparaString.replace(<span class="string">&quot;$&#123;table&#125;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">                                runs.get(i).setText(oneparaString, <span class="number">0</span>);</span><br><span class="line">                                <span class="type">XmlCursor</span> <span class="variable">cursor</span> <span class="operator">=</span> paragraph.getCTP().newCursor();</span><br><span class="line">                                <span class="comment">// 在指定游标位置插入表格</span></span><br><span class="line">                                <span class="type">XWPFTable</span> <span class="variable">table</span> <span class="operator">=</span> document.insertNewTbl(cursor);</span><br><span class="line"></span><br><span class="line">                                <span class="type">CTTblPr</span> <span class="variable">tablePr</span> <span class="operator">=</span> table.getCTTbl().getTblPr();</span><br><span class="line">                                <span class="type">CTTblWidth</span> <span class="variable">width</span> <span class="operator">=</span> tablePr.addNewTblW();</span><br><span class="line">                                width.setW(BigInteger.valueOf(<span class="number">8500</span>));</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span>(headList==<span class="literal">null</span>||headList.isEmpty()||bodyList==<span class="literal">null</span>||bodyList.isEmpty())&#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                insertTable(table,headList,bodyList);</span><br><span class="line"></span><br><span class="line">                            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 不是table关键字则按照文档替换进行</span></span><br><span class="line">                                <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">                                    oneparaString = oneparaString.replace(entry.getKey(), entry.getValue());</span><br><span class="line">                                &#125;</span><br><span class="line">                                runs.get(i).setText(oneparaString, <span class="number">0</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建新文件存放新内容</span></span><br><span class="line">                <span class="type">FileOutputStream</span> <span class="variable">outStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(textPath);</span><br><span class="line">                document.write(outStream);</span><br><span class="line">                outStream.close();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;DOC&quot;</span>.equals(formart)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(fileName)) &#123;</span><br><span class="line">                    textPath = filePath.replaceAll(fileName, newName + <span class="string">&quot;_&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;.doc&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">HWPFDocument</span> <span class="variable">document</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HWPFDocument</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath));</span><br><span class="line">                <span class="type">Range</span> <span class="variable">range</span> <span class="operator">=</span> document.getRange();</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">                    range.replaceText(entry.getKey(), entry.getValue());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 创建新文件存放新内容</span></span><br><span class="line">                <span class="type">FileOutputStream</span> <span class="variable">outStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(textPath);</span><br><span class="line">                document.write(outStream);</span><br><span class="line">                outStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 替换string中的预设关键字</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 源字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 关键字-要替换的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">replaceStr</span><span class="params">(String str, Map&lt;String, String&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            str = str.replace(key, map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无论替换文档和表格都可以，但没有新增表格能力</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcPath  模板文件的地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destPath 导出的文件保存地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map      替换的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">searchAndReplace</span><span class="params">(String srcPath, String destPath, Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 替换的的关键字存放到Set集合中</span></span><br><span class="line">            Set&lt;String&gt; set = map.keySet();</span><br><span class="line">            <span class="comment">// 读取模板文档</span></span><br><span class="line">            <span class="type">XWPFDocument</span> <span class="variable">document</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XWPFDocument</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcPath));</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 替换段落中的指定文字</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 读取文档中的段落，回车符为一个段落。</span></span><br><span class="line">            <span class="comment">// 同一个段落里面会被“:”等符号隔开为多个对象</span></span><br><span class="line">            Iterator&lt;XWPFParagraph&gt; itPara = document.getParagraphsIterator();</span><br><span class="line">            <span class="keyword">while</span> (itPara.hasNext()) &#123;</span><br><span class="line">                <span class="comment">// 获取文档中当前的段落文字信息</span></span><br><span class="line">                <span class="type">XWPFParagraph</span> <span class="variable">paragraph</span> <span class="operator">=</span> (XWPFParagraph) itPara.next();</span><br><span class="line">                List&lt;XWPFRun&gt; run = paragraph.getRuns();</span><br><span class="line">                <span class="comment">// 遍历段落文字对象</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; run.size(); i++) &#123;</span><br><span class="line">                    <span class="comment">// 获取段落对象</span></span><br><span class="line">                    <span class="keyword">if</span> (run.get(i) == <span class="literal">null</span>) &#123;    <span class="comment">//段落为空跳过</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">sectionItem</span> <span class="operator">=</span> run.get(i).getText(run.get(i).getTextPosition());    <span class="comment">//段落内容</span></span><br><span class="line">                    <span class="comment">// 遍历自定义表单关键字，替换Word文档中的内容</span></span><br><span class="line">                    Iterator&lt;String&gt; iterator = set.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        <span class="comment">// 当前关键字</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                        <span class="comment">// 替换内容</span></span><br><span class="line">                        sectionItem = sectionItem.replace(key, String.valueOf(map.get(key)));</span><br><span class="line">                    &#125;</span><br><span class="line">                    run.get(i).setText(sectionItem, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 替换表格中的指定文字</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//获取文档中所有的表格，每个表格是一个元素</span></span><br><span class="line">            Iterator&lt;XWPFTable&gt; itTable = document.getTablesIterator();</span><br><span class="line">            <span class="keyword">while</span> (itTable.hasNext()) &#123;</span><br><span class="line">                <span class="type">XWPFTable</span> <span class="variable">table</span> <span class="operator">=</span> (XWPFTable) itTable.next();   <span class="comment">//获取表格内容</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> table.getNumberOfRows();    <span class="comment">//表格的行数</span></span><br><span class="line">                <span class="comment">//遍历表格行的对象</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                    <span class="type">XWPFTableRow</span> <span class="variable">row</span> <span class="operator">=</span> table.getRow(i);    <span class="comment">//表格每行的内容</span></span><br><span class="line">                    List&lt;XWPFTableCell&gt; cells = row.getTableCells();   <span class="comment">//每个单元格的内容</span></span><br><span class="line">                    <span class="comment">//遍历表格的每行单元格对象</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cells.size(); j++) &#123;</span><br><span class="line">                        <span class="type">XWPFTableCell</span> <span class="variable">cell</span> <span class="operator">=</span> cells.get(j);    <span class="comment">//获取每个单元格的内容</span></span><br><span class="line">                        List&lt;XWPFParagraph&gt; paragraphs = cell.getParagraphs();      <span class="comment">//获取单元格里所有的段落</span></span><br><span class="line">                        <span class="keyword">for</span> (XWPFParagraph paragraph : paragraphs) &#123;</span><br><span class="line">                            <span class="comment">//获取段落的内容</span></span><br><span class="line">                            List&lt;XWPFRun&gt; run = paragraph.getRuns();</span><br><span class="line">                            <span class="comment">// 遍历段落文字对象</span></span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">o</span> <span class="operator">=</span> <span class="number">0</span>; o &lt; run.size(); o++) &#123;</span><br><span class="line">                                <span class="comment">// 获取段落对象</span></span><br><span class="line">                                <span class="keyword">if</span> (run.get(o) == <span class="literal">null</span> || run.get(o).equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="type">String</span> <span class="variable">sectionItem</span> <span class="operator">=</span> run.get(o).getText(run.get(o).getTextPosition());    <span class="comment">//获取段落内容</span></span><br><span class="line">                                <span class="keyword">if</span> (sectionItem == <span class="literal">null</span> || sectionItem.equals(<span class="string">&quot;&quot;</span>)) &#123;    <span class="comment">//段落为空跳过</span></span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">//遍历自定义表单关键字，替换Word文档中表格单元格的内容</span></span><br><span class="line">                                <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">                                    <span class="comment">// 替换内容</span></span><br><span class="line">                                    sectionItem = sectionItem.replace(key, String.valueOf(map.get(key)));</span><br><span class="line">                                    run.get(o).setText(sectionItem, <span class="number">0</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">outStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            outStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destPath);</span><br><span class="line">            document.write(outStream);</span><br><span class="line">            outStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据数据生成表格，并插入到word中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> table 表格对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headList 标题集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bodyList 每一行每一列的数据集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertTable</span><span class="params">(XWPFTable table,List&lt;String&gt; headList,List&lt;String[]&gt; bodyList)</span> &#123;</span><br><span class="line">        table.setWidthType(TableWidthType.AUTO);</span><br><span class="line">        <span class="type">XWPFTableRow</span> <span class="variable">row</span> <span class="operator">=</span> table.getRow(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">1</span>; col &lt; headList.size(); col++) &#123;<span class="comment">//默认会创建一列，即从第2列开始</span></span><br><span class="line">            <span class="comment">// 第一行创建了多少列，后续增加的行自动增加列</span></span><br><span class="line">            row.createCell().getCTTc().addNewTcPr();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置头部标题</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;headList.size();i++)&#123;</span><br><span class="line">            setText(row.getCell(i),headList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置每一行内容</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;bodyList.size();i++)&#123;<span class="comment">//外层循环为行数，内层循环为列数</span></span><br><span class="line">            row = table.createRow(); <span class="comment">// 创建一个新行</span></span><br><span class="line">            String[] cols = bodyList.get(i); <span class="comment">// 得到该行的列值数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;cols.length;j++)&#123; <span class="comment">// 循环列值挨个插入</span></span><br><span class="line">                setText(row.getCell(j),cols[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置表格中要被替换的字段值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setText</span><span class="params">(XWPFTableCell cell,String text)</span>&#123;</span><br><span class="line">        <span class="comment">// 设置内容居中</span></span><br><span class="line">        <span class="type">CTTc</span> <span class="variable">ctTc</span> <span class="operator">=</span> cell.getCTTc();</span><br><span class="line">        <span class="type">CTTcPr</span> <span class="variable">ctPr</span> <span class="operator">=</span> ctTc.addNewTcPr();</span><br><span class="line">        ctPr.addNewVAlign().setVal(STVerticalJc.CENTER);</span><br><span class="line">        ctTc.getPList().get(<span class="number">0</span>).addNewPPr().addNewJc().setVal(STJc.CENTER);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 替换值</span></span><br><span class="line">        cell.setText(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br></p>
<h3 id="idea相关"><a href="#idea相关" class="headerlink" title="idea相关"></a>idea相关</h3><details class="folding-tag" cyan><summary> 点击查看 </summary>
              <div class='content'>
              <ol><li><p>maven模块显示不是maven项目—解决</p><p>可能缺少<code>.iml</code>文件，idea无法识别</p><p><img src="https://imge.ablog168.cn//blog_img/image-20230704151328253.png" alt="image-20230704151328253"></p><p>先打开对应模块的命令终端，生成<code>iml</code>文件</p><p><img src="https://imge.ablog168.cn//blog_img/image-20230704151453872.png" alt="image-20230704151453872"></p><p>然后输入命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn idea:module</span><br></pre></td></tr></table></figure><p><img src="https://imge.ablog168.cn//blog_img/image-20230704152034746.png" alt="image-20230704152034746"></p><p>导入对应的模块</p><p><img src="https://imge.ablog168.cn//blog_img/image-20230704152115503.png" alt="image-20230704152115503"></p><p><img src="https://imge.ablog168.cn//blog_img/image-20230704152200271.png" alt="image-20230704152200271"></p><p><img src="https://imge.ablog168.cn//blog_img/image-20230704152213335.png" alt="image-20230704152213335"></p><p>然后再设置文件夹，点到对应的文件夹，再点击文件类型</p><p><img src="https://imge.ablog168.cn//blog_img/image-20230704152345022.png" alt="image-20230704152345022"></p></li></ol>
              </div>
            </details>
<p><br></p>
<h3 id="mysql相关"><a href="#mysql相关" class="headerlink" title="mysql相关"></a>mysql相关</h3><details class="folding-tag" cyan><summary> 点击查看 </summary>
              <div class='content'>
              <ol><li><p>设置最大连接数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;max_connections&#x27;; #查看当前的最大连接数</span><br><span class="line"></span><br><span class="line">SET GLOBAL max_connections=2000; #设置最大连接数</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br></p>
<details class="folding-tag" cyan><summary> 点击查看 </summary>
              <div class='content'>
              
              </div>
            </details>
<p><br></p>
<p><code>持续更新中......</code></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
